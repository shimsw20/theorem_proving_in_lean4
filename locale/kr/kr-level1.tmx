<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-5.7.0" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="en-US">
        <seg>"Type theory" gets its name from the fact that every expression has an
associated type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135220Z" creationid="tlqk35" creationdate="20220321T135220Z">
        <seg>'유형론'은 그것의 이름을 모든 표현은 연관된 유형을 가지고 있다는 사실로부터 갖게 되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>#check Nat → Nat      -- type the arrow as "\to" or "\r"
#check Nat -&gt; Nat     -- alternative ASCII notation

#check Nat × Nat      -- type the product as "\times"
#check Prod Nat Nat   -- alternative notation

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  same type as above

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- a "functional"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140252Z" creationid="tlqk35" creationdate="20220321T140252Z">
        <seg>#check Nat → Nat      --화살표를 쓰기 위해서 "\to"나 "\r"를 치세요.
#check Nat -&gt; Nat     -- ASCII 표기의 대체표현입니다.

#check Nat × Nat      -- 곱하기를 쓰기 위해 "\times"를 치세요.
#check Prod Nat Nat   -- 대체 표현입니다.

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  -- 위와 같은 유형입니다.

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- "범함수"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- λ and fun mean the same thing
#check fun x : Nat =&gt; x + 5     -- Nat inferred
#check λ x : Nat =&gt; x + 5       -- Nat inferred</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142214Z" creationid="tlqk35" creationdate="20220321T142214Z">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     --  λ 와 fun 같은 의미를 가집니다.
#check fun x : Nat =&gt; x + 5     --  Nat으로 추론됩니다.
#check λ x : Nat =&gt; x + 5       --  Nat으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Making sense of the type of this function requires an understanding
of dependent products, which will be explained below.)</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143305Z" creationid="tlqk35" creationdate="20220321T143305Z">
        <seg>(이 함수의 유형들을 이해하는 것은 아래에서 설명할 의존 곱에 대한 이해가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(The symbol ¬ is produced by
typing \not or \neg.)</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164334Z" creationid="tlqk35" creationdate="20220321T164334Z">
        <seg>(기호 ¬은 \not이나  \neg을 치는 것으로 만들어집니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(You can enter it with \l or
use the ascii equivalent, &lt;-.) If brevity is what we are after,
both rw and simp can do the job on their own:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180752Z" creationid="tlqk35" creationdate="20220321T180752Z">
        <seg>(여러분은 이것을 \l을 치거나 아스키 형식 &lt;-을 사용할 수 있습니다.) 우리가 간결함을 추구한다면 rw과simp이 알아서 처리해 줄 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;" is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135459Z" creationid="tlqk35" creationdate="20220321T135459Z">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;"은 불리언 and
#check b1 || b2     -- 불리언 or
#check true         -- 불리언 "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>-/

def m : Nat := 1       -- m is a natural number
def n : Nat := 0
def b1 : Bool := true  -- b1 is a Boolean
def b2 : Bool := false

/- Check their types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135403Z" creationid="tlqk35" creationdate="20220321T135342Z">
        <seg>-/

def m : Nat := 1       -- m은 자연수입니다.
def n : Nat := 0
def b1 : Bool := true  -- b1은 불리언입니다.
def b2 : Bool := false

/- 그들의 유형을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>/- Define some constants.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135320Z" creationid="tlqk35" creationdate="20220321T135320Z">
        <seg>/-  몇 가지 상수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Automated theorem proving focuses on the "finding" aspect.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131300Z" creationid="tlqk35" creationdate="20220321T131300Z">
        <seg>자동화된 정리 증명은 '찾기'에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Axioms and Computation</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171151Z" creationid="tlqk35" creationdate="20220321T171151Z">
        <seg>공리와 계산(Axioms and Computation)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent Type Theory</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170939Z" creationid="tlqk35" creationdate="20220321T170939Z">
        <seg>의존 유형론(Dependent Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Formal verification involves the use of logical and computational methods to establish claims that are expressed in
precise mathematical terms.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131125Z" creationid="tlqk35" creationdate="20220321T131125Z">
        <seg>형식 증명은 정밀한 수학적 항들로 표현된 주장을 세우는데 논리적이고 계산과학적 방법의 사용을 수반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Induction and Recursion</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171105Z" creationid="tlqk35" creationdate="20220321T171105Z">
        <seg>유도와 재귀(Induction and Recursion)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inductive Types</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171056Z" creationid="tlqk35" creationdate="20220321T171056Z">
        <seg>유도형(Inductive Types)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interacting with Lean</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171019Z" creationid="tlqk35" creationdate="20220321T171019Z">
        <seg>린과 상호작용하기(Interacting with Lean)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170931Z" creationid="tlqk35" creationdate="20220321T170931Z">
        <seg>소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propositions and Proofs</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170947Z" creationid="tlqk35" creationdate="20220321T170947Z">
        <seg>명제와 증명(Propositions and Proofs)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Quantifiers and Equality</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170959Z" creationid="tlqk35" creationdate="20220321T170959Z">
        <seg>한정기호와 동등성(Quantifiers and Equality)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structures and Records</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171114Z" creationid="tlqk35" creationdate="20220321T171114Z">
        <seg>구조체와 레코드(Structures and Records)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactic combinators are operations that form new tactics from old
ones.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145640Z" creationid="tlqk35" creationdate="20220524T145640Z">
        <seg>Tactic combinators은 이전의 전략으로부터 새로운 전략을 만드는 연산자들 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactics</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171004Z" creationid="tlqk35" creationdate="20220321T171004Z">
        <seg>전략(Tactics)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Conversion Tactic Mode</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171141Z" creationid="tlqk35" creationdate="20220321T171141Z">
        <seg>전략 모드로 전환(The Conversion Tactic Mode)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170925Z" creationid="tlqk35" creationdate="20220321T170925Z">
        <seg>린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type Classes</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171124Z" creationid="tlqk35" creationdate="20220321T171124Z">
        <seg>유형 계층(Type Classes)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>by Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich, with contributions from the Lean Community</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171326Z" creationid="tlqk35" creationdate="20220321T171326Z">
        <seg>Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich 및 Lean 커뮤니티의 기여자들 저</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>compose also takes a 3rd argument of type α which
it uses to invoke the second function (locally named f) and it
passes the result of that function (which is type β) as input to the
first function (locally named g).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144548Z" creationid="tlqk35" creationdate="20220321T144548Z">
        <seg>compose는 이는 두 번째 함수(지역적으로 f라 하는)을 호출하는데 사용되기도 하는 유형 α 를 세 번째 인수로 받습니다. 그리고 두 번째 합수는 그 함수의 결과(유형 β의)를 첫 번째 함수(지역적으로 g라 하는)의 입력으로 전달합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>compose is also very general in that it works over any type
α β γ.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144628Z" creationid="tlqk35" creationdate="20220321T144628Z">
        <seg>compose는 또 아주 일반적이어서 임의의 유형 α β γ에 대해서도 작동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>def can take multiple input parameters.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144242Z" creationid="tlqk35" creationdate="20220321T144242Z">
        <seg>def는 다수의 입력 매개변수를 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type 1 is then a larger universe of types, which contains Type
0 as an element, and Type 2 is an even larger universe of types,
which contains Type 1 as an element.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141659Z" creationid="tlqk35" creationdate="20220321T141659Z">
        <seg>Type 1는  Type 0를 원소로 갖는 유형들의 더 큰 세계이고 Type 2는 Type 1을 원소로 하는 유형들의 더욱 큰 세계입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prop has some special
features, but like the other type universes, it is closed under the
arrow constructor: if we have p q : Prop, then p → q : Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155829Z" creationid="tlqk35" creationdate="20220321T155829Z">
        <seg>Prop은 특별한 특징이 있습니다. 하지만 다른 유형 세계처럼, 화살표 생성자로 달성됩니다. 우리가 p q : Prop갖는다면  p → q : Prop입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type is
an abbreviation for Type 0:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141748Z" creationid="tlqk35" creationdate="20220321T141748Z">
        <seg>Type는 Type 0에 대한 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;tactics&gt; (or · &lt;tactics&gt;) for
structuring proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061833Z" creationid="tlqk35" creationdate="20220522T061810Z">
        <seg>&lt;tactics&gt; (혹은 · &lt;tactics&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A
number of identities in Lean's library have been tagged with the
[simp] attribute, and the simp tactic uses them to iteratively
rewrite subterms in an expression.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161005Z" creationid="tlqk35" creationdate="20220524T161005Z">
        <seg>Lean의 라이브러리 속 다수의 항등식은 [simp] 속성으로 표식되었습니다.
그리고 simp 전략은 이들을 표현식에서 부분항 다시쓰기로 반복적으로 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A calculation can be viewed as a proof as well, and these systems,
too, help establish mathematical claims.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131354Z" creationid="tlqk35" creationdate="20220321T131354Z">
        <seg>계산도 증명의 관점으로 볼 수 있으며 이런 시스템들도 수학적 진술을 세우는데 도움을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A calculational proof is just a chain of intermediate results that are
meant to be composed by basic principles such as the transitivity of
equality.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180241Z" creationid="tlqk35" creationdate="20220321T180241Z">
        <seg>계산 증명은 동등의 전달성과 같은 기본 원리로 구성된 것을 의미하는 중간 단계의 결과를 연결할 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A common idiom is to simplify a goal using local hypotheses:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T163538Z" creationid="tlqk35" creationdate="20220524T163538Z">
        <seg>흔한 관용구는 국부 가정을 사용해 목표를 단순화하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A disadvantage is that Lean does not have enough
information to infer the types of the arguments in the expressions
trans_r and trans_r hab.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174331Z" creationid="tlqk35" creationdate="20220321T174331Z">
        <seg>단점은 린이 표현식 trans_r과 trans_r hab에서 인자의 유형을 추론하기에 충분한 정보가 없다는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A first guess might be
Type → α → list α → list α, but, on reflection, this does not make
sense: the α in this expression does not refer to anything,
whereas it should refer to the argument of type Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151344Z" creationid="tlqk35" creationdate="20220321T151344Z">
        <seg>첫 번째 추측은 Type → α → list α → list α일지 모릅니다. 그러나 생각해보면 이는 말이 되지 않습니다. 이 식에서 α는 어떤 것도 지칭하지 않으므로 Type 유형을 인수로 지칭해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A proof of
p is then simply an object t : p of the right type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155903Z" creationid="tlqk35" creationdate="20220321T155903Z">
        <seg>p의 증명은 단순히 t : p 오른쪽 유형의 객체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184300Z" creationid="tlqk35" creationdate="20220321T184300Z">
        <seg>증명 항는 수학적 증명의 표현입니다. 전술은 그러한 증명를 구축하는 방법을 설명하는 명령 또는 지침입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A sequencing combinator is already implicit in the by block:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145725Z" creationid="tlqk35" creationdate="20220524T145725Z">
        <seg>순차 조합자는 by 블럭에 이미 암시적으로 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About Lean</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131709Z" creationid="tlqk35" creationdate="20220321T131709Z">
        <seg>린에 대해서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About this Book</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131959Z" creationid="tlqk35" creationdate="20220321T131959Z">
        <seg>이 책에 대하여</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135000Z" creationid="tlqk35" creationdate="20220321T135000Z">
        <seg>감사의 말</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Add support for hiding lines in other languages #1339</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171831Z" creationid="tlqk35" creationdate="20220321T171831Z">
        <seg>다른 언어 #1339에서 선을 숨기는 것의 지원을 추가하기.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding such extra information can improve the clarity of a proof and
help detect errors when writing a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161105Z" creationid="tlqk35" creationdate="20220321T161105Z">
        <seg>그런 추가 정보를 더하는 것은 증명의 명확성을 개선하고 증명을 작성할 때 오류를 감지하도록 돕습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Adding the local
modifier restricts the scope:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183259Z" creationid="tlqk3" creationdate="20220525T183259Z">
        <seg>범위를 제한하기 위해 local 수정자를 추가하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All that has changed are the braces around α : Type u in the
declaration of the variables.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153209Z" creationid="tlqk35" creationdate="20220321T153209Z">
        <seg>바뀐 것이라곤 변수 선언에서 α : Type u 주위의 괄호뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All you need to do is to provide a
label, and generalize uses it to store the assignment in the local
context:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065819Z" creationid="tlqk35" creationdate="20220522T065819Z">
        <seg>여러분이 해야할 것은 레이블을 제공하는 것과 generalize가 그 레이블을 지역 상황에 할당물을 저장하는데 사용하도록 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alternatively, you can
define tactic blocks usind curly braces and semicolons.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145218Z" creationid="tlqk35" creationdate="20220524T145218Z">
        <seg>대신 여러분은 전략 블럭을 중괄호와 세미콜론을 사용해 전략 블록을 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although the names of theorems and definitions have to be unique, the
aliases that identify them do not.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180325Z" creationid="tlqk35" creationdate="20220524T180059Z">
        <seg>로 확장됩니다. 정리와 정의의 이름은 고유하여야 함에도 별명은 그들을 식별하는 별명은 그렇지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An "axiom" would be a
constant of such a type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154916Z" creationid="tlqk35" creationdate="20220321T154916Z">
        <seg>"공리"는 그러한 유형의 상수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An expression like id or List.nil is
said to be polymorphic, because it can take on different meanings in
different contexts.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153452Z" creationid="tlqk35" creationdate="20220321T153452Z">
        <seg>다른 맥락에서 다른 의미를 가질 수 있기 때문에 id 나 List.nil 같은 표현식을 다형적이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162058Z" creationid="tlqk35" creationdate="20220321T162058Z">
        <seg>논리곱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And, indeed, it does:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143641Z" creationid="tlqk35" creationdate="20220321T143641Z">
        <seg>그리고 당연히 그럽니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another tactic that is sometimes useful is the revert tactic,
which is, in a sense, an inverse to intro.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063942Z" creationid="tlqk35" creationdate="20220522T063942Z">
        <seg>때떄로 유용한 또 다른 전략은 revert는 intro의 역방향 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any text between /- and -/ constitutes a comment block that is
ignored by Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135531Z" creationid="tlqk35" creationdate="20220321T135531Z">
        <seg> /-과 -/ 사이의 모든 글은 린에게 무시하라고 가리키는 주석을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Application can be
viewed as an "elimination rule," showing how to "eliminate" or use an
implication in a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162433Z" creationid="tlqk35" creationdate="20220321T162433Z">
        <seg>적용은 어떻게 "제거"하는지 증명에서 함의를 사용하는지를 보여주는 "제거 규칙"으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying the theorem
t1 : p → q → p to the fact hp : p that p is true yields the theorem
t1 hp : q → p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161351Z" creationid="tlqk35" creationdate="20220321T161351Z">
        <seg>정리t1 : p → q → p를 사실 hp : p에 적용하는 것은 p가 참임을 정리t1 hp : q → p을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Applying this to the "hypothesis" hab : r a b, we get a proof
of the implication r b c → r a c.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174050Z" creationid="tlqk35" creationdate="20220321T174050Z">
        <seg>이를 "가정"  hab : r a b에 적용함으로써 우리는 함의 r b c → r a c의 증명을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Architectures like SMT ("satisfiability
modulo theories") combine domain-general search methods with domain-specific procedures.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131338Z" creationid="tlqk35" creationdate="20220321T131338Z">
        <seg>SMT(Satisfiability Modulo Theories)같은 구조는 영역-일반 탐색법을 영역-특정 절차와 결합했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a
result, we can also prove the theorem as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180525Z" creationid="tlqk35" creationdate="20220321T180525Z">
        <seg>결론적으로 다음과 같이 정리를 증명할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a notational convention, we give the universal quantifier the
widest scope possible, so parentheses are needed to limit the
quantifier over x to the hypothesis in the example above.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173738Z" creationid="tlqk35" creationdate="20220321T173738Z">
        <seg>기호 규약으로써 우리는 전칭 한정기호에게 가능한 가장 넓은 범위를 줍니다. 그래서 위의 예제에서 가정의 x에만 한정사를 제한하도록 괄호가 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, Eq.subst doesn't always do what you want it
to.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180122Z" creationid="tlqk35" creationdate="20220321T180122Z">
        <seg>그러므로 Eq.subst은 여러분이 원하는 대로 항상 행하지 못합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, given h : p ∧ q, we can write h.left for
And.left h and h.right for And.right h.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163449Z" creationid="tlqk35" creationdate="20220321T163449Z">
        <seg>결과적으로 h : p ∧ q라면 우리는 h.left를 And.left h을 나타내는데 그리고 h.right 를 And.right h을 나타내는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, most of the examples we present here
work "out of the box."</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173932Z" creationid="tlqk35" creationdate="20220524T173932Z">
        <seg>그 결과 우리가 여기에 소개하는 대부분의 예제는 상식 밖의 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, some nontrivial identities can be proved by
reflexivity:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175642Z" creationid="tlqk35" creationdate="20220321T175642Z">
        <seg>결과적으로 어떤 비직관적인 항등식들이 대칭성으로부터 증명됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a result, the introduction of the connective
Implies is entirely redundant: we can use the usual function space
constructor p → q from dependent type theory as our notion of
implication.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155647Z" creationid="tlqk35" creationdate="20220321T155647Z">
        <seg>결과적으로 연결사 Implies의 도입은 완전히 중복됩니다. 그래서 우리는 의존 유형론의 함의에 대한 개념으로써 종종 함수 공간 생성자p → q를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As a theorem of propositional logic, what does t2 say?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161756Z" creationid="tlqk35" creationdate="20220321T161756Z">
        <seg>명제 논리의 정리로써 t2가 말하는 것은 무엇인가요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an exercise, try to understand
why the definition of foo below type checks, but the definition of
bar does not.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145104Z" creationid="tlqk35" creationdate="20220321T145104Z">
        <seg>연습으로 아래 유형 확인에서 foo의 정의가 왜 그런지 그러나  bar의 정의는 그렇지 않은지 이해하려고 해 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an exercise, you might
try proving the converse, that is, showing that em can be proved
from dne.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165907Z" creationid="tlqk35" creationdate="20220321T165846Z">
        <seg>연습으로 여러분은 역을 증명해보세요, 즉 em이 dne로부터 증명될 수 있음을 보이세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As another example, here is how we can express the fact that a relation, r, is transitive:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173951Z" creationid="tlqk35" creationdate="20220321T173951Z">
        <seg>또 다른 예제처럼 여기서 관계 r이 추이적이라는 사실을 어떻게 표현할지를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As another example, let us consider the composition function discussed
in the last chapter, now with propositions instead of types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161738Z" creationid="tlqk35" creationdate="20220321T161738Z">
        <seg>또 다른 예로써 지금은 유형 대신 명제로 지난 장에서 논한 합성함수를 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, the expression (fun x : Nat =&gt;  x) 1 has type Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143602Z" creationid="tlqk35" creationdate="20220321T143602Z">
        <seg>예상했다시피 표현식(fun x : Nat =&gt; x) 1 은 Nat 유형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the apply tactic is a command for constructing function
applications interactively, the intro tactic is a command for
constructing function abstractions interactively (i.e., terms of the
form fun x =&gt; e).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062425Z" creationid="tlqk35" creationdate="20220522T062425Z">
        <seg> apply 전략이 함수의 활용을 상호작용으로 만드는 명령인 것처럼 
intro 전략은 상호작용 방식으로 함수 추상화를 만드는 명령입니다. 
(예, fun x =&gt; e꼴의 항들).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the example above suggests, you have already seen an example of a function of type
Type → Type → Type, namely, the Cartesian product Prod:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141444Z" creationid="tlqk35" creationdate="20220321T141444Z">
        <seg>위 예에서 제안한 것처럼 여러분은 이미 주로 카테시안 곱 Prod에서 Type → Type → Type 유형의 함수의 예를 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As was the case for implication, the propositions-as-types
interpretation now comes into play.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173005Z" creationid="tlqk35" creationdate="20220321T173005Z">
        <seg>함의의 경우 때와 같이 유형으로써 명제 해석은 이제 제 역할을 하기 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As we will discuss further in
Attributes, one can limit the scope of an attribute to the
current file or section using the local modifier:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171536Z" creationid="tlqk35" creationdate="20220524T165401Z">
        <seg>Attributes에서 더 논의할 것이지만 누군가는 local 수정자를 
사용해 특성의 범위를 현재 파일이나 섹션으로 제한할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with have, you can leave the type implicit by writing let a
:= 3 * 2.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144507Z" creationid="tlqk35" creationdate="20220524T144507Z">
        <seg>have처럼 여러분은  let a:= 3 * 2와 같이 작성하여 유형을 암시적으로 정해지게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with rewrite, you can send simp a list of facts to use,
including general lemmas, local hypotheses, definitions to unfold, and
compound expressions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T163106Z" creationid="tlqk35" creationdate="20220524T163106Z">
        <seg>rewrite처럼 여러분은 simp를 일반적인 보조정리, 국부적인 가정, 
펼쳐지지 않은 정의와 복합 표현식을 포함한 사실들의 리스트를 사용하도록 보낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with rw, you can use the keyword at to simplify a hypothesis:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171814Z" creationid="tlqk35" creationdate="20220524T161708Z">
        <seg>rw처럼 여러분은 키워드 at으로 가정을 간단히 하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with definitions, the #print command will show you the proof of
a theorem.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161013Z" creationid="tlqk35" creationdate="20220321T161013Z">
        <seg>정의와 마찬가지로 #print명령은 정리의 증명을 여러분에게 보여줄 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with lambda abstraction notation, the
intro tactic allows us to use an implicit match.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062521Z" creationid="tlqk35" creationdate="20220522T062511Z">
        <seg>람다 추상화 기호처럼 intro 전략은 암시적인 match를 쓸 수 있도록 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with ordinary definitions, we can move the lambda-abstracted
variables to the left of the colon:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161130Z" creationid="tlqk35" creationdate="20220321T161130Z">
        <seg>평범한 정의처럼 우리는 람다 추상화된 변수를 콜론의 왼쪽으로 옮길 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with proof terms, you can omit the label in the have tactic, in
which case, the default label this is used:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143904Z" creationid="tlqk35" creationdate="20220524T143904Z">
        <seg>증명항과 마찬가지로 여러분은  have 전략 속에 레이블을 생략할 수 있습니다. 그 경우 
기본 레이블로 this가 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As with the
propositional connectives, in systems of natural deduction, "forall"
is governed by an introduction and elimination rule.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172849Z" creationid="tlqk35" creationdate="20220321T172849Z">
        <seg>명제적 연결사와 마찬가지로 자연 연역에서 "모든"은  도입과 제거 규칙에 지배받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you should by now expect, the library includes both an introduction
rule and an elimination rule.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180850Z" creationid="tlqk35" creationdate="20220321T180850Z">
        <seg>지금 예상한 대로 라이브러리는 도입 규칙과 소거 규칙 둘 다 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ascii</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162017Z" creationid="tlqk35" creationdate="20220321T161846Z">
        <seg>아스키(Ascii)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Associativity:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170134Z" creationid="tlqk35" creationdate="20220321T170134Z">
        <seg>결합성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At that point, simp applies
reflexivity to finish it off.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161449Z" creationid="tlqk35" creationdate="20220524T161228Z">
        <seg>이점에서 simp는 이를 끝내는데 반사성을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181632Z" creationid="tlqk3" creationdate="20220525T181632Z">
        <seg>특성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131401Z" creationid="tlqk35" creationdate="20220321T131401Z">
        <seg>자동화된 추론 시스템은 종종 건전성 보장을 희생해서라도 성능과 효율성을 끌어올리기 위해 애쓰고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Basic Tactics</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061845Z" creationid="tlqk35" creationdate="20220522T061845Z">
        <seg>기본 전략들</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Be careful: repeat (try t) will loop forever, because the inner tactic never fails.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151930Z" creationid="tlqk35" creationdate="20220524T151930Z">
        <seg>조심하세요. repeat (try t)는 내부 전략은 항상 실패하기 때문에 무한루프를 돌 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Be careful: not
every generalization preserves the validity of the goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065050Z" creationid="tlqk35" creationdate="20220522T065050Z">
        <seg>조심하세요. 모든 일반화가 목표의 유효성을 보존하지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Or has two constructors, we cannot use anonymous
constructor notation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164120Z" creationid="tlqk35" creationdate="20220321T164120Z">
        <seg>Or은 두 개의 생성자가 있기 때문에 우리는 익명 생성자 표기를 사용할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because equational reasoning is so common and important, Lean provides
a number of mechanisms to carry it out more effectively.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180155Z" creationid="tlqk35" creationdate="20220321T180155Z">
        <seg>방정식적인 추론은 꽤 흔하고 중요하기 때문에 린은 그것을 더 효과적으로 수행하는 다수의 메커니즘을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer
fill in as many of the details as possible.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132211Z" creationid="tlqk35" creationdate="20220321T132211Z">
        <seg>완전히 상세한 공리적 증명은 너무 복잡하기 때문에, 증명 보조기의 문제점은 컴퓨터에 가능한 많이 상세한 것들을 두어야 한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the constructors are polymorphic over types, we have to insert
the type Nat as an argument repeatedly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152448Z" creationid="tlqk35" creationdate="20220321T152448Z">
        <seg>생성자들이 유형에 대해 다형적이기 때문에, 우리는 유형 Nat를 인수로써 반복적으로 삽입해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both expressions denote the type of
functions that take a natural number as input and return a natural
number as output.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140507Z" creationid="tlqk35" creationdate="20220321T140507Z">
        <seg>두 표현식 모두 자연수를 입력으로 받아 자연수를 출력으로 반환하는 함수 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both versions are
actually notationally convenient abbreviations for a more long-winded
expression, Exists (fun x : α =&gt; p x), defined in Lean's library.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180843Z" creationid="tlqk35" creationdate="20220321T180843Z">
        <seg>두 버전 다 린의 라이브러리에 정의된 길고 장황한 표현식 Exists (fun x : α =&gt; p x)을 위한 기호적으로 편리한 약어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But
first, in this chapter, we take a break from the mechanics of type
theory to explore some pragmatic aspects of interacting with Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173156Z" creationid="tlqk35" creationdate="20220524T173121Z">
        <seg>그러나 우선 이 장에서 우리는 유형론의 원리로부터 떨어져서 린과 상호작용하는 것에 대한 실용적인 면을 탐색해봅시다</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But
for straightforward constructions like the one above, when the type of
h and the goal of the construction are salient, the notation is
clean and effective.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163519Z" creationid="tlqk35" creationdate="20220321T163519Z">
        <seg>위와 같은 간단한 구성의 경우 h의 유형과 구성의 목표가 두드러질 때 이 표기법은 깨끗하고 효과적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But
wherever a term is expected, Lean allows us to insert instead a by
&lt;tactics&gt; block, where &lt;tactics&gt; is a sequence of commands,
separated by semicolons or line breaks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184535Z" creationid="tlqk35" creationdate="20220321T184535Z">
        <seg>그러나 항이 예상되는 어디든지 린은 우리가 by &lt;tactics&gt; 블록 대신 &lt;tactics&gt;이 세미콜론이나 줄 분리자로 나눠진 일련의 명령들을 삽입하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But revert is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064249Z" creationid="tlqk35" creationdate="20220522T064249Z">
        <seg>그러나 revert는 맥락 속 요소들 뿐만 아니라 그에 의존하는 맥락의 뒤에 올 모든 요소를 되돌려 놓는 다는 점에서 아주 영리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But it is very useful for building long proofs
incrementally.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170310Z" creationid="tlqk35" creationdate="20220321T170310Z">
        <seg>하지만 이것은 긴 증명을 점진적으로 만들어 나갈 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But notice that we
have to manually disable the implicit arguments in th1, th2,
and euclr, because otherwise too many implicit arguments are
inserted.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T190327Z" creationid="tlqk3" creationdate="20220525T190327Z">
        <seg>하지만 th1과 th2, euclr에서 암시적인 인수를 수동적으로 이 기능을 해제했음을 보세요. 그렇지 않으면 너무 많은 암시적인 인수가 삽입됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But some commands have other
effects on the environment, either assigning attributes to objects in
the environment, defining notation, or declaring instances of type
classes, as described in Chapter Type Classes.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T182230Z" creationid="tlqk3" creationdate="20220525T182230Z">
        <seg>그러나 환경 속 대상에 특성을 할당하는 것이나  기호를 정의하는 것 또는Chapter Type Classes에서 설명할 유형 클래스의 개체를 선언하는 것으로 몇 가지 명령은 환경에 대해 다른 영향을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But sometimes you will want to leave this information
protected by a fully qualified name, for example, when they conflict
with identifiers in another namespace you want to use.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150453Z" creationid="tlqk35" creationdate="20220321T150453Z">
        <seg>그러나 때로는 당신이 사용할 다른 이름공간과 식별자가 충돌할 때 여러분이 이 정보가 완전히 자격을 갖춘 이름으로 보호되길 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But the simplifier detects identities that
permute their arguments, and uses a technique known as ordered
rewriting.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171747Z" creationid="tlqk35" creationdate="20220524T162449Z">
        <seg>그러나 단순화기는 항등식들이 그들의 인자를 교환한다는 것을 감지합니다. 
그리고 ordered rewriting으로 알려진 기법을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But there is
no reason to multiply languages in this way: dependent type theory is
flexible and expressive, and there is no reason we cannot represent
assertions and proofs in the same general framework.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154828Z" creationid="tlqk35" creationdate="20220321T154828Z">
        <seg>그러나 의존유형론은 유연하고 표현력 있어 이런 식으로 언어들을 늘릴 이유는 없습니다. 그리고 주장과 증명은 한 동일한 일반적 프레임워크에서 표현하지 못할 이유도 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But they can also be shorter and easier to
write.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184339Z" creationid="tlqk35" creationdate="20220321T184339Z">
        <seg>그러나 그것들은 더 짧고 더 쓰기 쉬울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But this information is
redundant: one can infer the argument α in
Lst.cons Nat 5 (Lst.nil Nat) from the fact that the second argument, 5, has
type Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152522Z" creationid="tlqk35" creationdate="20220321T152522Z">
        <seg>그러나 이 정보는 중복적입니다. Lst.cons Nat 5 (Lst.nil Nat)에서 두번째 인수 5가 Nat 유형을 가진다는 사실로부터 인수 α를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But using reverse_mk_symm is generally the right thing to do, and
it would be nice if users did not have to invoke it explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171616Z" creationid="tlqk35" creationdate="20220524T164657Z">
        <seg>하지만 reverse_mk_symm을 사용하는 것은 일반적으로 해야 하는 것입니다. 그리고 
사용자가 이를 명시적으로 불러올 필요가 없다면 좋을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But using the
type annotations in the longer version makes the proof more readable,
and can help catch and debug errors.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164102Z" creationid="tlqk35" creationdate="20220321T164102Z">
        <seg>하지만 더 긴 버전의 유형 주석을 사용하는 것은 증명을 더 가독성있게 하 에러를 잡고 고치는 걸 도와줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But we can still write h.elim instead of
Or.elim h:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164139Z" creationid="tlqk35" creationdate="20220321T164135Z">
        <seg>그러나 우리는 여전히 Or.elim h대신 h.elim와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what type should cons have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151314Z" creationid="tlqk35" creationdate="20220321T151314Z">
        <seg>그러나  cons는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But you can replace an arbitrary
expression in the goal by a fresh variable using the generalize
tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064654Z" creationid="tlqk35" creationdate="20220522T064654Z">
        <seg>하지만 여러분은 목표 속 임의의 표현식을 generalize 전략을 사용해 새 변수로 대체할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But, more importantly, equational
reasoning is supported by a term rewriter, a simplifier, and other
kinds of automation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180214Z" creationid="tlqk35" creationdate="20220321T180214Z">
        <seg>그러나 더 중요한 것은 방정식적인 추론은 항 다시쓰기, 단순화, 그리고 여타의 자동화에서도 지원된다는 점 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default,
simp includes all theorems that have been marked with the
attribute [simp].</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170118Z" creationid="tlqk35" creationdate="20220524T170118Z">
        <seg>기본적으로 simp은 [simp] 특성으로 표시한 모든 정리를 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, rw uses an equation in the forward direction, matching
the left-hand side with an expression, and replacing it with the
right-hand side.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172032Z" creationid="tlqk35" creationdate="20220524T154749Z">
        <seg>기본적으로 rw은 표현식의 좌변과 일치하면 좌변을 우변으로 대체하여 앞방향으로 방정식을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, it includes the standard library directory, and (in some contexts)
the root of the user's local project.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174406Z" creationid="tlqk35" creationdate="20220524T174406Z">
        <seg>기본적으로 이는 표준 라이브러리 경로와 (같은 맥락에서) 사용자의 로컬 프로젝트의 루트 경로를 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By default, the rewrite tactic affects only the goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171841Z" creationid="tlqk35" creationdate="20220524T160101Z">
        <seg>기본적으로 rewrite 전략은 목표에만 영향을 미칩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By now, you have seen some ways of defining objects and functions in
Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154758Z" creationid="tlqk35" creationdate="20220321T154758Z">
        <seg>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By the end
of this chapter, you will understand much of what this means.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135143Z" creationid="tlqk35" creationdate="20220321T135143Z">
        <seg>2장의 끝에서 여러분은 이것의 의미하는 바의 대부분을 이해하게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calculational Proofs</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180228Z" creationid="tlqk35" creationdate="20220321T180228Z">
        <seg>계산 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Classical Logic</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165639Z" creationid="tlqk35" creationdate="20220321T165639Z">
        <seg>고전 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comment blocks can
be nested, making it possible to "comment out" chunks of code, just as
in many programming languages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135553Z" creationid="tlqk35" creationdate="20220321T135553Z">
        <seg>주석 블록은 중첩될 수 있으며 대부분의 프로그래밍 언어처럼 코드 조각을 "주석 처리"할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Commutativity:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170129Z" creationid="tlqk35" creationdate="20220321T170129Z">
        <seg>교환성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computer algebra systems and
specialized mathematical software packages provide means of carrying out mathematical computations, establishing
mathematical bounds, or finding mathematical objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131347Z" creationid="tlqk35" creationdate="20220321T131347Z">
        <seg>컴퓨터 대수 시스템(CAS, Computer Algebra Systems)과 특정 수학 소프트웨어 패키지는 수학 계산을 수행하고 수학적 한계를 세우며, 수학적 대상을 찾는 수단을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computers and Theorem Proving</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131055Z" creationid="tlqk35" creationdate="20220321T131055Z">
        <seg>컴퓨터와 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conceptually, stating a theorem or introducing a have statement
creates a goal, namely, the goal of constructing a term with the
expected type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185523Z" creationid="tlqk35" creationdate="20220321T184354Z">
        <seg>개념적으로, 정리를 진술하거나 have 문장을 도입하는 것은 예상되는 유형으로 항를 생성하는 목표를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conjunction</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162506Z" creationid="tlqk35" creationdate="20220321T162506Z">
        <seg>연결사</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider the "barber paradox," that is, the claim that in a certain
town there is a (male) barber that shaves all and only the men who
do not shave themselves.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183829Z" creationid="tlqk35" creationdate="20220321T183829Z">
        <seg>"이발사의 역설"을 고려해보세요. 즉, 그들 자신을 면도하지 않는 남자만 면도해 준다고 주장하는 어떤 마을의 (남자) 이발사의 주장입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider the following three function definitions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145126Z" creationid="tlqk35" creationdate="20220321T145126Z">
        <seg>다음 세 함수 정의를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constructing such proofs typically requires much more input and interaction from users, but it
allows you to obtain deeper and more complex proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131511Z" creationid="tlqk35" creationdate="20220321T131511Z">
        <seg>전형적으로 이런 증명을 작성하는 것은 사용자에게 훨씬 많은 입력과 상호작용을 요구합니다. 그러나 이것은 우리가 더 깊고 복잡한 증명을 얻을 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, if you have p : Nat × Nat, then you can write
p.1 : Nat and p.2 : Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141208Z" creationid="tlqk35" creationdate="20220321T141208Z">
        <seg>반대로 여러분이 p : Nat × Nat을 갖고 있다면 p.1 : Nat과 p.2 : Nat처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, the cases tactic can be used to decompose a
disjunction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070342Z" creationid="tlqk35" creationdate="20220522T070342Z">
        <seg>반대로 cases 전략은 분리자를 분해하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, the proof of a mathematical theorem may require a
lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what
it is supposed to do.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131219Z" creationid="tlqk35" creationdate="20220321T131219Z">
        <seg>반대로 수학적 정리의 증명은 긴 계산이 필요하는데 이 경우 정리의 참을 증명하는 건 계산한 것을 증명하는 걸 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, when writing an arbitrary Lean term, you can
always invoke the tactic mode by inserting a by
block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143110Z" creationid="tlqk35" creationdate="20220524T143110Z">
        <seg>반대로 임의의 Lean 항을 작성했다면 by 블럭을 삽입하는 것으로 
전략모드를 불러올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating a function from another expression is a process known as
lambda abstraction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142243Z" creationid="tlqk35" creationdate="20220321T142243Z">
        <seg>다른 표현식으로부터 함수를 만드는 것은 람다 추상화(lambda abstraction)과정으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaring an "axiom" hp : p is tantamount to declaring that p
is true, as witnessed by hp.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161252Z" creationid="tlqk35" creationdate="20220321T161252Z">
        <seg>"공리" hp : p를 선언하는 것은 hp에서 본 바와 같이 p가 참이라고 선언하는 것과 마찬가지입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaring new objects in this manner is a good way to experiment
with the system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135914Z" creationid="tlqk35" creationdate="20220321T135914Z">
        <seg>이처럼 새로운 대상을 선언하는 것은 시스템을 실험해보는 좋은 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Definition</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161926Z" creationid="tlqk35" creationdate="20220321T161926Z">
        <seg>정의(Definition)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Definitions</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143811Z" creationid="tlqk35" creationdate="20220321T143811Z">
        <seg>정의(Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent Type Theory</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135104Z" creationid="tlqk35" creationdate="20220321T135104Z">
        <seg>의존 유형론</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent products
are also called sigma types, and you can also write them as
Σ a : α, β a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152302Z" creationid="tlqk35" creationdate="20220321T152302Z">
        <seg>의존적 곱은 sigma유형이라고 불립니다. 그리고 여러분은 그것을 Σ a : α, β a처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent type theory is a powerful and expressive language, allowing
you to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135117Z" creationid="tlqk35" creationdate="20220321T135117Z">
        <seg>의존 유형론은 여러분이 복잡한 수학적 진술을 표현할 수 있게 하고, 복잡한 하드웨어와 소프트웨어 명제를 작성할 수 있게 하며 이 둘에 대해 자연스럽고 일관성있게 추론할 수 있게 하는 강력하고 표현력 있는 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Determining that an expression t is a correct proof of assertion p would then
simply be a matter of checking that t has type Proof p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155215Z" creationid="tlqk35" creationdate="20220321T155215Z">
        <seg>표현식 t는 주장 p의 올바른 증명이다를 결정하는 것은 t가 Proof p형임을 확인하는 문제가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Disjunction</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163542Z" creationid="tlqk35" creationdate="20220321T163542Z">
        <seg>분리자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Distributivity:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170141Z" creationid="tlqk35" creationdate="20220321T170141Z">
        <seg>분배성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Double-negation elimination allows one to prove any proposition,
p, by assuming ¬p and deriving false, because that amounts
to proving ¬¬p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165828Z" creationid="tlqk35" creationdate="20220321T165828Z">
        <seg>이중 부정 제거는 여러분에게 어떤 명제  p에 대해서 ¬p를 가정하면 ¬¬p의 증명을 고려하기 때문에 false를 유도할 수 있게 허용해 줍니다.&lt;부분 1098 ¶&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each &lt;proof&gt;_i is a proof for &lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180313Z" creationid="tlqk35" creationdate="20220321T180313Z">
        <seg>각  &lt;proof&gt;_i는 &lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i에 대한 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Each style has its own advantages and disadvantages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184324Z" creationid="tlqk35" creationdate="20220321T184324Z">
        <seg>각 스타일은 그것의 장단점을 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Editor shortcut</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162042Z" creationid="tlqk35" creationdate="20220321T161859Z">
        <seg>편집 단축기(Editor shortcut)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Entering Tactic Mode</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184348Z" creationid="tlqk35" creationdate="20220321T184348Z">
        <seg>전략 모드 진입</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Equality</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175300Z" creationid="tlqk35" creationdate="20220321T175300Z">
        <seg>동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Equality is much more than an equivalence relation, however.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175705Z" creationid="tlqk35" creationdate="20220321T175705Z">
        <seg>하지만 동등은 등가 관계 그 이상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Essentially, it just checks that the
given term has the indicated type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162706Z" creationid="tlqk35" creationdate="20220321T162706Z">
        <seg>본질적으로 어떤 항이 가리키는 유형을 갖는 것을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Essentially, the rw tactic uses a given equality (which can be a
hypothesis, a theorem name, or a complex term) to "rewrite" the
goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180428Z" creationid="tlqk35" creationdate="20220321T180428Z">
        <seg>본질적으로 rw 전략은 주어진 동등성을 목표(혹은 가정, 정리, 복잡한 항이 될 수도 있음)를 "다시 쓰는데" 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Examples of Propositional Validities</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170104Z" creationid="tlqk35" creationdate="20220321T170104Z">
        <seg>명제 유효성 예제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Exercises</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170558Z" creationid="tlqk35" creationdate="20220321T170558Z">
        <seg>연습문제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>False</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161944Z" creationid="tlqk35" creationdate="20220321T161944Z">
        <seg>거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Fill in the definitions of prime
and Fermat_prime below, and construct each of the given
assertions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183913Z" creationid="tlqk35" creationdate="20220321T183913Z">
        <seg>아래의 prime과 Fermat_prime의 정의를 채우세요. 그리고 주어진 주장의 각각을 생성하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally,
we have to show q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165632Z" creationid="tlqk35" creationdate="20220321T165632Z">
        <seg>마지막으로 q임을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, applying it to the
hypothesis hbc yields a proof of the conclusion r a c.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174116Z" creationid="tlqk35" creationdate="20220321T174116Z">
        <seg>마침내, 이것을 가정 hbc에 적용하는 것으로 결론 r a c의 증명을 거둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, consider the existential quantifier, which can be written as
either exists x : α, p x or ∃ x : α, p x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180827Z" creationid="tlqk35" creationdate="20220321T180827Z">
        <seg>마지막으로 exists x : α, p x나 ∃ x : α, p x으로 쓸 수 있는 존재 한정기호를 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, the last step applies
associativity in the reverse direction rewriting a + (c + b) to
a + c + b.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171939Z" creationid="tlqk35" creationdate="20220524T155726Z">
        <seg>마침내 마지막 단계는 a + (c + b)에서 a + c + b으로 다시쓰기를 역방향으로 결합성을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, you will learn about features that are specific to Lean, including the language you use to communicate
with the system, and the mechanisms Lean offers for managing complex theories and data.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134710Z" creationid="tlqk35" creationdate="20220321T134710Z">
        <seg>마지막으로 린에 여러분이 시스템과 소통하기 위해 사용하는 언어와 복잡한 이론과 자료를 관리하기 위해 린이 제공하는 메커니즘을 포함하는 구체적인 특징에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, the application of
a function f to a value x is denoted f x (e.g., Nat.succ 2).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140728Z" creationid="tlqk35" creationdate="20220321T140728Z">
        <seg>우선 함수 f에 값 x의 활용은 f x 를 지칭합니다. (예를 들어 Nat.succ 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, we have
to show that it indeed suffices to show q, by proving the original
goal of q ∧ p with the additional hypothesis hq : q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165620Z" creationid="tlqk35" creationdate="20220321T165620Z">
        <seg>우선, 우리는 원래 목표q ∧ p 과 추가적인 가정 hq : q으로 증명함으로써 q임을 충분히 보일 수 있는 것을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, a ∧ b → c ∨ d ∧ e means (a ∧ b) → (c ∨ (d ∧
e)).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162247Z" creationid="tlqk35" creationdate="20220321T162247Z">
        <seg>예를 들어 a ∧ b → c ∨ d ∧ e은 (a ∧ b) → (c ∨ (d ∧ e))을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184328Z" creationid="tlqk35" creationdate="20220321T184328Z">
        <seg>예를 들어, 전략 스타일의 증명은 독자가 각 명령의 결과를 예측하거나 추측해야 하기 때문에 읽기가 더 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, the tactic apply And.intro tagged the first sugoal as
left, and the second as right.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061050Z" creationid="tlqk35" creationdate="20220522T061050Z">
        <seg>예를 들어, 전략  apply And.intro는 첫번째 목표를 left으로
두번째 목표를 right으로 표식을 붙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, the variable b in the expression fun (b : β) (x : α) =&gt; b
has nothing to do with the constant b declared earlier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143414Z" creationid="tlqk35" creationdate="20220321T143414Z">
        <seg>예를 들어 표현식 fun (b : β) (x : α) =&gt; b 속 변수 b는 앞서 선언된 상수 b와는 아무런 연관이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, we can use it to postulate the empty type False has an
element.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161224Z" creationid="tlqk35" creationdate="20220321T161224Z">
        <seg>예를 들어 우리는 그것을 빈 유형 False이 원소를 갖는다고 가정하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For another example, consider the
type Vector α n, the type of vectors of elements of α of
length n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150928Z" creationid="tlqk35" creationdate="20220321T150928Z">
        <seg>또 다른 예시로 유형 Vector α n을 고려해보세요. 이 벡터의 유형은 길이 n인 α를 원소로 하는 리스트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For another example, we can use the instance command to assign the
notation ≤ to the isPrefix relation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183450Z" creationid="tlqk3" creationdate="20220525T183356Z">
        <seg>다른 예제에서 우리는 instance 명령을 isPrefix관계에 ≤기호를 부여하는 데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For every p q : Prop,
p ∧ q is an example: the canonical way to construct an element is
to apply And.intro to suitable arguments hp : p and
hq : q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163129Z" creationid="tlqk35" creationdate="20220321T163129Z">
        <seg>모든 p q : Prop에 대해 p ∧ q가 예제입니다. 원소를 생성하는 정식 방법은 And.intro를 적절한 인수 hp : p과 hq : q에 대해 적용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example,
all_goals t applies t to all open goals:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T152303Z" creationid="tlqk35" creationdate="20220524T152303Z">
        <seg>예를 들어 all_goals t는 모든 끝나지 않은 목표에 t를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example,
using the hypothesis p, it rewrites p ∧ q to q and p ∨
q to true, which it then proves trivially.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171702Z" creationid="tlqk35" creationdate="20220524T163946Z">
        <seg>예를 들어 가정 p를 사용하여 이것은 p ∧ q을 q으로 그리고 p ∨
q을 true으로 다시 쓴다.  그럼 이를 명백하게 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, List α should make sense for any type
α, no matter which type universe α lives in.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141914Z" creationid="tlqk35" creationdate="20220321T141914Z">
        <seg>예를 들어 α가 어떤 유형 세계에 있던간에 List α는 임의의 유형 α에 대해 의미가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, t can be a hypothesis h : x = y in the
context; it can be a general lemma, like
add_comm : ∀ x y, x + y = y + x, in which the rewrite tactic tries to find suitable
instantiations of x and y; or it can be any compound term
asserting a concrete or general equation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172113Z" creationid="tlqk35" creationdate="20220524T153958Z">
        <seg>예를 들어 t는 맥락 속에서 가정 h : x = y이 될 수 있습니다. 
그것은 add_comm : ∀ x y, x + y = y + x같은 일반적인 보조정리일 수 있고, 
여기서 다시쓰기 전략은 x와 y 적절한 개체화를 발견하려고 노력합니다.
아니면 이것은 일반적인 방정식 혹은 구체적인 방정식을 주장하는 임의의 복합적인 항이 될 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Lean groups definitions and theorems involving lists into
a namespace List.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150513Z" creationid="tlqk35" creationdate="20220321T150513Z">
        <seg>예를 들어 Lean은 이름공간 List 속에 리스트를 포함한 정의와 정리를 묶습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if a and b are types, a -&gt; b
denotes the type of functions from a to b, and a × b
denotes the type of pairs consisting of an element of a paired
with an element of b, also known as the Cartesian product.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140041Z" creationid="tlqk35" creationdate="20220321T140041Z">
        <seg>예를 들어 a와 b가 유형이라면 a -&gt; b는 a 에서 b로 가는 함수 유형을 나타냅니다. 그리고 a × b 는 a의 원소와 b의 원소로 이뤄진 쌍을 원소로 갖는 유형을 나타냅니다. 이것을 카테시안 곱이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if we have have
hg : g 0 0 = 0 and write Exists.intro 0 hg, there are many possible values
for the predicate p, corresponding to the theorems ∃ x, g x x = x,
∃ x, g x x = 0, ∃ x, g x 0 = x, etc.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185510Z" creationid="tlqk35" creationdate="20220321T181101Z">
        <seg>예를 들어 우리가 have hg : g 0 0 = 0를 갖고 있고 Exists.intro 0 hg을 썼다면 정리  ∃ x, g x x = x, ∃ x, g x x = 0, ∃ x, g x 0 = x 등에 대응하는 술어 p에 대해 수없이 많은 가능한 값이 존재합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in a given context, x + 0 may
denote a natural number and f may denote a function on the natural
numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135242Z" creationid="tlqk35" creationdate="20220321T135242Z">
        <seg>예를들어 어떤 맥락에서 x + 0은 자연수를 가리키고  f은 자연수에 대한 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in many proof systems for
propositional logic, we have the rule of modus ponens:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154940Z" creationid="tlqk35" creationdate="20220321T154940Z">
        <seg>예를 들어 명제논리에 대한 많은 증명보조기들은 전건긍정(modus ponens)에 대한 규칙을 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, it allows
you to "partially apply" the function Nat.add.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140858Z" creationid="tlqk35" creationdate="20220321T140858Z">
        <seg>예를 들어 이는 여러분에게 함수 Nat.add의 "부분 적용"을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, one can
carry out a proof by cases:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165920Z" creationid="tlqk35" creationdate="20220321T165920Z">
        <seg>예를 들어 누군가는 경우를 나눠 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, reverting x in the example
above brings h along with it:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064343Z" creationid="tlqk35" creationdate="20220522T064343Z">
        <seg>예를 들어 위의 예제에서 x를 되돌려 놓는 것은 그것과 붙은 h를 가져옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, suppose we
define a list operation that symmetrizes its input by appending its
reversal:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171633Z" creationid="tlqk35" creationdate="20220524T164342Z">
        <seg>예를 들어 우리가 그것의 입력을 그것의 거꾸로 추가하여 
대칭시키는 리스트 연산을 정의한다고 합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, term rewriting, and Lean's automated methods for simplifying terms and
expressions automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132252Z" creationid="tlqk35" creationdate="20220321T132252Z">
        <seg>예를 들어, 항을 다시 쓰기(rewriting)와 Lean의 자동화된 항과 식의 단순화(simplifying) 기법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following creates the goal of
constructing a term of type p ∧ q ∧ p, in a context with constants
p q : Prop, hp : p and hq : q:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184434Z" creationid="tlqk35" creationdate="20220321T184434Z">
        <seg>예를 들어 , 다음은 p ∧ q ∧ p형의 항을 상수 p q : Prop과 hp : p,hq : q가 있는 현재 상황에 대해 생성하는 목표를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following implication requires classical
reasoning because, from a constructive standpoint, knowing that it is
not the case that every x satisfies ¬ p is not the same as
having a particular x that satisfies p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183059Z" creationid="tlqk35" creationdate="20220321T183059Z">
        <seg>예를 들어, 직관주의적 관점에서 모든 x가 ¬p을 만족하는 경우가 아니라는 것을 아는 것은 p를 만족하는 특정 x를 갖는 것과 같지 않기 때문에 다음의 함의는 고전적인 추론을 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the following two expressions mean the same
thing:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163416Z" creationid="tlqk35" creationdate="20220321T163416Z">
        <seg>예를 들어 다음 두 표현식은 같은 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, the tactics apply and exact
expect arbitrary terms, which you can write using have, show,
and so on.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143008Z" creationid="tlqk35" creationdate="20220524T143008Z">
        <seg>예를 들어 apply 와exact 전략은 
have, show 등등을 사용해 만든 임의의 항을 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, using
the abbreviation rw for rewrite, the proof above could be written
as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180400Z" creationid="tlqk35" creationdate="20220321T180400Z">
        <seg>예를 들어, 다시쓰기에 대해서 간략히 rw를 쓰는 것으로 위의 증명은 다음과 같이 다시 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, we could introduce a new type, Prop, to represent
propositions, and introduce constructors to build new propositions
from others.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154846Z" creationid="tlqk35" creationdate="20220321T154843Z">
        <seg>예를 들어, 우리는 새로운 유형 Prop을 명제를 나타내기 위해 도입할 수 있습니다. 그리고 다른 유형으로부터 새로운 명제를 만드는 생성자를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, when applied to a goal of the form
p ∨ q, you use tactics such as apply Or.inl and apply
Or.inr.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070256Z" creationid="tlqk35" creationdate="20220522T070256Z">
        <seg>예를 들어, p ∨ q꼴의 목표에 적용했을 때, 여러분은 apply Or.inl과 apply
Or.inr 같은 전략들을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can say that there are infinitely many
primes by asserting that for every natural number n, there is a
prime number greater than n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183935Z" creationid="tlqk35" creationdate="20220321T183935Z">
        <seg>예를 들어, 여러분은 모든 자연수 n에 대해 n보다 큰 소수가 있다고 주장하여 무한히 많은 소수가 있다고 말할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, you can use cases and constructor with an existential quantifier:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071910Z" creationid="tlqk35" creationdate="20220522T071910Z">
        <seg>예를 들어, 여러분은cases와 constructor을 존재 정량자와 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144651Z" creationid="tlqk35" creationdate="20220321T144651Z">
        <seg>예를 들어</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For now, notice that
this is an important feature of dependent type theory: every term has
a computational behavior, and supports a notion of normalization.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143711Z" creationid="tlqk35" creationdate="20220321T143711Z">
        <seg>현재로써는 이게 의존 유형론의 중요한 특징인 것만 알아 두세요. 모든 항은 전산적 거동을 하고 정규화(normalization)의 개념을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For operations that are commutative and associative, like
multiplication on the natural numbers, the simplifier uses these two
facts to rewrite an expression, as well as left commutativity.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171801Z" creationid="tlqk35" creationdate="20220524T161932Z">
        <seg>자연수 곱셈 같은 교환성과 결합성 연산자와 왼쪽 교환성과 
마찬가지로 단순화기는 표현식을 다시 쓰는데 이 두 사실을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For reference, here are two sample proofs of validities taken from the
list above.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170519Z" creationid="tlqk35" creationdate="20220321T170519Z">
        <seg>참고로 여기 위쪽의 리스트에서 가져온 유효성의 증명 예시가 두 개 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For simple sugoals, it may not be worth selecting a subgoal using its
tag, but you may still want to structure the proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061653Z" creationid="tlqk35" creationdate="20220522T061653Z">
        <seg>간단한 하위목표에 대해 그것의 표식을 이용해 하위목표를 선택하는 것은 불필요할 수 있지만
그래도 여러분은 여전히 증명을 구조화하길 원할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For that purpose, Lean provides the notion of
a section:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150040Z" creationid="tlqk35" creationdate="20220321T150040Z">
        <seg>이를 위해 Lean은  section의 개념을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For that reason, it
is common to make these arguments implicit:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174219Z" creationid="tlqk35" creationdate="20220321T174219Z">
        <seg>이런 이유로 이런 인자를 암시적으로 만드는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For that to be the case, each of them also has to have a
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141327Z" creationid="tlqk35" creationdate="20220321T141327Z">
        <seg>이렇게 하는 경우에 대해 그들 각각은 유형을 가져야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For those who like precise definitions, a Lean natural number
is an arbitrary-precision unsigned integer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135255Z" creationid="tlqk35" creationdate="20220321T135255Z">
        <seg>엄밀한 정의를 좋아하는 이들에게 린의 자연수는 부호없는 임의 정밀도의 정수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Formally, expressions that are the same up to a renaming of bound
variables are called alpha equivalent, and are considered "the
same." Lean recognizes this equivalence.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143446Z" creationid="tlqk35" creationdate="20220321T143446Z">
        <seg>공식적으로 구속 변수의 이름이 바뀌기까지 같은 표현식은 알파 등가(alpha equivalent)라 하고 "같은" 것으로 생각합니다. 린도 이를 등가로 인식합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>From a proof of Implies p q and a proof of p, we obtain a proof of q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155000Z" creationid="tlqk35" creationdate="20220321T155000Z">
        <seg>증명 Implies p q과 증명p으로부터 우리는 증명 q을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>From the
constructive point of view, proofs are abstract mathematical objects
that are denoted by suitable expressions in dependent type
theory.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160343Z" creationid="tlqk35" creationdate="20220321T160343Z">
        <seg>직관주의자의 관점에서 증명은 의존 유형론의 적절한 표현식으로 표기된추상적인 수학적 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Abstraction and Evaluation</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142123Z" creationid="tlqk35" creationdate="20220321T142123Z">
        <seg>함수 추상화와 함수값의 평가</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given α : Type and β : α → Type, think of β
as a family of types over α, that is, a type β a for each
a : α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151703Z" creationid="tlqk35" creationdate="20220321T151703Z">
        <seg>α : Type과β : α → Type이라면, β를 α에 대한 유형 족(family)으로 생각할 수 있습니다. 즉, 각각의 a : α에 대해 β a유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given a proof ∀ x : α, p x and any term t : α, we obtain a proof of p t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173000Z" creationid="tlqk35" creationdate="20220321T173000Z">
        <seg>증명 ∀ x : α, p x과 임의의 항 t : α이 있다고 하자, 그러면 우리는 p t의 증명을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given a proof of p x, in a context where x : α is arbitrary, we obtain a proof ∀ x : α, p x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172917Z" creationid="tlqk35" creationdate="20220321T172917Z">
        <seg>임의의 x : α의 상황에서 p x의 증명이 주여졌다고 하자, 그러면 우리는 증명 ∀ x : α, p x을 얻는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given a term s : (x : α) → β x and any term t : α, we have s t : β t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173120Z" creationid="tlqk35" creationdate="20220321T173120Z">
        <seg>항 s : (x : α) → β x과 임의의 항 t : α이 주어졌다고 해봅시다. 그러면 우리는 s t : β t을 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given a term t of type β x, in a context where x : α is arbitrary, we have (fun x : α =&gt; t) : (x : α) → β x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173049Z" creationid="tlqk35" creationdate="20220321T173049Z">
        <seg> β x형의 항 t 임의의 x : α에 대해서 주어졌다고 해봅시다. 그러면 우리는 (fun x : α =&gt; t) : (x : α) → β x을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given an expression
e of an inductive type Foo (possibly applied to some
arguments), the notation e.bar is shorthand for Foo.bar e.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163400Z" creationid="tlqk35" creationdate="20220321T163400Z">
        <seg>(아마 몇 가지 인수를 적용한) 유도형이 Foo인 표현식 e에 대해 e.bar과 같은 표기는 Foo.bar e의 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given that every expression in Lean has a type, it is natural to ask:
what type does Type itself have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141547Z" creationid="tlqk35" creationdate="20220321T141547Z">
        <seg>린의 모든 표현식이 유형을 가진다면 Type 그 자체는 어떤 유형을 가져야 하는지 궁금한게 당연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Go back to the exercises in Chapter Propositions and
Proofs and
Chapter Quantifiers and Equality and
redo as many as you can now with tactic proofs, using also rw
and simp as appropriate.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171356Z" creationid="tlqk35" creationdate="20220524T171356Z">
        <seg>명제와 증명과  한정기호와 동등성의 연습문제로 돌아가서 
전략 증명으로 여러분이 할 수 있는 만큼 많이 다시 해보세요. 
rw와 simp도 적절히 사용하세요..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Goldbach's weak conjecture states
that every odd number greater than 5 is the sum of three
primes.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183948Z" creationid="tlqk35" creationdate="20220321T183948Z">
        <seg>골드바흐의 약한 추측은 5보다 큰 모든 홀수 세 소수의 합으로 표현될 수 있다고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here
is an example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181420Z" creationid="tlqk35" creationdate="20220321T181420Z">
        <seg>여기 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here u_1 is a variable ranging over type levels.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141951Z" creationid="tlqk35" creationdate="20220321T141951Z">
        <seg>여기서 u_1는 어떤 유형 세계에 대한 변수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are solutions to two of the more difficult ones:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183205Z" creationid="tlqk35" creationdate="20220321T183205Z">
        <seg>여기 더 어려운 두 문제에 대한 해답이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some examples of how you can declare objects in Lean and
check their types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135259Z" creationid="tlqk35" creationdate="20220321T135259Z">
        <seg>린에서 여러분이 객체를 어떻게 선언하고 그들의 유형을 확인할 수 있는지 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some examples:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180921Z" creationid="tlqk35" creationdate="20220321T180921Z">
        <seg>여기 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some more examples</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142527Z" creationid="tlqk35" creationdate="20220321T142527Z">
        <seg>여기 추가 예제가 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some more examples
with lists:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161527Z" creationid="tlqk35" creationdate="20220524T161430Z">
        <seg>여기 추가 예제가 리스트와 함께 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is a more
elaborate example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183650Z" creationid="tlqk35" creationdate="20220321T183650Z">
        <seg>여기 더 협력(elaborate)하는 예제들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is a proof
of p ∧ q ↔ q ∧ p:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164759Z" creationid="tlqk35" creationdate="20220321T164759Z">
        <seg>여기 p ∧ q ↔ q ∧ p의 증명이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is a small example,
adapted from the last section:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165107Z" creationid="tlqk35" creationdate="20220321T165107Z">
        <seg>여기 이전 장에서 가져온 작은 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is an example of a calculation in the natural numbers that uses
substitution combined with associativity, commutativity, and
distributivity.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180018Z" creationid="tlqk35" creationdate="20220321T180018Z">
        <seg>여기 자연수에 대한 대체과 결합성, 교환성, 분배성을 혼합한 계산 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is an example of how the propositions-as-types correspondence gets put into practice.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173724Z" creationid="tlqk35" creationdate="20220321T173724Z">
        <seg>여기에 유형으로써 명제 대응이 현장에서 어떻게 놓이는지에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is an example of how we can carry out elementary reasoning with an equivalence relation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174357Z" creationid="tlqk35" creationdate="20220321T174357Z">
        <seg>이곳은 우리가 어떻게 동등 관계로 초등적인 추론을 하는지 예시를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is an example of rewriting using a compound expression:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T154307Z" creationid="tlqk35" creationdate="20220524T154307Z">
        <seg>여기서 복합 표현식을 사용하는 다시쓰기의 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is an example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180323Z" creationid="tlqk35" creationdate="20220321T180323Z">
        <seg>여기 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is another example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072437Z" creationid="tlqk35" creationdate="20220522T072437Z">
        <seg>여기 또 다른 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is another example: given any type α, the type List α
denotes the type of lists of elements of type α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141520Z" creationid="tlqk35" creationdate="20220321T141520Z">
        <seg>또 다른 예제가 있습니다. α라 하는 임의의 타입에 대해 List α의 유형은 α 유형을 원소로 하는 리스트 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is another useful trick.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170408Z" creationid="tlqk35" creationdate="20220321T170408Z">
        <seg>여기 또 유용한 트릭이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here the rewrite tactic, abbreviated rw, uses h to replace
x by 3 again.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070102Z" creationid="tlqk35" creationdate="20220522T070016Z">
        <seg>여기 rewrite 전략은 rw로 축약되었고, h를 써서 x가 다시 3으로 바뀌게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here the left arrow before Nat.add_assoc tells rewrite to use the
identity in the opposite direction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180724Z" creationid="tlqk35" creationdate="20220321T180724Z">
        <seg>Nat.add_assoc 앞의 왼쪽 화살표는 항등식을 반대 방향으로 사용해 다시쓰라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here,
generalize replaces a goal that could be proved using
rfl with one that is not provable:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065254Z" creationid="tlqk35" creationdate="20220522T065254Z">
        <seg>여기서 generalize는 rfl을 사용해 증명할 수 있는 목표를 
증명가능하지 않은 것으로 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, apply Or.inl; assumption is functionally equivalent to a
single tactic which first applies apply Or.inl and then applies
assumption.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145831Z" creationid="tlqk35" creationdate="20220524T145831Z">
        <seg>여기  apply Or.inl; assumption는 기능적으로 apply Or.inl을 
적용한 뒤 assumption을 적용한 한 개의 전략과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, h hq establishes the equation x = y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172051Z" creationid="tlqk35" creationdate="20220524T154343Z">
        <seg>여기서 h hq가 방정식 x = y을 세웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, twice_double x is definitionally equal to the term (x + x) * (x + x).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144822Z" creationid="tlqk35" creationdate="20220321T144822Z">
        <seg>여기서twice_double x도 항  (x + x) * (x + x)과 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, for example, is a proof of ¬p → q → (q → p) → r:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164515Z" creationid="tlqk35" creationdate="20220321T164515Z">
        <seg>여기 ¬p → q → (q → p) → r의 증명에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the axiom declaration postulates the existence of an
element of the given type and may compromise logical consistency.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161204Z" creationid="tlqk35" creationdate="20220321T161204Z">
        <seg>여기서 axiom 선언은 주어진 유형의 원소의 존재성을 가정하고 논리적 일관성을 타협할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, the constructor tactic leaves the first component of the
existential assertion, the value of x, implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072049Z" creationid="tlqk35" creationdate="20220522T072049Z">
        <seg>여기서  constructor 전략은 존재 가정의 첫 요소 암시적으로 x의 값으로 남깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How to deploy</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172355Z" creationid="tlqk35" creationdate="20220321T172355Z">
        <seg>작동시키는 법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, in Section Setting Options, we will
discuss Lean's mechanisms for setting options, which does not follow
this pattern: options can only be set locally, which is to say,
their scope is always restricted to the current section or current
file.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184117Z" creationid="tlqk3" creationdate="20220525T184117Z">
        <seg>하지만 Section Setting Options에서 우리는 린의 이 패턴을 따르지 않는 옵션 설정에 대한 메커니즘에 대해서 얘기할 것입니다. 옵션은 지역적으로만 설정될 수 있습니다. 그 말은 즉, 그들의 범위는 항상 현재 섹션이나 현재 파일로 제한됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, such commands often support the local modifier,
which indicates that they only have effect until
the current section or namespace is closed, or until the end
of the current file.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T182533Z" creationid="tlqk3" creationdate="20220525T182533Z">
        <seg>하지만 이런 명령은 종종 이들이 현재 section이나 namespace이 닫힐 때까지 혹은 현재 파일의 끝까지만 유효하다는 것을 가리키는 local 수정자를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, you can use the combinator unhygienic to disable this restriction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063341Z" creationid="tlqk35" creationdate="20220522T063253Z">
        <seg>하지만 여러분은 unhygienic 조합자를 사용해서 이 제한을 해제할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Identifiers in Lean can include any alphanumeric characters, including
Greek characters (other than ∀ , Σ , and λ , which, as we have seen,
have a special meaning in the dependent type theory).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T191054Z" creationid="tlqk3" creationdate="20220525T191054Z">
        <seg>린의 식별자들은 임의의 그리스 문자를 포함해 (우리가 본 ∀ , Σ , λ 외에도  종속 유형론에서 특별한 의미를 갖습니다.) 알파벳과 수치 문자를 포함할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If
Lean tries to do so and fails, it returns with an error message "don't
know how to synthesize placeholder," followed by the type of
the term it is expecting, and all the objects and hypothesis available
in the context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170450Z" creationid="tlqk35" creationdate="20220321T170450Z">
        <seg>만약 린이 그렇게 하려고 했는데 실패한다면 다음에 오는 항의 유형을 기대했다면서 "어떻게 자리 차지자를 동기화 해야할 지 모르겠다"는 오류 메시지를 반환합니다. 그리고 모든 객체와 가정들은 맥락에서 이용가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If q does not mention
w, then showing that q follows from p w is tantamount to
showing the q follows from the existence of any such x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181413Z" creationid="tlqk35" creationdate="20220321T181413Z">
        <seg>q가  w를 언급하지 않았다면 p w로부터 q가 따름을 보이는 것으로 임의의 x의 존재함으로부터  q를 보이기에 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If foo is such a function, the
notation @foo denotes the same function with all the arguments
made explicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153735Z" creationid="tlqk35" creationdate="20220321T153735Z">
        <seg>만약 foo가 그런 함수라면 @foo 표기는 모든 인수가 명시적으로 된 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If j is not 0, then (x : α) → β is
an element of Sort (max i j).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174654Z" creationid="tlqk35" creationdate="20220321T174654Z">
        <seg>만약 j가 0이 아니라면 (x : α) → β는 Sort (max i j)의 원소이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If p and q have been declared as variables, Lean will
generalize them for us automatically:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161522Z" creationid="tlqk35" creationdate="20220321T161522Z">
        <seg>p와 q가 변수로 선언되었다면 린은 우리를 위해 자동적으로 일반화시킬 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If p is any expression,
∀ x : α, p is nothing more than alternative notation for
(x : α) → p, with the idea that the former is more natural than the latter
in cases where p is a proposition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173317Z" creationid="tlqk35" creationdate="20220321T173317Z">
        <seg>만약 p가 임의의 표현식이면, ∀ x : α, p은 그저 (x : α) → p에 대한 대체 표현일 뿐입니다. 전자의 생각은  p가 명제인 후자의 경우보다 자연스럽습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If RH represents the Riemann
hypothesis, a classical mathematician is willing to assert
RH ∨ ¬RH, even though we cannot yet assert either disjunct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165749Z" creationid="tlqk35" creationdate="20220321T165749Z">
        <seg>만약 RH가 리만 가설을 나타낸다면 우리가 아직 어느쪽에 분리자를 주장하지 않았더라도 고전 수학자는 RH ∨ ¬RH라고 기꺼이 주장할 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If doing so reduces the goal to an identity t = t, the
tactic applies reflexivity to prove it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180439Z" creationid="tlqk35" creationdate="20220321T180439Z">
        <seg>그렇게 하면 항등식 t = t로 목표를 축소합니다. 전략은 그것을 증명하는데 대칭성을 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If that is not the one
you want, you can use additional arguments to specify the appropriate
subterm.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172003Z" creationid="tlqk35" creationdate="20220524T155415Z">
        <seg>만약 이게 여러분이 원한 것이 아니라면 여러분은 추가 인수를 사용해 적절한 부분항을 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If the proof is incomplete, the token by is
decorated with a red squiggly line, and the error message contains the
remaining goals.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060519Z" creationid="tlqk35" creationdate="20220522T060519Z">
        <seg>만일 증명이 불완전하다면, 토큰 by은 빨간색 구불구불한 선으로 장식됩니다.
그리고 오류 메시지가 남은 목표에 포함됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If this command is used outside a namespace, the aliases
are exported to the top level.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181612Z" creationid="tlqk3" creationdate="20220525T181612Z">
        <seg>이 명령이 이름공간 밖에서 사용된다면 별명은 최상위 단계로 내보내지게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you
don't want that to happen, you have to write @t instead.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184653Z" creationid="tlqk3" creationdate="20220525T184653Z">
        <seg>여러분이 이것이 일어나기 원하지 않는다면 대신 @t를 써줘야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you are not used to thinking constructively, it may take some time
for you to get a sense of where classical reasoning is used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170002Z" creationid="tlqk35" creationdate="20220321T170002Z">
        <seg>여러분이 직관적으로 생각하는데 익숙치 않다면 고전 추론이 사용되는 곳을 이해하는데 약간의 시간이 소요될지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you are reading the book online, you will see a button that reads "try it!" Pressing the button opens up a tab with a
Lean editor, and copies the example with enough surrounding context to make the code compile correctly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134929Z" creationid="tlqk35" creationdate="20220321T134929Z">
        <seg>여러분이 온라인으로 책을 읽는다면 "실행해보기"라 적힌 버튼을 볼 것입니다. 버튼을 누르면 린 편집기 탭이 열리면서 코드가 올바르게 컴파일되도록 주변 맥락을 포함해 예제를 복사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you do name a section, however, you
have to close it using the same name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150146Z" creationid="tlqk35" creationdate="20220321T150146Z">
        <seg>그러나 여러분이 섹션에 이름을 붙이고자 한다면 같은 이름을 사용해 이를 닫아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want
to specify a witness to the existential quantifier explicitly, you can
use the exists tactic instead:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072410Z" creationid="tlqk35" creationdate="20220522T072410Z">
        <seg>여러분이 명시적으로 존재정량자를 나타내 보도록하길 원한다면,
대신exists 전략을 사용하면 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to use additional files, however, they need to be imported
manually, via an import statement at the beginning of a file.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174028Z" creationid="tlqk35" creationdate="20220524T174028Z">
        <seg>그러나 여러분이 추가 파일을 사용하길 원한다면 파일의 시작에서 import 구문을 통해 수동으로 불러와야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit Arguments</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152413Z" creationid="tlqk35" creationdate="20220321T152413Z">
        <seg>암시적 인자(Implicit Arguments)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Importing Files</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173340Z" creationid="tlqk35" creationdate="20220524T173340Z">
        <seg>파일 불러오기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In
principle, two terms that reduce to the same value are called
definitionally equal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143728Z" creationid="tlqk35" creationdate="20220321T143723Z">
        <seg>원리적으로 같은 값으로 축약되는 두 항은 정의상으로 동등(definitionally equal)하다고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In
the case of multiplication the latter is expressed as follows:
x * (y * z) = y * (x * z).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171754Z" creationid="tlqk35" creationdate="20220524T162041Z">
        <seg>곱셈의 경우 후자는 다음과 같이 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In
this case, however, apply would work just as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055358Z" creationid="tlqk35" creationdate="20220522T055358Z">
        <seg>하지만 이 경우 apply도 마찬가지로 잘 작동할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Chapter Inductive Types,
we will explain how equality is defined from the primitives of Lean's logical framework.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175415Z" creationid="tlqk35" creationdate="20220321T175415Z">
        <seg>유도형 장에서 우리는 어떻게 동등이 린의 기초적인 논리 프레임워크로부터 정의되는지 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Section Implicit Arguments,
we saw that if Lean displays the type
of a term t as {x : α} → β x, then the curly brackets
indicate that x has been marked as an implicit argument to
t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184454Z" creationid="tlqk3" creationdate="20220525T184454Z">
        <seg>Section Implicit Arguments에서 우리는 린은 항 t의 유형을 {x : α} → β x으로 표시하고 나서 중괄호는 x가  암시적인 인수로써 t로 표시되었음을 나타냄을 봤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Section Notation below, we will discuss Lean's
mechanisms for defining notation, and see that they also support the
local modifier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183843Z" creationid="tlqk3" creationdate="20220525T183843Z">
        <seg>아래 Section Notation에서 우리는 린의 기호를 정의하는 메커니즘에 대해 얘기하고 또 이들이 local 수정자를 지원함을 볼 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Section Using the Simplifier,
we saw that theorems can be annotated with the [simp] attribute,
which makes them available for use by the simplifier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T182721Z" creationid="tlqk3" creationdate="20220525T182721Z">
        <seg>Section Using the Simplifier에서 우리는 정리들이 단순화기에 의한 사용이 가능하도록 만드는 [simp] 특성이 붙는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In t₁ &lt;;&gt; t₂, the &lt;;&gt; operator provides a parallel version of the sequencing operation:
t₁ is applied to the current goal, and then t₂ is applied to all the resulting subgoals:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150229Z" creationid="tlqk35" creationdate="20220524T150229Z">
        <seg>t₁ &lt;;&gt; t₂에서 &lt;;&gt; 연산자는 순차 연산의 버전에 대해 parallel을 제공합니다.
t₁는 현재 목표에 적용되고 그 후  t₂은 출력되는 하위목표 all에 적용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Emacs, you can see the goal at the end of any
line by pressing C-c C-g, or see the remaining goal in an
incomplete proof by putting the cursor after the first character of
the last tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055948Z" creationid="tlqk35" creationdate="20220522T055823Z">
        <seg>Emacs에서 여러분은 임의의 줄의 끝에서 C-c C-g을 눌러 목표를 볼 수 있습니다. 
아니면 마지막 전략의 첫 문자 뒤에 커서를 놓으면 불완전한 증명에 대한 나머지 목표를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Lean, a calculation proof starts with the keyword
calc, and has the following syntax:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180258Z" creationid="tlqk35" creationdate="20220321T180258Z">
        <seg>린에서 계산 증명은 키워드 calc로 시작합니다. 그리고 다음 문법을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Lean, identifiers are given by hierarchical names like
Foo.Bar.baz.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175657Z" creationid="tlqk35" creationdate="20220524T175609Z">
        <seg>린에서 식별자는 Foo.Bar.baz처럼 계층적인 names으로 제시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Lean, one uses an underscore, _, to specify
that the system should fill in the information automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152757Z" creationid="tlqk35" creationdate="20220321T152757Z">
        <seg>Lean에서 누군가는 시스템이 자동적으로 정보를 채워넣도록 명시하기 위해 밑줄문자(_)를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Lean, the
theorem command introduces a new theorem:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160647Z" creationid="tlqk35" creationdate="20220321T160647Z">
        <seg>린에서 theorem 명령은 새로운 정리를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In VS Code, you can open
a window to display messages by pressing Ctrl-Shift-Enter, and
that window will then show you the current goal whenever the cursor is
in a tactic block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055738Z" creationid="tlqk35" creationdate="20220522T055738Z">
        <seg>VS Code에서 여러분은  Ctrl-Shift-Enter을 눌러 메시지을 보고자 창을 열 수 있습니다. 
그러면 이 창은 전략 블록 속의 커서가 어디에 있든지 간에 현재 목표를 여러분에게 보여줄 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a nested block,
Lean focuses on the first goal, and generates an error if it has not
been fully solved at the end of the block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144844Z" creationid="tlqk35" creationdate="20220524T144844Z">
        <seg>중첩된 블럭 속에 Lean은 첫번째 목표에 집중하고 블록 끝에서도 완전히 풀리지 않는다면 오류를 발생시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a proof, there are often multiple goals outstanding.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T152042Z" creationid="tlqk35" creationdate="20220524T152042Z">
        <seg>증명에서 종종 두드러진 다수의 목표들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to apply and exact, another useful tactic is
intro, which introduces a hypothesis.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062004Z" creationid="tlqk35" creationdate="20220522T062004Z">
        <seg>apply과 exact에 더해 또 다른 유용한 전략은 가정을 도입하는 intro입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In addition to axioms, however, we would also need rules to build new
proofs from old ones.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154932Z" creationid="tlqk35" creationdate="20220321T154932Z">
        <seg>하지만 공리에 더해 우리는 이전 증명으로부터 새로운 증명을 만드는데 사용할 규칙도 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all cases, the command #print t1 still yields
∀ p q : Prop, p → q → p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161633Z" creationid="tlqk35" creationdate="20220321T161633Z">
        <seg>모든 경우에 명령 #print t1은 여전히 ∀ p q : Prop, p → q → p을 출력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In all these cases, the attribute remains in effect in any file that
imports the one in which the declaration occurs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183219Z" creationid="tlqk3" creationdate="20220525T183219Z">
        <seg>모든 경우에 대해서, 특성은 선언이 있는 파일을 불러온 임의의 파일에 대해 영향을 미칩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In any case, all that really matters is the bottom line.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160455Z" creationid="tlqk35" creationdate="20220321T160455Z">
        <seg>어떤 경우에는 가장 중요한 것은 아래의 문장입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In any case, the additional rules are
added to the collection of identities that are used to simplify a
term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171713Z" creationid="tlqk35" creationdate="20220524T163318Z">
        <seg>어떤 경우에 항을 간단히 하는데 사용되는 항등식의 모임에 추가 규칙이 더해질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, interactive
theorem proving focuses on the "verification" aspect of theorem proving, requiring that every claim is supported by a
proof in a suitable axiomatic foundation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131435Z" creationid="tlqk35" creationdate="20220321T131435Z">
        <seg>반대로 상호작용 증명기는 모든 진술은 적절한 공리적 기초에 의한 증명으로 지지될 것을 요구하면서 정리 증명의 "식별" 측면에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, if we think in terms of the coding trick
described above, then the expressions themselves do not denote
anything interesting.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160400Z" creationid="tlqk35" creationdate="20220321T160400Z">
        <seg>반대로 위에서 설명한 코딩 트릭으로 생각한다면 표현식 그 자체는 어떤 흥미로운 것도 나타내지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact,
the expression denotes the same function as fun (u : β) (z : α) =&gt; u.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143430Z" creationid="tlqk35" creationdate="20220321T143430Z">
        <seg>사실 표현식은  fun (u : β) (z : α) =&gt; u처럼 같은 함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, Lean is generally
able to process and check proofs in parallel, since assessing the
correctness of one proof does not require knowing the details of
another.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161001Z" creationid="tlqk35" creationdate="20220321T161001Z">
        <seg>사실, 어떤 증명의 옳음에 접근하는 것은 다른 것의 상세를 알 필요가 없기 때문에 린은 일반적으로 증명의 검증과 처리를 병렬적으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, by the propositions-as-types correspondence, we can declare
the assumption hp that p holds, as another variable:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161547Z" creationid="tlqk35" creationdate="20220321T161547Z">
        <seg>사실 유형으로써 명제 대응에 의해 우리는 p를 가진 가정 hp를을 또다른 변수로 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, more should be true: applying the expression (fun x : Nat
=&gt; x) to 1 should "return" the value 1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143634Z" creationid="tlqk35" creationdate="20220321T143634Z">
        <seg>사실, 더 중요한건 표현식(fun x : Nat =&gt; x)을 1에 적용하는 것은 값 1을 "반환"하는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, most such systems provide fully elaborated "proof objects" that can be communicated to other systems and
checked independently.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131457Z" creationid="tlqk35" creationdate="20220321T131457Z">
        <seg>사실, 그런 시스템의 대부분은 증명 대상과의 완전한 협력을 제공합니다. 이 대상은 다른 시스템과 상호작용될 수 있고 독립적으로 검증될 수 있습니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, the
notation is defined in Lean as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183515Z" creationid="tlqk35" creationdate="20220321T183515Z">
        <seg>사실 린에서 정의된 기호는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, the function
id is defined in the standard library in exactly this way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153328Z" creationid="tlqk35" creationdate="20220321T153328Z">
        <seg>사실 함수 id는 표준 라이브러리에서도 이와 정확히 동일한 방식으로 정의되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, the type Prop is
syntactic sugar for Sort 0, the very bottom of the type hierarchy
described in the last chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155739Z" creationid="tlqk35" creationdate="20220321T155739Z">
        <seg>사실 Prop형은 Sort 0에 대한 문법적 설탕입니다. 유형 계층의 최하층은 마지막 장에서 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, there is a show tactic, which is similar to the
show expression in a proof term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143254Z" creationid="tlqk35" creationdate="20220524T143254Z">
        <seg>사실 증명항에서 show 표현식과 비슷한 show 전략이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, we can compress the full tactic down to one line:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172122Z" creationid="tlqk35" creationdate="20220524T152820Z">
        <seg>사실, 우리는 완전한 전략을 한 줄로 압축시킬 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, with this
notation, you can even omit both the type and the label, in which case
the new fact is introduced with the label this.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144138Z" creationid="tlqk35" creationdate="20220524T144138Z">
        <seg>사실 이 기호와 관련해서 여러분은 심지어 유형과 레이블 모두 생략할 수 있습니다. 
그 경우 새로운 사실은 this 레이블로 도입됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In full generality, the problem of
determining whether a higher-order unifier exists is undecidable, and
Lean can at best provide imperfect and approximate solutions to the
problem.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180110Z" creationid="tlqk35" creationdate="20220321T180110Z">
        <seg>완전 일반적으로 고차 통합자가 존재하는지 정하는 문제는 결정 불가능합니다. 그리고 린은 최선을 다해 이 문제에 부정확하지만 근사적인 해를 제공할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In light of that fact,
Lean tags proofs as irreducible, which serves as a hint to the
parser (more precisely, the elaborator) that there is generally no
need to unfold it when processing a file.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160948Z" creationid="tlqk35" creationdate="20220321T160948Z">
        <seg>그 사실에 비춰보면 린의 증명을 줄일 수 없는 것으로 태그한다. 그리고 그것은 파서(더 정확히는  협력기)에게 파일을 처리할 때 증명을 펼칠 필요가 없다는 힌트를 주는 역할을 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In many respects, however, a namespace ... end block behaves the
same as a section ... end block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150718Z" creationid="tlqk35" creationdate="20220321T150718Z">
        <seg>하지만 여러 관점에서 namespace ... end블록은 section ... end블록과 동일하게 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most cases, the first argument of Or.intro_right and
Or.intro_left can be inferred automatically by Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163946Z" creationid="tlqk35" creationdate="20220321T163946Z">
        <seg>대게의 경우  Or.intro_right와 Or.intro_left의 첫번째 인수는 린에 의해 자동적으로 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In normal circumstances, it is never necessary to
unfold the "definition" of a theorem; by proof irrelevance, any two
proofs of that theorem are definitionally equal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160904Z" creationid="tlqk35" creationdate="20220321T160904Z">
        <seg>평범한 상황에서 증명 무연관에 의해 정리의 "정의"를 펼칠 필요는 절대 없습니다. 그리고 그 정리의 임의의 두 증명도 정의상으로 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other
words, assuming α : Type is the first argument to the function,
the type of the next two elements are α and List α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151425Z" creationid="tlqk35" creationdate="20220321T151425Z">
        <seg>다시 말하면 함수의 첫 번째 인수로  α : Type으로  가정하면 다음 두 원소의 유형은  α와 List α가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words,
True is simply true, and has a canonical proof, True.intro.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164603Z" creationid="tlqk35" creationdate="20220321T164603Z">
        <seg>다시 말하자면 True는 단순히 참이고, 정식 증명 True.intro를 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, s is a proof of p,
t is a proof of the desired conclusion assuming h : p, and the
two are combined by a lambda abstraction and application.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165203Z" creationid="tlqk35" creationdate="20220321T165203Z">
        <seg>다시 말하자면 s는 p의 증명입니다. h : p를 가정한 t는 원하는 결론의 증명입니다. 그리고 이 둘은 람다 추상화와 적용으로 결합되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, double-negation elimination allows
one to carry out a proof by contradiction, something which is not
generally possible in constructive logic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165833Z" creationid="tlqk35" creationdate="20220321T165833Z">
        <seg>다시 말하자면 이중 부정 제거는 직관주의적 논리에서 일반적으로 불가능한 귀류법을 사용한 증명을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, for each unresolved placeholder, Lean
reports the subgoal that needs to be filled at that point.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170458Z" creationid="tlqk35" creationdate="20220321T170458Z">
        <seg>다시 말하자면 각 해결되지 않은 자리 차지자에 대해 린은 그 지점에서 채워져야 할 작은 목표를 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, for every α,
cons α is the function that takes an element a : α and a list
as : List α, and returns a new list, so you have cons α a as : List α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151242Z" creationid="tlqk35" creationdate="20220321T151242Z">
        <seg>다시 말하면 모든 α에 대해  cons α는 원소 a : α와 리스트 as : List α를 받는 함수입니다.  그리고 새로운 리스트를 반환합니다. 그래서 여러분은  cons α a as : List α를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, if β is a
proposition depending on α, then ∀ x : α, β is again a
proposition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175033Z" creationid="tlqk35" creationdate="20220321T175033Z">
        <seg>다시 말해서, 만약 β가 α에 의존하는 명제라면 ∀ x : α, β도 다시 명제인 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, if you import Foo and Foo imports Bar,
then you also have access to the contents of Bar, and do not need to import it explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174626Z" creationid="tlqk35" creationdate="20220524T174626Z">
        <seg>다시 말하면, 여러분이 Foo를 부르고 Foo는 Bar를 불러온다면
여러분은 Bar의 내용에도 접근할 수 있습니다. 그리고 명시적으로 불러올 필요가 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, implication between propositions p and q
corresponds to having a function that takes any element of p to an
element of q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155625Z" creationid="tlqk35" creationdate="20220321T155625Z">
        <seg>다시 말하면, 명제  p과 q사이의 함의는  p의 원소에서 q의 원소로 가는 함수를 갖는 것에 대응된니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, it is a
proof by cases.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163805Z" creationid="tlqk35" creationdate="20220321T163805Z">
        <seg>다시 말하자면 경우에 따라 증명한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, the expressions
themselves are the proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160431Z" creationid="tlqk35" creationdate="20220321T160431Z">
        <seg>다시 말하자면 표현식 그들 자체는 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, the type of
dependent functions from α to β "lives" in the universe whose
index is the maximum of i and j.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174838Z" creationid="tlqk35" creationdate="20220321T174838Z">
        <seg>다시 말하면, α에서 β로의 의존 함수 유형이 그것의 첨자가 i와 j 중 최대값인 유형세계에 "성립한다"입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, the type of the value
returned by f depends on its input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151837Z" creationid="tlqk35" creationdate="20220321T151837Z">
        <seg>다시 말하자면 f에 의해 반환되는 값의 유형은 그것의 입력에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, whenever we have p : Prop, we
can interpret p as a type, namely, the type of its proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155450Z" creationid="tlqk35" creationdate="20220321T155450Z">
        <seg>다시 말하자면, p : Prop를 갖는한 우리는p를 유형으로써 대게 그것의 증명형으로  해석할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular,
we can define predicates on α by quantifying over all predicates
on α, which is exactly the type of circularity that was once
considered problematic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175253Z" creationid="tlqk35" creationdate="20220321T175253Z">
        <seg>특히, 우리는 α에 대한 술어를 α에 대한 모든 술어를 한정함으로써 정의할 수 있습니다. 그리고 이게 한때 문제라고 여겼던 순환 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, if you use the
variable command within a namespace, its scope is limited to the
namespace.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150731Z" creationid="tlqk35" creationdate="20220321T150731Z">
        <seg>특히, 이름공간 안에서 variable 명령을 사용한다면 그것의 범위는 이름공간으로 제한될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, we
can often write ⟨hp, hq⟩ instead of And.intro hp hq:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163302Z" creationid="tlqk35" creationdate="20220321T163302Z">
        <seg>특히 And.intro hp hq대신  ⟨hp, hq⟩와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, there is not a
sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal
verification requires describing hardware and software systems in mathematical terms, at which point establishing claims
as to their correctness becomes a form of theorem proving.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131208Z" creationid="tlqk35" creationdate="20220321T131208Z">
        <seg>실제로 수학의 일부를 식별하는 것과 시스템의 명확성을 식별하는 것 사이에 명확한 구분이 없습니다. 형식 증명은 하드웨어와 소프트웨어 시스템을 수학적 항으로 묘사하기를 요구합니다. 그리고 그때 그들의 올바름에 대한 주장을 세우는 것은 정리 증명의 형태가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In situations like this, it can be tedious to supply the arguments
a b c, when they can be inferred from hab hbc.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174212Z" creationid="tlqk35" creationdate="20220321T174212Z">
        <seg>그들이 hab hbc으로부터 추론될 수 있을 때, 인자 a b c를 제공하는 것은 번거로울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In that case,
(x : α) → β is an element of Sort 0 as well, no matter which
type universe α lives in.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175001Z" creationid="tlqk35" creationdate="20220321T174900Z">
        <seg>그 경우 α가 어느 유형세계에 속하였든 상관없이 (x : α) → β도 Sort 0의 원소입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In that case, given
x : α, p x denotes the assertion that p holds of
x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172714Z" creationid="tlqk35" creationdate="20220321T172714Z">
        <seg>이 경우 x : α가 주어진다면, p x는  p가  x가 성립한다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In that case, the type (a : α) → β a denotes the type
of functions f with the property that, for each a : α, f a
is an element of β a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151821Z" creationid="tlqk35" creationdate="20220321T151821Z">
        <seg>이 경우 유형 (a : α) → β a는 모든  a : α에 대해,  f a가 β a의 원소라는 성질로 f 함수의 유형을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
Lean standard library, you often see Greek letters to denote types,
and the Unicode symbol → as a more compact version of -&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140139Z" creationid="tlqk35" creationdate="20220321T140139Z">
        <seg>린의 표준 라이브러리에서 여러분은 유형을 나타내는데 그리스 문자를 자주 보게 됩니다. 그리고 유니코드 기호 → 은 -&gt;보다 더 간결한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
next two examples, they are used to define functions which swap the
components of the product and sum types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072556Z" creationid="tlqk35" creationdate="20220522T072556Z">
        <seg>다음 두 예제에서, 이들은 곱과 합 유형의 요소를 바꾸는 함수를 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
previous example, the proper value of the metavariable is determined
by the tactic exact px, since px has type p x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072240Z" creationid="tlqk35" creationdate="20220522T072240Z">
        <seg>이전 예제에서 메타변수의 적절한 값은exact px 전략에 의해 결정됩니다. 
그 이유는 px가 p x형을 갖기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
second expression, a is a variable, and the expression
fun a =&gt; t2 has to make sense independently of the value of a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145013Z" creationid="tlqk35" creationdate="20220321T145013Z">
        <seg>두 번째 표현식에서 a는 변수이고 표현식 fun a =&gt; t2는  a의 값과 별개로 의미를 가져야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the case of the apply
tactic, the tags are inferred from the parameters names used in the
And.intro declaration.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061147Z" creationid="tlqk35" creationdate="20220522T061147Z">
        <seg>apply 전략의 경우 표식은 And.intro에서 사용된 매개변수의 이름으로부터 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the case where p x has type Prop, if we replace
(x : α) → β x with ∀ x : α, p x, we can read these as the correct rules
for building proofs involving the universal quantifier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173157Z" creationid="tlqk35" creationdate="20220321T173157Z">
        <seg>p x는 Prop형을 갖는 이 경우에 대해, 우리가  (x : α) → β x을 ∀ x : α, p x으로 대체한다면, 우리는 이것들을 전칭 한정기호를 포함한 증명을 만드는데 옳바른 규칙이라고 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the current setting, it shows
how to "introduce" or establish an implication.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162426Z" creationid="tlqk35" creationdate="20220321T162426Z">
        <seg>지금 상황에서 그것은 "도입"을 어떻게 하는지 또는 함의를 어떻게 세우는지 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the editors, you can type the backwards arrow as
\l.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172018Z" creationid="tlqk35" creationdate="20220524T155059Z">
        <seg>편집자에게 여러분은 뒷방향 화상표를 이와 같이 칠 수 있습니다.
\l</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, def m : Nat := 1
defines a new constant m of type Nat whose value is 1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135810Z" creationid="tlqk35" creationdate="20220321T135810Z">
        <seg>위 예제에서 def m : Nat := 1는 1을 값으로 갖는 새로운 상수 m을 Nat유형으로 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the command apply And.intro yields two
subgoals:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184640Z" creationid="tlqk35" creationdate="20220321T184640Z">
        <seg>위의 예에서 apply And.intro 명령은 두 하위 목표를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, the first use of rw replaces k with
0 in the goal f k = 0.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T154134Z" creationid="tlqk35" creationdate="20220524T154134Z">
        <seg>다음 예제에서 rw의 첫 번째 사용은 목표 f k = 0에서 
k를 0으로 대체합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the examples below, the minus sign and
only are used to block the application of reverse_mk_symm.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170337Z" creationid="tlqk35" creationdate="20220524T170337Z">
        <seg>아래 예제에서 음의 부호와 only는 reverse_mk_symm의 
활용을 막는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the exercises below, we encourage you to prove as many
as you can.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183126Z" creationid="tlqk35" creationdate="20220321T183126Z">
        <seg>아래 연습 문제에서 여러분이 할 수 있는 가능한 많이 증명해보길 권합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the exposition below, we will slip back and forth between these two
ways of talking, at times saying that an expression "constructs" or
"produces" or "returns" a proof of a proposition, and at other times
simply saying that it "is" such a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160439Z" creationid="tlqk35" creationdate="20220321T160439Z">
        <seg>아래의 설명에서 우리는 두 말하기 방식 사이를 앞뒤로 다닐 것인데, 어떤 표현은 명제의 증명을 "구성" 또는 "생성", "반환"을 말하고, 어떤 표현은 단순히 "그것"이라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the expression Or.elim hpq hpr hqr, Or.elim
takes three arguments, hpq : p ∨ q, hpr : p → r and
hqr : q → r, and produces a proof of r.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163854Z" creationid="tlqk35" creationdate="20220321T163854Z">
        <seg>표현식 Or.elim hpq hpr hqr과 Or.elim은 세 인수 hpq : p ∨ q, hpr : p → r 그리고 hqr : q → r를 받습니다. 그리고 r의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first example above, the first step rewrites a + b + c to
a + (b + c).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171958Z" creationid="tlqk35" creationdate="20220524T155458Z">
        <seg>첫 예제에서 처음 절차는 a + b + c을 a + (b + c)으로 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150808Z" creationid="tlqk35" creationdate="20220524T150808Z">
        <seg>첫 예제에서 왼쪽 분기는 성공했습니다. 반면 두번째에서 성공한 것은 오른쪽의 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first example, the left-hand side of the equality in the goal
is simplified using the usual identities involving 0 and 1, reducing
the goal to x * y = x * y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161445Z" creationid="tlqk35" creationdate="20220524T161117Z">
        <seg>첫 예제에서 목표 속 등식의 좌변은 0과 1을 포함한 평범한 항등식을 
사용해 단순화해 목표를  x * y = x * y으로 축소합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first expression, you should think of every instance
of a in t2 as a syntactic abbreviation for t1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144938Z" creationid="tlqk35" creationdate="20220321T144938Z">
        <seg>첫 번째 표현식에서, 여러분은 t2속 a의 모든 개체를 t1에 대한 문법적 약어로 생각해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, the tactic rename_i h1 _ h2 renames two of the last three hypotheses in
your context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063649Z" creationid="tlqk35" creationdate="20220522T063649Z">
        <seg>다음 예제에서는 rename_i h1 _ h2 전략이 여러분의 상황 속 세 가정 중 마지막 두 개의 이름을 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, we
use this basic form to rewrite the goal using a hypothesis.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T154032Z" creationid="tlqk35" creationdate="20220524T154032Z">
        <seg>다음 예제에서 우리는 이 기본 형태를 가정을 사용하여 목표를 다시 쓰는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, we define even a as ∃ b, a = 2*b,
and then we show that the sum of two even numbers is an even number.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182926Z" creationid="tlqk35" creationdate="20220321T182926Z">
        <seg>다음 예제에서 우리는 짝수 a를 ∃ b, a = 2*b와 같이 정의합니다. 그런 뒤 두 짝수의 합이 짝수임을 보일 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, we define the notation triv using the command syntax.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170454Z" creationid="tlqk35" creationdate="20220524T170454Z">
        <seg>다음 에제에서 우리는triv기호를 syntax 명령을 사용해 정의한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, we use
Or.elim to prove p ∨ q → q ∨ p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163917Z" creationid="tlqk35" creationdate="20220321T163917Z">
        <seg>다음 예제에서 우리는 Or.elim을 p ∨ q → q ∨ p을 증명하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the following example, we use rw [h] at t to rewrite the hypothesis t : Tuple α n to t : Tuple α 0.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171820Z" creationid="tlqk35" creationdate="20220524T160542Z">
        <seg>다음 예제에서 우리는 가정 t : Tuple α n을 t : Tuple α 0으로 다시쓰도록 rw [h] at t을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the last chapter we observed that lambda abstraction can be viewed
as an "introduction rule" for →.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162419Z" creationid="tlqk35" creationdate="20220321T162419Z">
        <seg>지난 장에서 우리는 람다 추상화가 →에 대한 "도입 규칙"으로 본 적이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the latter case, let us say that (the type associated
with) p is inhabited.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160016Z" creationid="tlqk35" creationdate="20220321T160016Z">
        <seg>후자의 경우에서 (연관된 유형)p은 머무른다고 말합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the meanwhile, here we explain how to use it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175424Z" creationid="tlqk35" creationdate="20220321T175424Z">
        <seg>한편, 여기서는 어떻게 그것을 사용할지 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the next example we
use And.intro to create a proof of p → q → p ∧ q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162642Z" creationid="tlqk35" creationdate="20220321T162642Z">
        <seg>다음 예제에서 우리는 And.intro를 p → q → p ∧ q의 증명을 만들기 위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the next example, the second
constructor succeeds on the right conjunct q ∧ r (remember that
disjunction and conjunction associate to the right) but fails on the
first.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151729Z" creationid="tlqk35" creationdate="20220524T151729Z">
        <seg>다음 예제에서 두 번째 constructor는 오른쪽 결합자 q ∧ r(분리자와 
결합자는 오른쪽 결합성을 가짐을 기억하세요.)에서 성공합니다. 그러나 첫 번째에서는 실패합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the next three examples, the same compound tactic succeeds in each case.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150833Z" creationid="tlqk35" creationdate="20220524T150833Z">
        <seg>다음 세 예제에서 동일한 복합 전략은 각 경우에서 성공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the propositions-as-types paradigm, theorems involving only →
can be proved using lambda abstraction and application.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160637Z" creationid="tlqk35" creationdate="20220321T160637Z">
        <seg>유형으로써 명제 패러다임에서 →만을 포함하는 정리는 람다 추상화와 적용을 사용해 증명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the second example, simp reduces
the goal to p (x * y), at which point the assumption h
finishes it off.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161458Z" creationid="tlqk35" creationdate="20220524T161353Z">
        <seg>두 번째 예제에서 simp는 목표를 p (x * y)으로 축약합니다.
이점에서 가정 h가 이를 끝냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the second pair of examples below, this mechanism is
used to specify the desired types of the expressions id and
List.nil:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153603Z" creationid="tlqk35" creationdate="20220321T153603Z">
        <seg>아래 예제의 쌍의 두 번째에서, 이 메커니즘은 식 id와 List.nil의 바람직한 유형을 명시하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this
section and the next, we discuss them in greater detail.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T153301Z" creationid="tlqk35" creationdate="20220524T153301Z">
        <seg>이 섹션과 다음에서 우리는 이들에 대해 더 자세히 논의할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case you can think of def as a kind of named lambda.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144029Z" creationid="tlqk35" creationdate="20220321T144029Z">
        <seg>이 경우 여러분은 def를 lambda와 같은 종류로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case, the any_goals tactic provides a more robust solution.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172331Z" creationid="tlqk35" creationdate="20220524T152345Z">
        <seg>여기서 any_goals 전략은 더 강건한 답을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this chapter,
we extend the repertoire of logical constructions to include the
universal and existential quantifiers, and the equality relation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172553Z" creationid="tlqk35" creationdate="20220321T172553Z">
        <seg>이번 장에서는 우리는 전칭과 존재 한정기호와 동등 관계를 포함한 논리 구축 레퍼토리를 확장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this chapter, we describe an alternative approach to constructing
proofs, using tactics.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184252Z" creationid="tlqk35" creationdate="20220321T184252Z">
        <seg>이 장에서는 전략을 사용하여 증명을 생성하는 대체 접근 방식을 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this chapter, we will begin to explain how to write
mathematical assertions and proofs in the language of dependent type
theory as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154806Z" creationid="tlqk35" creationdate="20220321T154806Z">
        <seg>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the admit tactic is the analogue of the sorry
proof term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065339Z" creationid="tlqk35" creationdate="20220522T065339Z">
        <seg>이 예제에서 admit 전략은 증명항 sorry와 유사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, the term ←h₁ instructs the rewriter to replace
b with a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172022Z" creationid="tlqk35" creationdate="20220524T155024Z">
        <seg>이 예제에서 항 ←h₁은 b를 a로 대체하도록 다시쓰기에게 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this example, there is only one goal after the cases tactic is
applied, with h : p ∧ q replaced by a pair of assumptions,
hp : p and hq : q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071237Z" creationid="tlqk35" creationdate="20220522T071237Z">
        <seg>이 예제에서,cases 전략이 h : p ∧ q에서 가정 
hp : p과 hq : q을 적용한  이후에는 한 목표만 남습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this section, we describe some means that help provide
structure to a tactic-style proof, making such proofs more readable
and robust.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142740Z" creationid="tlqk35" creationdate="20220524T142740Z">
        <seg>이 섹션에서 우리는 더욱 가독성있고 강건한 전략 스타일의 증명을 만들 구조를 
제공하도록 돕는 몇몇 수단을 설명할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this section, we discuss some
additional features of the proof language that are often convenient.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183301Z" creationid="tlqk35" creationdate="20220321T183301Z">
        <seg>이 섹션에서는 종종 편리한 증명 언어의 몇 가지 추가적인 기능에 대해 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In type theory, this is generally more convenient than
writing Nat.add as a function that takes a pair of natural numbers as
input and returns a natural number as output.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140842Z" creationid="tlqk35" creationdate="20220321T140842Z">
        <seg>유형론에서 보통 Nat.add과 같이 쓰는 것이 자연수 쌍을 입력으로 받고 자연수를 출력으로 하는 함수로 쓰는 것보다 더 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Incidentally, just as False has only an elimination rule, True
has only an introduction rule, True.intro : true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164549Z" creationid="tlqk35" creationdate="20220321T164549Z">
        <seg>참고로 False은 제거 규칙만 있듯이 True는 도입 규칙 True.intro : true만 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed,
it is the "failure" state that causes the first combinator to
backtrack and try the next tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151249Z" creationid="tlqk35" creationdate="20220524T151249Z">
        <seg>당연히 first 조합자가 원래대로 돌아와 다음 전략을 시도하도록 하는 "실패" 상태입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, if p : Prop is any proposition, Lean's kernel treats any
two elements t1 t2 : p as being definitionally equal, much the
same way as it treats (fun x =&gt; t) s and t[s/x] as
definitionally equal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160239Z" creationid="tlqk35" creationdate="20220321T160239Z">
        <seg>물론 p : Prop이 어떤 명제라면, 린의 커널은 임의의 두 원소 t2 : p 을 (fun x = t) s와 t[/x]를 정의상으로 동등하다고 같다는 것과 거의 같은 방식으로 정의상 동등하게 취급합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184450Z" creationid="tlqk35" creationdate="20220321T184450Z">
        <seg>실제로 위의 예에서 "sorry"를 밑줄로 바꾸면 린은 바로 이 목표가 해결되지 않은 상태로 남아 있다고 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, in dependent type theory (and in Lean), α → β
is just notation for (a : α) → β when β does not depend on a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152055Z" creationid="tlqk35" creationdate="20220321T152055Z">
        <seg>물론, 종속 유형론에서(그리고 Lean에서) α → β는 β가 a에 의존하지 않을 때 (a : α) → β에 대한 표기일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Inferring this predicate therefore requires an instance
of higher-order unification.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180055Z" creationid="tlqk35" creationdate="20220321T180055Z">
        <seg>이 술어를 추론하는 것은 그러므로 고차 통합의 개체를 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Informally, the
introduction rule states:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172855Z" creationid="tlqk35" creationdate="20220321T172855Z">
        <seg>비공식적으로 도입 규칙은 다음과 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Informally, you might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof
term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184307Z" creationid="tlqk35" creationdate="20220321T184307Z">
        <seg>비공식적으로 "앞방향으로 증명하고, 정의를 펼치고, 이전 보조 정리를 적용하고, 단순화하십시오."라고 말함으로써 수학적 증명을 시작할 수 있습니다. 이것이 독자에게 관련 증명을 찾는 방법을 알려주는 지침인 것처럼 전략은 Lean에게 증명 항를 생성하는 방법을 알려주는 지침입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Information as to how
the search path is determined can be found on the
documentation pages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174257Z" creationid="tlqk35" creationdate="20220524T174257Z">
        <seg>어떻게 탐색경로가 결정되는지에 대한 정보는 documentation pages에서 찾아볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of using sorry, you can use
an underscore _ as a placeholder.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170429Z" creationid="tlqk35" creationdate="20220321T170429Z">
        <seg>sorry를 사용하는 것 대신 밑줄 문자  _를 자리 차지자로 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interacting with Lean</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172630Z" creationid="tlqk35" creationdate="20220524T172630Z">
        <seg>린과 상호작용하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Internally, the expression have h : p := s; t produces the term
(fun (h : p) =&gt; t) s.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165138Z" creationid="tlqk35" creationdate="20220321T165138Z">
        <seg>내부적으로 표현식 have h : p := s; t은 항 (fun (h : p) =&gt; t) s을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Introducing Auxiliary Subgoals</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165041Z" creationid="tlqk35" creationdate="20220321T165041Z">
        <seg>부가적인 하위 목표를 도입하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131051Z" creationid="tlqk35" creationdate="20220321T131051Z">
        <seg>소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Intuitively, our proof of
p → q → p assumes p and q are true, and uses the first
hypothesis (trivially) to establish that the conclusion, p, is
true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160813Z" creationid="tlqk35" creationdate="20220321T160813Z">
        <seg>직관적으로  p → q → p에 대한 우리의 증명은 p와 q가 참이라고 가정한다. 그리고 (명백히) 첫 번 째 가정을 p가 참이라는 결론을 세우기 위해 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Intuitively, the constructive "Or" is very strong: asserting p ∨ q
amounts to knowing which is the case.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165726Z" creationid="tlqk35" creationdate="20220321T165726Z">
        <seg>직관적으로 구성자 "논리합"은 아주 강력합니다.  p ∨ q라 주장하는 것은 각 경우를 아는 것과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It
allows us to prove a proposition q from ∃ x : α, p x, by
showing that q follows from p w for an arbitrary value
w.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181249Z" creationid="tlqk35" creationdate="20220321T181249Z">
        <seg>임의의 값 w에 대해 p w로부터 q임을 보임으로써 ∃ x : α, p x으로부터 명제 q를 증명하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also makes proofs more readable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183644Z" creationid="tlqk35" creationdate="20220321T183644Z">
        <seg>또 이것은 증명을 더 가독성있게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also uses other rules that have been previously declared to
the system, and applies commutativity wisely to avoid looping.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180518Z" creationid="tlqk35" creationdate="20220321T180518Z">
        <seg>또 이것은 시스템에서 전에 선언된 적 있는 다른 규칙을 사용합니다.그리고 무한 루프를 현명하게 피하면서 교환성을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can even combine different relations.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180647Z" creationid="tlqk35" creationdate="20220321T180647Z">
        <seg>심지어 이것은 다른 관계와 혼합될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It closes the current goal, producing the usual warning
that sorry has been used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065446Z" creationid="tlqk35" creationdate="20220522T065446Z">
        <seg>이것은 현재 목표를 마무리 짓고, sorry를 사용했을 때처럼 경고를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has
the important property that every assertion respects the equivalence,
in the sense that we can substitute equal expressions without changing
the truth value.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175710Z" creationid="tlqk35" creationdate="20220321T175710Z">
        <seg>우리가  같은 표현식들을 진리값을 바꾸지 않고 대체할 수 있다는 점에서 등가에 대한 모든 주장은 중요한 성질이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has a compiler that
generates a binary executable and an interactive interpreter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143751Z" creationid="tlqk35" creationdate="20220321T143751Z">
        <seg>이것은 이진 실행 프로그램을 만드는 컴파일러와 상호작용적인 인터프리터를 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is
equivalent to first | t | skip, where skip is a tactic that does
nothing (and succeeds in doing so).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151558Z" creationid="tlqk35" creationdate="20220524T151558Z">
        <seg>이는 first | t | skip과 동일합니다. 여기서 skip은 
아무것도 하지 않는(그리고 그것의 실행에서 성공하는) 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is
needed in the following example because, from a constructive
standpoint, knowing that p and q are not both true does not
necessarily tell you which one is false:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170025Z" creationid="tlqk35" creationdate="20220321T170025Z">
        <seg>다음 예제에서 이게 필요한데 왜냐하면 직관주의적 관점에서 p와 q 둘 다 참이 아니라는 것을 아는 것은 여러분에게 반드시 어떤 것이 거짓이라는 것을 말해줄 필요는 없기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is also more robust than apply, since the
elaborator takes the expected type, given by the target of the goal,
into account when processing the expression that is being applied.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055322Z" creationid="tlqk35" creationdate="20220522T055322Z">
        <seg>이것은 apply보다 더 강건합니다. 왜냐하면 
협력기는 적용될 표현식을 처리할 때 목표의 대상에 의해 
제시된 예상 유형을 받기를 기대하기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is an ongoing, long-term
effort, and much of the potential for automation will be realized only gradually over time.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131736Z" creationid="tlqk35" creationdate="20220321T131736Z">
        <seg>이것은 장기적으로 현재진행 중이고 자동화에 대한 대부분의 잠재성은 시간이 지나면서 점차 실현될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is clear that cons α should have type α → List α → List α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151301Z" creationid="tlqk35" creationdate="20220321T151301Z">
        <seg>cons α가  α → List α → List α 유형을 가져야 함은 분명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is common to describe
And.intro as the and-introduction rule.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162615Z" creationid="tlqk35" creationdate="20220321T162615Z">
        <seg>And.intro를 and-도입 규칙이라고 설명하는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is common to iterate constructions like "And." Lean also allows you
to flatten nested constructors that associate to the right, so that
these two proofs are equivalent:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163527Z" creationid="tlqk35" creationdate="20220321T163527Z">
        <seg>"And"같은 반복적 생성은 흔합니다. 두 증명이 동등함을 보이기 위해 린은 여러분에게 오른쪽에 연관된 중첩된 생성자를 평평하게 만들도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is convenient for illustration,
and we will use it often.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162714Z" creationid="tlqk35" creationdate="20220321T162714Z">
        <seg>이는 설명에 유용하고 예제 명령을 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is good form to use
it in a tactic proof, since its failure signals that something has
gone wrong.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055131Z" creationid="tlqk35" creationdate="20220522T055131Z">
        <seg>전략 증명모드에서 이것은 사용하기에 좋은 형태입니다. 
왜냐하면 그것의 실패는 무언가 잘못되었음을 알려주기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is often possible to bring a component of a formula outside a
universal quantifier, when it does not depend on the quantified
variable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183811Z" creationid="tlqk35" creationdate="20220321T183811Z">
        <seg>식이 정량화된 변수에 의존하지 않을 때 종종 전칭 한정기호를 식의 바깥 쪽으로 가져올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is represented
by a metavariable, which should be instantiated later on.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072123Z" creationid="tlqk35" creationdate="20220522T072123Z">
        <seg>이는 메타변수로 표현되며 나중에 반드시 개체화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is similar to all_goals, except it fails unless its argument
succeeds on at least one goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172129Z" creationid="tlqk35" creationdate="20220524T152643Z">
        <seg>any_goals은 그것의 인자가 적어도 한 목표에 대해서도 성공하지 않는 
한 실패하는 경우를 제외하고 all_goals과 유사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is sometimes useful to export aliases from one namespace to another, or to the top level.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181416Z" creationid="tlqk3" creationdate="20220525T181416Z">
        <seg>별명을 한 이름 공간에서 다른 곳 혹은 최상위 단계로 내보내기하는 것은 때때로 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is still tedious, however, to type all these underscores.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153139Z" creationid="tlqk35" creationdate="20220321T153139Z">
        <seg>그래도 여전히 이 밑줄문자를 치는 것은 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is the tactic analogue of a let in a proof
term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144352Z" creationid="tlqk35" creationdate="20220524T144352Z">
        <seg>이것은 증명항에서 let과 유사한 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is the typing rule for dependent arrow types, and the universal
quantifier in particular, that distinguishes Prop from other
types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174429Z" creationid="tlqk35" creationdate="20220321T174429Z">
        <seg>이것은 의존 화살표 유형에 대한 타자 규칙입니다. 특히 그리고 전칭 한정기호는 Prop 과 다른 유형들을 구분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It just so happens that the rules for
function application and abstraction can conveniently help us keep
track of which elements of Prop are inhabited.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160048Z" creationid="tlqk35" creationdate="20220321T160048Z">
        <seg>함수 적용 및 추상화 규칙이 Prop의 원소가 머무르는 것을 우리가 추적하는 것을 편리하게 도울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It may be helpful to compare the exists-elimination rule to the
or-elimination rule: the assertion ∃ x : α, p x can be thought of
as a big disjunction of the propositions p a, as a ranges over
all the elements of α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181604Z" creationid="tlqk35" creationdate="20220321T181604Z">
        <seg>존재-제거 규칙과 논리합-제거 규칙을 비교하는것은 도움이 아마 도움이 될 것입니다. 왜냐하면 a가 모든 α의 요소 범위를 갖기 때문에 명제 ∃ x : α, p x은 커다란 명제의 분리자  p a로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It may seem that commutativity and
left-commutativity are problematic, in that repeated application of
either causes looping.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171738Z" creationid="tlqk35" creationdate="20220524T162327Z">
        <seg>둘 중 어떤 것의 반복적인 활용이 무한루프를 유발한다는 점에서 
교환성과 좌교환성은 문제가 있어 보입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It means
that even though we can treat proofs t : p as ordinary objects in
the language of dependent type theory, they carry no information
beyond the fact that p is true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160316Z" creationid="tlqk35" creationdate="20220321T160316Z">
        <seg>우리가 증명t : p을 의존 유형론 언어의 평범한 대상으로 다룰 수 있음에도 p가 참이라는 사실 이상의 정보를 전달하지 않는다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It simply declares the type of the
goal that is about to be solved, while remaining in tactic
mode.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143405Z" creationid="tlqk35" creationdate="20220524T143405Z">
        <seg>전략모드에 남아있는 동안 이것는 단순히 막 풀리려고 하는 목표의 유형을 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184630Z" creationid="tlqk35" creationdate="20220321T184630Z">
        <seg>결론을 현재 목표의 표현식과 통합하고 이후 인수가 종속되지 않는 한 나머지 인수에 대한 새 목표를 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It useful to use indendation to structure proof: every time a tactic
leaves more than one subgoal, we separate the remaining subgoals by
enclosing them in blocks and indenting.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145433Z" creationid="tlqk35" creationdate="20220524T145421Z">
        <seg>구조화된 증명에 인덴트를 사용하는 것은 유용합니다. 매번 전략은 한 개 이상의 하위 목표를 남겨두므로 
우리는 블럭과 인덴트로 그들을 담아  남은 하위목표와 분리할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It will unify metavariables in the conclusion if necessary:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063004Z" creationid="tlqk35" creationdate="20220522T063004Z">
        <seg>이것은 필요하다면 결론의 메타변수들을 통합할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Iterating such
rewrites produces nontrivial propositional reasoning.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171647Z" creationid="tlqk35" creationdate="20220524T164027Z">
        <seg>이 다시쓰기를 반복하는 것은 명백하지 않은 명제논리적 추론을 만들어 냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its use is also not limited to propositions,
though using it for data is somewhat odd:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183723Z" creationid="tlqk35" creationdate="20220321T183723Z">
        <seg>그것의 용도는 명제에마 국한되지 않고 약간 이상하지만 데이터에 대해서도 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just as dependent function types (a : α) → β a generalize the
notion of a function type α → β by allowing β to depend on
α, dependent Cartesian product types (a : α) × β a generalize
the Cartesian product α × β in the same way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152228Z" creationid="tlqk35" creationdate="20220321T152228Z">
        <seg>의존적 함수 유형 (a : α) → β a는 함수의 유형 α → β의 개념을 β가 α에 종속적이라고 함으로써 일반화한 것처럼 의존적 카테시안 곱 유형은 (a : α) × β a는 카테시안 곱 α × β를 같은 방식으로 일반화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just as the constructive "or" is stronger than the classical "or," so,
too, is the constructive "exists" stronger than the classical
"exists".</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183014Z" creationid="tlqk35" creationdate="20220321T183014Z">
        <seg>직관주의적 "or"은 고전주의의 "or"보다 강한 것처럼 직관주의적 "존재한다"도 고전주의적 "존재한다"보다 강한 의미를 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Keep in mind that you can use the French quotation marks in this way
to refer to anything in the context, not just things that were
introduced anonymously.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183716Z" creationid="tlqk35" creationdate="20220321T183716Z">
        <seg>여러분은 프랑스 인용부호를 맥락 속에서 익명으로 도입된 것들 뿐만 아니라 어떤 것이든 참조하기 위해 사용될 수 있다는 점을 명심하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Later, we show how you can extend the proof language using the Lean macro system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183733Z" creationid="tlqk35" creationdate="20220321T183733Z">
        <seg>나중에 우리는 린의 매크로 시스템을 사용해서 증명 언어를 확장하는 방법을 소개합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean
therefore provides Or.inr and Or.inl which can be viewed as
shorthand for Or.intro_right _ and Or.intro_left _.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164016Z" creationid="tlqk35" creationdate="20220321T164016Z">
        <seg>린은 그러므로  Or.intro_right _과 Or.intro_left _의 약식 표현으로 볼 수 있는 Or.inr 과 Or.inl을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean allows us to use anonymous constructor notation
⟨arg1, arg2, ...⟩ in situations like these, when the relevant type is an
inductive type and can be inferred from the context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163229Z" creationid="tlqk35" creationdate="20220321T163229Z">
        <seg>연관된 유형이 유도형이고 맥락으로부터 추리할 수 있는 상황에서 린은 익명 생성자 표기 ⟨arg1, arg2, ...⟩를 쓸 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also
allows us to specify the type of the final term hp, explicitly,
with a show statement.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161051Z" creationid="tlqk35" creationdate="20220321T161051Z">
        <seg>린은 여러분에게 마지막 항 hp을 명시적으로 show 문장으로 유형을 명시하는 것을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also allows you to introduce "local" definitions using the
let keyword.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144719Z" creationid="tlqk35" creationdate="20220321T144719Z">
        <seg>Lean은 여러분이 let 키워드를 사용해 "지역" 정의를 가져올 수 있게 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also has a let tactic, which is similar to the have
tactic, but is used to introduce local definitions instead of
auxiliary facts.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144248Z" creationid="tlqk35" creationdate="20220524T144248Z">
        <seg>Lean은 또 have전략과 유사한 let 전략을 갖고 있습니다. 
그러나 이것은 부가적인 사실 대신 지역 정의를 도입하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also has mechanisms to serve as its own metaprogramming
language, which means that you can implement automation and extend the functionality of Lean using Lean itself.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131622Z" creationid="tlqk35" creationdate="20220321T131622Z">
        <seg>또한 Lean은 그 자체로 메타프로그래밍 언어로 기능하는 작동 원리가 있어 자동화의 수행 및 Lean 자체로 그 기능을 확장할 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also provides
the "bullet" notation .</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061823Z" creationid="tlqk35" creationdate="20220522T061751Z">
        <seg>린은 또 구조화한 증명에 대해 "bullet" 기호를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also provides a pattern-matching let expression:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182802Z" creationid="tlqk35" creationdate="20220321T182802Z">
        <seg>또 린은 패턴-매칭 let 표현식을 제공합니다.&lt;부분 1562 ¶&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also supports a structured way of reasoning backwards from a
goal, which models the "suffices to show" construction in ordinary
mathematics.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165224Z" creationid="tlqk35" creationdate="20220321T165224Z">
        <seg>린은 또 구조화된 목표로부터 후방향 추론 방식을 지원합니다. 이것은 일상 수학에서 "보여주기에 충분하다" 구성을 모델링 한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also supports the use of various editors, which provide
continuous checking and feedback.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173524Z" creationid="tlqk35" creationdate="20220524T173524Z">
        <seg>또한 린은 다양한 끊임없는 확인과 피드백을 제공하는 편집기의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean can
usually infer the type α, but it is often a good idea to write it
explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144144Z" creationid="tlqk35" creationdate="20220321T144144Z">
        <seg>Lean은 α의 유형을 추론할 수 있습니다. 그러나 이를 명백히 적는 것이 좋습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean can not only define mathematical objects and express
mathematical assertions in dependent type theory, but it also can be used as a language for writing proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132153Z" creationid="tlqk35" creationdate="20220321T132120Z">
        <seg>린은 수학적 대상들을 정의하고 수학적 주장을 의존 유형론으로 진술할 수 있고 증명을 작성하는 언어로써 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean defines all the standard logical connectives and notation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161834Z" creationid="tlqk35" creationdate="20220321T161834Z">
        <seg>린은 모든 표준 논리 연결사와 표기를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean detects that the proof uses hp and automatically adds
hp : p as a premise.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161613Z" creationid="tlqk35" creationdate="20220321T161613Z">
        <seg>린은 hp를 사용하는 증명을 감지하고 자동적으로 hp : p를 전제로 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153412Z" creationid="tlqk35" creationdate="20220321T153412Z">
        <seg>Lean은 암시적인 인수를 인스턴스화(instantiating)하는데 아주 복잡한 매커니즘을 가지고 있습니다. 그리고 우리는 함수의 유형과 술어 그리고 심지어 증명을 추론하는데 사용될 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of x and y from the
expression if not y then x + 1 else x + 2.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142601Z" creationid="tlqk35" creationdate="20220321T142601Z">
        <seg>린은 마지막 세 예제를 같은 표현식으로 해석합니다. 마지막 표현식에서 린은 x와 y의 유형을 표현식 if not y then x + 1 else x + 2으로부터 추론합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is a complete programming language.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143745Z" creationid="tlqk35" creationdate="20220321T143745Z">
        <seg>린은 완전한 프로그래밍 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is based on a version of dependent type
theory known as the Calculus of Constructions, with a countable
hierarchy of non-cumulative universes and inductive types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135135Z" creationid="tlqk35" creationdate="20220321T135135Z">
        <seg>린은  직관주의 계산법이라고 하는 가산적인 비축적적 세계(Universe)와 유도형이 있는 의존 유형론 버전을 기반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is released under the
Apache 2.0 license, a permissive open source license that permits others to use and extend the code and
mathematical libraries freely.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131805Z" creationid="tlqk35" creationdate="20220321T131805Z">
        <seg>Lean은  Apache 2.0 라이센스하에서 배포되었습니다. 이는 타인에게 자유롭게 사용하는 것과 수학 라이브러리 및 코드의 확장을 허락합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is smart enough to figure out which variables are used
explicitly or implicitly in a definition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145931Z" creationid="tlqk35" creationdate="20220321T145931Z">
        <seg>Lean은 정의에서 명시적으로나 암시적으로 사용된 변수를 구분하기에 충분히 똑똑합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean offers a weaker annotation,
{{y : ℕ}}, which specifies that a placeholder should only be added
before a subsequent explicit argument.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185509Z" creationid="tlqk3" creationdate="20220525T185229Z">
        <seg>린은 종종 자리차지자가 이후의 명시적인 인수 앞에 추가되어야 함을 나타내는 약한 주석 {{y : ℕ}}을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides a fun (or λ) keyword to create a function
from an expression as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142148Z" creationid="tlqk35" creationdate="20220321T142148Z">
        <seg>린은 fun (또는 λ) 키워드를 제공하여 다음과 같은 표현식으로부터 함수를 만들 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides a more convenient way to eliminate from an existential
quantifier with the match expression:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181807Z" creationid="tlqk35" creationdate="20220321T181807Z">
        <seg>린은 match 표현식이 있는 존재 한정기호를 더 편리하게 제거하는 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides another useful syntactic gadget.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163333Z" creationid="tlqk35" creationdate="20220321T163333Z">
        <seg>린은 또 다른 유용한 문법적 도구를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides various sectioning mechanisms to help structure a
theory.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174732Z" creationid="tlqk35" creationdate="20220524T174732Z">
        <seg>린은 이론을 구조화하는 것을 돕기 위해 구획을 나누는 다양한 메커니즘을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides you with the variable command to make such
declarations look more compact:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145147Z" creationid="tlqk35" creationdate="20220321T145143Z">
        <seg>린은 여러분에게 이런 선언을 더 간결하게 보이게 만들도록 variable 명령을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides you with the ability to group definitions into nested,
hierarchical namespaces:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150219Z" creationid="tlqk35" creationdate="20220321T150219Z">
        <seg>Lean은 여러분에게 정의를 중첩되고 계층적인 namespaces에 묶을 수 있는 능력을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean tries to use type information to
disambiguate the meaning in context, but you can always disambiguate
by giving the full name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180522Z" creationid="tlqk35" creationdate="20220524T180522Z">
        <seg>린은 맥락에서 의미의 모호함을 해소하려고 유형 정보를 사용하려고 합니다. 
그러나 여러분은 이들의 완전한 이름을 주는 것으로 모호성을 항상 풀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean uses the
context to infer which one is appropriate.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181106Z" creationid="tlqk35" creationdate="20220321T181106Z">
        <seg>린은 어떤 것이 적절한 지 추론하는데 맥락을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean will even allow us to use an implicit match
in the fun expression:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182848Z" creationid="tlqk35" creationdate="20220321T182848Z">
        <seg>더욱이 린은 우리에게 fun 표현식에서 암시적인 match를 사용할 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's library contains a large number of common identities, such as these:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175923Z" creationid="tlqk35" creationdate="20220321T175923Z">
        <seg>린의 라이브러리는 이와 같은 흔한 항등식들을 많이 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's parser is extensible, which is to say, we can define new notation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T191247Z" creationid="tlqk3" creationdate="20220525T191247Z">
        <seg>린의 구문분석기는 확장가능성이 있습니다. 그 말은 우리가 새로운 기호를 정의할 수 있다는 뜻입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's standard library contains proofs of many valid statements of
propositional logic, all of which you are free to use in proofs of
your own.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170114Z" creationid="tlqk35" creationdate="20220321T170114Z">
        <seg>린의 표준 라이브러리는 명제 논리의 유효한 많은 진술들이 담겨있고 그 모든 것들은 여러분들의 주장을 증명하는데 자유롭게 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's task, as a
proof assistant, is to help us to construct such a term, t, and to
verify that it is well-formed and has the correct type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160545Z" creationid="tlqk35" creationdate="20220321T160545Z">
        <seg>증명 보조기로써 린의 일은 그러한 항 t를 생성하고 그것이 올바른 유형이고 잘 형성된 것을 검증하도록 돕는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's underlying foundation has an infinite
hierarchy of types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141603Z" creationid="tlqk35" creationdate="20220321T141603Z">
        <seg>린의 기저에는 무한한 유형의 계층이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming
language.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131550Z" creationid="tlqk35" creationdate="20220321T131550Z">
        <seg>Lean의 기본 논리는 컴퓨팅 해석기(interpretor)을 가지는데 있다. 그래서 Lean은 프로그래밍 언어와 마찬가지로 동등하게 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let us now turn to one of the most fundamental relations defined in
Lean's library, namely, the equality relation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175313Z" creationid="tlqk35" creationdate="20220321T175313Z">
        <seg>이제 주로 동등 관계라고 하는 린의 라이브러리에 정의된 가장 기초적인 관계 중 하나로 가봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's create one
that adds two natural numbers:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144254Z" creationid="tlqk35" creationdate="20220321T144254Z">
        <seg>두 자연수를 더하는 함수를 만들어 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's take a look at some basic syntax.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140329Z" creationid="tlqk35" creationdate="20220321T140329Z">
        <seg>몇 가지 기본 문법에 대해 살펴봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like sections, namespaces can be nested:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150535Z" creationid="tlqk35" creationdate="20220321T150535Z">
        <seg>section처럼 이름공간도 중첩될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like sections, nested namespaces have to be closed in the order they
are opened.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150603Z" creationid="tlqk35" creationdate="20220321T150603Z">
        <seg>섹션과 마찬가지로 중첩된 이름공간은 그들이 열린 순서대로 닫혀야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Local Definitions</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144706Z" creationid="tlqk35" creationdate="20220321T144706Z">
        <seg>지역 정의(Local Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Logical Equivalence</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164609Z" creationid="tlqk35" creationdate="20220321T164609Z">
        <seg>논리적 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Look up the definition of a Fermat prime or any of the
other statements, if necessary.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183958Z" creationid="tlqk35" creationdate="20220321T183958Z">
        <seg>페르마 소수의 정의나 필요하다면 다른 문장들을 찾아보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Make sure Lean accepts the term with
all the sorry's; if not, there are errors that you need to
correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170349Z" creationid="tlqk35" creationdate="20220321T170349Z">
        <seg>린이 모든 sorry에 대한 말을 받아들이게 만드세요. 그렇지 않으면 여러분이 고쳐야 하는 에러가 생깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Many people have contributed to the effort, providing
corrections, suggestions, examples, and text.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134821Z" creationid="tlqk35" creationdate="20220321T134821Z">
        <seg>많은 사람들이 오타 정정, 제안, 예제, 본분을 제공하는 등의 노력으로 기여했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More Tactics</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070126Z" creationid="tlqk35" creationdate="20220522T070126Z">
        <seg>이 외의 전략들</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More information can be found on the
Lean documentation pages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173553Z" creationid="tlqk35" creationdate="20220524T173553Z">
        <seg>린에 대한 더 많은 정보는 documentation pages에서 찾을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More on Implicit Arguments</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184142Z" creationid="tlqk3" creationdate="20220525T184142Z">
        <seg>암시적인 인수에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More on Namespaces</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175445Z" creationid="tlqk35" creationdate="20220524T175445Z">
        <seg>이름공간에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More on Sections</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175439Z" creationid="tlqk35" creationdate="20220524T175439Z">
        <seg>섹션에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More on the Proof Language</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183223Z" creationid="tlqk35" creationdate="20220321T183223Z">
        <seg>증명 언어에 대한 자세한 내용</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More specifically, Lean is based on a version of a system
known as the Calculus of Constructions with inductive types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132056Z" creationid="tlqk35" creationdate="20220321T132056Z">
        <seg>더 구체적으로 Lean은 유도형(inductive types)의 직관주의적 계산법(calculus of Construction)으로 알려진 시스템에 기반한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as
reasoning about the functions that the programs compute.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131607Z" creationid="tlqk35" creationdate="20220321T131607Z">
        <seg>더욱이 이것은 정밀한 의미를 갖는 편집프로그램이나 프로그램이 계산하는 함수에 대한 추론 프로그램으로도 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, Type u is also just
syntactic sugar for Sort (u+1).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155755Z" creationid="tlqk35" creationdate="20220321T155755Z">
        <seg>게다가 Type u도 Sort (u+1)에 대한 문법적 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, Lean flags an error
if the selected goal is not fully solved at the end of the case
block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061544Z" creationid="tlqk35" creationdate="20220522T061544Z">
        <seg>게다가 린은 선택된 목표가 case 블록의 끝에서 완전히 풀리지 않았다면 오류를 표시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, once we make this identification, the rules for implication
show that we can pass back and forth between Implies p q and
p → q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155550Z" creationid="tlqk35" creationdate="20220321T155550Z">
        <seg>게다가 한번 우리가 이런 식별을 하면 함의 규칙은 Implies p q과 p → q의 앞뒤를 오갈 수 있다는 것을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184343Z" creationid="tlqk35" creationdate="20220321T184343Z">
        <seg>게다가 자동화된 절차 자체가 전략이기 때문에 전략은 Lean의 자동화를 사용하기 위한 관문을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, the
output indicates that the first argument is implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153759Z" creationid="tlqk35" creationdate="20220321T153759Z">
        <seg>게다가 출력은 첫 번째 인수가 암시적임을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161754Z" creationid="tlqk35" creationdate="20220524T161754Z">
        <seg>게다가 여러분은 "와일드카드" *로 모든 가정과 목표를 간단히 하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most of
these commands have global effects, which is to say, that they remain
in effect not only in the current file, but also in any file that
imports it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T182353Z" creationid="tlqk3" creationdate="20220525T182353Z">
        <seg>대개 이런 명령들은 전역 효과를 갖습니다. 그 말은 즉, 그들이 현재 파일 뿐 아니라 그것을 불러오는 모든 파일에 대해 영향이 남는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moving a hypothesis into the goal yields an implication:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064037Z" creationid="tlqk35" creationdate="20220522T064037Z">
        <seg>가정을 목표 속으로 옮김으로써 함의를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Much of the background information you will
need in order to do this is not specific to Lean at all.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132021Z" creationid="tlqk35" creationdate="20220321T132021Z">
        <seg>이를 배우기 위해 필요한 대부분의 배경지식은 Lean으로만 국한되어 있지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple rewrites can be combined using the notation rw [t_1, ..., t_n],
which is just shorthand for rw t_1; ...; rw t_n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172045Z" creationid="tlqk35" creationdate="20220524T154555Z">
        <seg>다수의 다시쓰기는 rw [t_1, ..., t_n] 표기을 사용해 결합될 수 있습니다. 
이것은 rw t_1; ...; rw t_n의 축약된 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Multiple tactic applications can be written in a single line by concatenating with a semicolon.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060802Z" creationid="tlqk35" creationdate="20220522T060802Z">
        <seg>복수의 전략들은 세미콜론으로 연결한 한 줄에 작성될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150201Z" creationid="tlqk35" creationdate="20220321T150201Z">
        <seg>이름공간(Namespaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces and sections serve different purposes:
namespaces organize data and sections declare variables for insertion
in definitions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150609Z" creationid="tlqk35" creationdate="20220321T150609Z">
        <seg>이름공간과 섹션은 다른 목적을 갖고 일합니다. 이름공간은 데이터를 정리하고 섹션은 정의의 삽입에 대해 변수를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces that have been closed can later be reopened, even in another file:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150550Z" creationid="tlqk35" creationdate="20220321T150550Z">
        <seg>닫힌 이름공간은 심지어 다른 파일일지라도 나중에 다시 열릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Negation and Falsity</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164157Z" creationid="tlqk35" creationdate="20220321T164157Z">
        <seg>부정과 거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Negation, ¬p, is actually defined to be p → False, so we
obtain ¬p by deriving a contradiction from p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164220Z" creationid="tlqk35" creationdate="20220321T164220Z">
        <seg>부정 ¬p은 실제로 p → False로 정의되어 있습니다. 그래서 우리는 p로부터 모순을 유도함으로써 ¬p를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nor do you have
to name a section, which is to say, you can use an anonymous
section / end pair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150138Z" creationid="tlqk35" creationdate="20220321T150138Z">
        <seg>섹션에 이름을 줄 필요도 없습니다. 그말은 즉슨, 여러분은 익명의 section / end 쌍을 사용할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161954Z" creationid="tlqk35" creationdate="20220321T161954Z">
        <seg>부정</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not all of the information found here will be useful to you right
away.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173159Z" creationid="tlqk35" creationdate="20220524T173146Z">
        <seg>여기서 찾은 모든 정보가 여러분에게 바로 유용하지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notation</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T190612Z" creationid="tlqk3" creationdate="20220525T190612Z">
        <seg>기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notationally,
this hides the specification of the type, making it look as though
ident simply takes an argument of any type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153317Z" creationid="tlqk35" creationdate="20220321T153317Z">
        <seg>표기상으로 ident가 단순히 임의의 유형의 인수를 받을 수 있는 것처럼 만들어 유형의 명세를 감춥니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note
that × is a Unicode symbol.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140054Z" creationid="tlqk35" creationdate="20220321T140054Z">
        <seg>×은 유니코드 기호임을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that Exists.intro has implicit arguments: Lean has to infer
the predicate p : α → Prop in the conclusion ∃ x, p x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181019Z" creationid="tlqk35" creationdate="20220321T181019Z">
        <seg>Exists.intro은 암시적인자를 가지고 있음을 유의하세요. 린은 결론 ∃ x, p x에서 술어 p : α → Prop를 추론해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that Nat.mul_add and Nat.add_mul are alternative names
for Nat.left_distrib and Nat.right_distrib, respectively.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180000Z" creationid="tlqk35" creationdate="20220321T180000Z">
        <seg>Nat.mul_add과 Nat.add_mul은 각각 Nat.left_distrib과 Nat.right_distrib에 대한 별명임을 유의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that Lean hides the other goals inside the case block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061427Z" creationid="tlqk35" creationdate="20220522T061427Z">
        <seg>린은 case블록 안에 다른 목표를 숨긴 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that double does not have y as argument.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175335Z" creationid="tlqk35" creationdate="20220524T175335Z">
        <seg>double은 y를 인수로서 갖지 않음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that it is often useful to use numeric unicode subscripts,
entered as \0, \1, \2, ..., for hypotheses, as we did in
this example.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161817Z" creationid="tlqk35" creationdate="20220321T161817Z">
        <seg>수치 유니코드 밑첨자를 사용하는 것은 종종 유용합니다. 이 예제에서 그런 것처럼 가정에 대해 \0, \1, \2, ..., 으로 쳐서 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that names automatically generated by Lean are inaccessible by default.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063146Z" creationid="tlqk35" creationdate="20220522T063146Z">
        <seg>린에 의해 자동으로 생성된 이름들은 기본적으로 접근할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the theorem command is really a version of the
def command: under the propositions and types
correspondence, proving the theorem p → q → p is really the same
as defining an element of the associated type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160842Z" creationid="tlqk35" creationdate="20220321T160842Z">
        <seg>theorem 명령은 def 명령의 한 버전이라는 것을 주목하세요. 명제와 유형 대응 하에서 정리 p → q → p의 증명하는 것은 연관된 유형의 원소를 증명하는 것과 정말 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the anonymous constructor
notation ⟨w, hw.right, hw.left⟩ abbreviates a nested constructor
application; we could equally well have written ⟨w, ⟨hw.right, hw.left⟩⟩.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181633Z" creationid="tlqk35" creationdate="20220321T181633Z">
        <seg>익명 생성자 기호 ⟨w, hw.right, hw.left⟩가 중첩된 생성자 활용을 간략히 한다는 것을 주목하세요. 우리는 이를 ⟨w, ⟨hw.right, hw.left⟩⟩로 동등한 의미를 갖게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the syntax is similar to the one used in match expressions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070416Z" creationid="tlqk35" creationdate="20220522T070416Z">
        <seg>문법이 match 표현식에서의 것과 비슷함에 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the various simp options we have discussed --- giving an
explicit list of rules, and using at to specify the location --- can be combined,
but the order they are listed is rigid.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T165658Z" creationid="tlqk35" creationdate="20220524T165658Z">
        <seg>논의한 다양한 simp 옵션은 규칙의 명시적인 리스트를 주고 at을 
사용해 위치를 나타내는 것으로 결합될 수 있다. 그러나 나열된 순서는 변하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that up to the names we have chosen for the variables, the
definitions are identical to the proofs of the analogous propositions
for conjunction and disjunction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220523T073708Z" creationid="tlqk35" creationdate="20220523T073708Z">
        <seg>우리가 변수에 대한 이름을 선택하는 한 정의들은 
결합자와 분리자에 대한 유사한 명제의 증명과 
동일할 것임을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice here we called the double function to create the first
parameter to add.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144328Z" creationid="tlqk35" creationdate="20220321T144328Z">
        <seg>여기서 우리가 add의 첫 번째 매개변수를 만들기 위해 double 함수를 호출한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that (a : α) → β makes sense for any expression β :
Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151858Z" creationid="tlqk35" creationdate="20220321T151858Z">
        <seg>(a : α) → β는  모든 식  β : Type에 대해 성립하는 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that an existential proposition is very similar to a sigma
type, as described in dependent types section.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181643Z" creationid="tlqk35" creationdate="20220321T181643Z">
        <seg>존재 명제는 의존 유형론 섹션에서 설명했던 시그마 유형과 아주 비슷한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that and-introduction and and-elimination are similar to the
pairing and projection operations for the cartesian product.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162854Z" creationid="tlqk35" creationdate="20220321T162854Z">
        <seg>and-도입과 and-제거는 카테시안 곱 연산의 순서쌍을 구성하는 것과 순서쌍에서 원소를 추출하는 연산과 비슷한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that applying a term t : α → β to a term s : α yields
an expression t s : β.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143513Z" creationid="tlqk35" creationdate="20220321T143513Z">
        <seg>항 t : α → β을 항 s : α에 적용하여 표현식 t s : β을 얻는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that if α is any
type, we can form the type α → Prop of all predicates on α
(the "power type of α").</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175148Z" creationid="tlqk35" creationdate="20220321T175148Z">
        <seg>만약 α가 임의의 유형이면, 우리는  α에 대한 모든 술어에 대해 α → Prop형을 만들 수 있습니다. (" α형의 능력")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that if α is any type, we can represent a unary predicate
p on α as an object of type α → Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172626Z" creationid="tlqk35" creationdate="20220321T172626Z">
        <seg>α 가 임의의 유형인지를 보세요, 우리는 α에 대해 단항 술어 p를  α → Prop형의 대상으로 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that implicit arguments are inserted eagerly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184901Z" creationid="tlqk3" creationdate="20220525T184901Z">
        <seg>암시적인 인수는 간절히 삽입됨을 주의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that now the first #check command gives the type of the
identifier, id, without inserting any placeholders.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153754Z" creationid="tlqk35" creationdate="20220321T153754Z">
        <seg>현재 첫 번째 #check 명령은 식별자 id의 유형을 어떤 플레이스 홀더도 삽입하지 않고 주는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the lambda abstractions hp : p and hq : q can be
viewed as temporary assumptions in the proof of t1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161038Z" creationid="tlqk35" creationdate="20220321T161038Z">
        <seg>람다 추상화 hp : p과 hq : q은 t1의 증명에서 일시적인 가정으로 보일 수 있음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the last example specifies that the rewrite
should take place on the right-hand side by specifying the second
argument to Nat.add_comm.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171924Z" creationid="tlqk35" creationdate="20220524T160039Z">
        <seg>마지막 예제는  Nat.add_comm의 
두 번째 인수를 명시함으로써 우변에 다시쓰기가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the meaning of the expression let a := t1; t2 is very
similar to the meaning of (fun a =&gt; t2) t1, but the two are not
the same.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144909Z" creationid="tlqk35" creationdate="20220321T144909Z">
        <seg>표현식 let a := t1; t2의 의미는 (fun a =&gt; t2) t1의 의미와 아주 비슷함을 주목하세요. 그러나 이 둘은 같지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the second example and the last two examples require the
assumption that there is at least one element a of type α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183157Z" creationid="tlqk35" creationdate="20220321T183157Z">
        <seg>두 번째 예제와 마지막 두 예제는 α형의 한 원소 a가 적어도 하나 있다는 가정을 필요로 한다는 것을 유의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the second implicit parameter to Eq.subst, which
provides the context in which the substitution is to occur, has type
α → Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180044Z" creationid="tlqk35" creationdate="20220321T180044Z">
        <seg>대체가 일어나는 곳에 대한 맥락을 제공하는 두번째 암시적 인수 Eq.subst이 α → Prop형을 가지는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that there is enough information in the full expression for
Lean to infer the types of hp and hq as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164048Z" creationid="tlqk35" creationdate="20220321T164048Z">
        <seg>hp와 hq의 유형을 추론하기에 린에게 완전한 표현식에 충분한 정보가 있음을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now to get a bit more abstract, you can also specify arguments that
are like type parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144422Z" creationid="tlqk35" creationdate="20220321T144422Z">
        <seg>이제 약간 더 추상적으로 갑시다. 여러분은 유형 매개변수같은 인수를 지정할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now we can apply the theorem t1 just as a function application.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161146Z" creationid="tlqk35" creationdate="20220321T161146Z">
        <seg>이제 우리는 정리 t1을 함수 활용에 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now, given that
h has type ∀ x : α, p x ∧ q x, the expression h y has type
p y ∧ q y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173844Z" creationid="tlqk35" creationdate="20220321T173844Z">
        <seg>이제 h가 ∀ x : α, p x ∧ q x형을 갖는다고 해봅시다. 그러면 표현식 h y는  p y ∧ q y형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153644Z" creationid="tlqk35" creationdate="20220321T153644Z">
        <seg>수치들은 Lean에 매우 많이 있습니다. 그러나 수치 유형이 추론되지 못할 때, 린은 기본적으로 그걸 자연수라고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Of course, a fundamental property of equality is that it is an equivalence relation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175431Z" creationid="tlqk35" creationdate="20220321T175431Z">
        <seg>물론 동등의 기초적인 성질은 등가 관계라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Of course, it is unsound
as a proof method -- for example, you can use it to prove False --
and Lean produces severe warnings when files use or import theorems
which depend on it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170302Z" creationid="tlqk35" creationdate="20220321T170302Z">
        <seg>물론 증명 방법으로 건전하지 않습니다. -- 예를 들어, 여러분은 False 을 증명하는데 그것을 사용할 수 있습니다. --그러면 린은 그것에 의존하는 정리를 불러오거나 그런 파일을 사용할 때 심각한 경고를 보냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Often proofs move from one fact to the next, so this can be effective
in eliminating the clutter of lots of labels.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183348Z" creationid="tlqk35" creationdate="20220321T183348Z">
        <seg>증명은 종종 한 사실에서 다음 사실로 이동하기 때문에 이것은 많은 이름으로 생기는 혼동을 없애는 데 효과적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Often, when you import a module, you will want to open one or
more of the namespaces it contains, to have access to the short
identifiers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150448Z" creationid="tlqk35" creationdate="20220321T150448Z">
        <seg>짧은 식별자로 접근하기 위해서 종종 여러분이 모듈을 가져오기(import) 할 때, 모듈이 담은 다수의 이름공간을 열기 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once again, it is the Curry-Howard isomorphism that allows
us to co-opt this mechanism for writing proofs as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182618Z" creationid="tlqk35" creationdate="20220321T182618Z">
        <seg>한 번 더  커리-하워드 동형은 우리가 증명을 작성하는 데에도 이 메커니즘과 함께 쓰이게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once again, using the propositions-as-types correspondence, the
variable h of type r → s can be viewed as the hypothesis, or
premise, that r → s holds.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161724Z" creationid="tlqk35" creationdate="20220321T161724Z">
        <seg>다시 한 번, 유형으로써 명제 대응을 사용하면 r → s형의 변수 h는 r → s을 성립시키는 가정 또는 전제로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once again, you should exercise judgment as to whether such
abbreviations enhance or diminish readability.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164151Z" creationid="tlqk35" creationdate="20220321T164151Z">
        <seg>다시 한 번, 여러분은 그러한 간략화가 가독성을 높이는지 낮추는지 판단을 시험해보셔야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once again, you should try some examples on your own.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140307Z" creationid="tlqk35" creationdate="20220321T140307Z">
        <seg>다시 한번 여러분 스스로 몇 가지 예제를 시도해보기 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the attribute is applied, however, there is no way to permanently
remove it; it persists in any file that imports the one where the
attribute is assigned.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171543Z" creationid="tlqk35" creationdate="20220524T165238Z">
        <seg>그러나 한 번 이 특성이 적용되면 그 특성이 부여된 정리를 불러온 어떤 파일이든 
지속되므로 영구적으로 이를 제거할 방법이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once the proof of a
theorem is complete, typically we only need to know that the proof
exists; it doesn't matter what the proof is.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160910Z" creationid="tlqk35" creationdate="20220321T160910Z">
        <seg>한번 정리의 증명이 마쳐지면 우리는 증명이 존재한다는 것만 알면 됩니다. 증명이 무엇인지 아는 것은 중요하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can also assign the attribute any time after the definition takes place:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183057Z" creationid="tlqk3" creationdate="20220525T183031Z">
        <seg>어떤 이는 이 정의를 만든 뒤 어느 때든지 특성을 부여할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can also specify imports relative to the current directory; for example,
Importing is transitive.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174453Z" creationid="tlqk35" creationdate="20220524T174453Z">
        <seg>어떤 이는 현재 경로에 상대적으로 불러오기를 명시할 수 있습니다. 예를 들어 불러오는 것은 전이적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can always specify the type T of an expression e by
writing (e : T).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153518Z" creationid="tlqk35" creationdate="20220321T153518Z">
        <seg>누군가는 표현식 e의 유형 T를 (e : T)와 같이 씀으로써 항상 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can similarly infer the argument in Lst.nil Nat, not
from anything else in that expression, but from the fact that it is
sent as an argument to the function Lst.cons, which expects an element
of type Lst α in that position.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153125Z" creationid="tlqk35" creationdate="20220321T152730Z">
        <seg>어떤 식으로부터도 아니고 Lst α형의 원소를 기대하는  Lst.cons 함수에 인수로 전달되었다는 사실로부터 누군가는 비슷하게 Lst.nil Nat에서 인수를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One consequence of the law of the excluded middle is the principle of
double-negation elimination:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165753Z" creationid="tlqk35" creationdate="20220321T165753Z">
        <seg>배중률의 한 결과는 이중 부정 제거의 원리입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One strategy for proving assertions about objects defined in the
language of dependent type theory is to layer an assertion language
and a proof language on top of the definition language.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154820Z" creationid="tlqk35" creationdate="20220321T154820Z">
        <seg>의존 유형론의 언어로 정의된 객체에 대해서 주장을 증명하는 한 전략은 주장 언어와 증명 언어를 정의언어의 꼭대기 층에 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One thing that is nice about Lean's proof-writing syntax is that it is
possible to mix term-style and tactic-style proofs, and pass between
the two freely.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142848Z" creationid="tlqk35" creationdate="20220524T142848Z">
        <seg>Lean의 증명 작성 문법에 대해 좋은 점은 항 스타일과 전략 스타일의 증명을 섞고,
 이들 사이를 자유로이 왕래할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One thing that makes the simplifier especially useful is that its
capabilities can grow as a library develops.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171639Z" creationid="tlqk35" creationdate="20220524T164211Z">
        <seg>단순화기를 특히 유용하게 만드는 한 가지는 그것의 능력이 
라이브러리가 개발되어 감에 따라 증가한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way in which Lean's dependent type theory extends simple type
theory is that types themselves --- entities like Nat and Bool
--- are first-class citizens, which is to say that they themselves are
objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141313Z" creationid="tlqk35" creationdate="20220321T141313Z">
        <seg>린의 종속 유형론이 단순 유형론을 확장시키는 한 방법은 ---Nat과 Bool같은 개체는 그들 그 자체로 대상인 일등 시민 ---으로 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Or</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162105Z" creationid="tlqk35" creationdate="20220321T162105Z">
        <seg>논리합</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Or even this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180458Z" creationid="tlqk35" creationdate="20220321T180458Z">
        <seg>심지어 이렇게도 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Or you can carry out a proof by contradiction:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165949Z" creationid="tlqk35" creationdate="20220321T165949Z">
        <seg>한편 여러분은 귀류법으로 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ordinarily, you meet such a goal by writing an explicit term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184454Z" creationid="tlqk35" creationdate="20220321T184454Z">
        <seg>일반적으로 명시적인 항을 작성하여 이런 목표를 달성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ordinary classical logic adds to
this the law of the excluded middle, p ∨ ¬p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185340Z" creationid="tlqk35" creationdate="20220321T165657Z">
        <seg>평범한 고전 논리는 여기에 배중률 p ∨ ¬p을 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other properties:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170151Z" creationid="tlqk35" creationdate="20220321T170151Z">
        <seg>다른 성질들:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other systems provide search procedures and decision procedures for specific languages and domains,
such as linear or nonlinear expressions over the integers or the real numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131328Z" creationid="tlqk35" creationdate="20220321T131328Z">
        <seg>다른 시스템들은 특정 언어와 영역에 대한 선형 혹은 비선형 식(가령 정수나 실수에 대해 정의된)들에 탐색 절차과 결정 절차를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Outside the section, the simplifier will no longer use
reverse_mk_symm by default.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T165457Z" creationid="tlqk35" creationdate="20220524T165457Z">
        <seg>섹션 바깥 쪽에서 단순화기는 기본적으로 reverse_mk_symm을 사용할 수 없게 될 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Parallel
sequencing is one way to arrange it so that a single tactic is applied
to multiple goals, but there are other ways to do this.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T152200Z" creationid="tlqk35" creationdate="20220524T152200Z">
        <seg>병렬은 이를 배열하는 한 방법이므로 하나의 전략이 다수의 목표에 적용될 수 있습니다. 
그러나 이를 할 수 있는 다른 방식들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Please see lean prover and lean community for an up to date list
of our amazing contributors.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134918Z" creationid="tlqk35" creationdate="20220321T134918Z">
        <seg>합린 증명보조기와 린 커뮤니티에서 놀라운 최신 기여자 명단을 확인할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Printing them out shows that all three groups of definitions have
exactly the same effect.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145220Z" creationid="tlqk35" creationdate="20220321T145220Z">
        <seg>이것을 출력하는 것은 세 정의 그룹이 정확히 동일한 효과를 가짐을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propositional Logic</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161827Z" creationid="tlqk35" creationdate="20220321T161827Z">
        <seg>명제 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propositions and Proofs</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154753Z" creationid="tlqk35" creationdate="20220321T154753Z">
        <seg>명제와 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Propositions as Types</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154815Z" creationid="tlqk35" creationdate="20220321T154815Z">
        <seg>유형으로써 명제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove ¬(p ↔ ¬p) without using classical logic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185359Z" creationid="tlqk35" creationdate="20220321T170721Z">
        <seg>고전 논리를 사용하지 않고 ¬(p ↔ ¬p)을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove as many of the identities listed in the Existential
Quantifier section as you can.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184006Z" creationid="tlqk35" creationdate="20220321T184006Z">
        <seg>존재 정량자에서 수록된 항등식을 여러분이 할 수 있는 만큼 가능한 많이 증명해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove that this is a contradiction:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183839Z" creationid="tlqk35" creationdate="20220321T183839Z">
        <seg>이것이 모순임을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove the following identities, replacing the "sorry" placeholders
with actual proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170704Z" creationid="tlqk35" creationdate="20220321T170704Z">
        <seg>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove the following identities, replacing the "sorry" placeholders with actual proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170611Z" creationid="tlqk35" creationdate="20220321T170611Z">
        <seg>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prove these equivalences:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183748Z" creationid="tlqk35" creationdate="20220321T183748Z">
        <seg>이 등가식들을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Quantifiers and Equality</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172532Z" creationid="tlqk35" creationdate="20220321T172532Z">
        <seg>한정기호와 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rather, it is the fact that we can write them
down and check that they are well-typed that ensures that the
proposition in question is true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160408Z" creationid="tlqk35" creationdate="20220321T160408Z">
        <seg>그것보다 우리가 표현식을 쓰고 잘 쓰여졌는지 확인할 수 있다는 사실은 의문의 명제가 참인지를 확실히 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall that terms in the
Calculus of Constructions have a computational interpretation, and
that the logical framework treats terms with a common reduct as the
same.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175635Z" creationid="tlqk35" creationdate="20220321T175635Z">
        <seg>직관주의적 계산법의 항은 계산적인 해석을 갖고 논리 프레임워크는 공통 환원된 항을 같은 것으로 다룬는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall that the def keyword provides one important way of declaring new named
objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143839Z" creationid="tlqk35" creationdate="20220321T143839Z">
        <seg>def가 새 이름을 가진 대상을 선언하는 중요한 방식임을 기억하세요.

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall that we can also write theorem t1 as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161408Z" creationid="tlqk35" creationdate="20220321T161408Z">
        <seg>우리는 정리 t1을 다음과 같이 쓸 수 있음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall that, in the case of ordinary
function spaces, we could interpret α → β as the special case of
(x : α) → β in which β does not depend on x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173603Z" creationid="tlqk35" creationdate="20220321T173603Z">
        <seg>평범한 함수공간의 경우에 대해 우리는 α → β을 (x : α) → β의 특별한 경우로 해석할 수 있음을 생각해보세요. 이때  β는 x에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall this tells Lean that
the argument is implicit, and should be filled in automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170438Z" creationid="tlqk35" creationdate="20220321T170438Z">
        <seg>이것이 린에게 인수가 암시적이고 자동적으로 채우게 함을 의미한다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Reflexivity is more powerful than it looks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175629Z" creationid="tlqk35" creationdate="20220321T175629Z">
        <seg>대칭성은 보기 보다 더 강력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that → associates to the right (nothing changes
now that the arguments are elements of Prop, instead of some other
Type), as do the other binary connectives.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162316Z" creationid="tlqk35" creationdate="20220321T162316Z">
        <seg>다른 이항 결합자들처럼 →은 오른쪽으로 결합한다는 것을 기억하세요.(인수가 Type 대신 Prop인 것을 제외하고 변한 건 없습니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that expressions which differ up to renaming of bound
variables are considered to be equivalent.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173915Z" creationid="tlqk35" creationdate="20220321T173915Z">
        <seg>표현식들은 구속변수의 이름이 달라지기까지 동등한 것으로 간주된다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that the point of the variable command is to
declare variables for use in theorems, as in the following example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175057Z" creationid="tlqk35" creationdate="20220524T175057Z">
        <seg>variable 명령의 요점은 다음 예제에서 처럼 정리에서 사용하기 위한 변수를 선언하는 것임을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that this type can just as well
be written ∀ (p q : Prop) (hp : p) (hq :q), p, since the arrow
denotes nothing more than an arrow type in which the target does not
depend on the bound variable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161645Z" creationid="tlqk35" creationdate="20220321T161645Z">
        <seg>왜냐하면 화살표는 대상이 구속 변수에 의존하지 않는 화살표 유형만을 나타내기 때문에 이 유형은 ∀ (p q : Prop) (hp : p) (hq :q), p로 쓸 수 있게 함을 기억하세요. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that, without any parameters, an expression of type
Prop is just an assertion.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183859Z" creationid="tlqk35" creationdate="20220321T183859Z">
        <seg>어떤 매개변수도 없이 Prop형의 표현식은 그저 주장일 뿐이라는 걸 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember the introduction and
elimination rules for dependent arrow types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173012Z" creationid="tlqk35" creationdate="20220321T173012Z">
        <seg>의존 화살표 유형에 대한 도입과 소거 규칙을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Replace calling rustdoc --test from mdbook test with ./test</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171930Z" creationid="tlqk35" creationdate="20220321T171930Z">
        <seg> mdbook test에서 rustdoc --test을 호출하는 것을 ./test으로 대체함.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolution theorem provers, tableau theorem provers, fast
satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and
first-order logic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131315Z" creationid="tlqk35" creationdate="20220321T131315Z">
        <seg>Resolution 증명 보조기, tableau 증명 보조기, fast satisfiability 솔버 등등은 명제 논리식와 1계 논리식의 유효성을 식별하는 세우는 수단을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning to the example of lists, you can use the command #check to
inspect the type of the following List functions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152114Z" creationid="tlqk35" creationdate="20220321T152114Z">
        <seg>리스트의 예로 돌아가서 여러분은 다음 List 함수의 유형을 검사하기 위해 #check 명령을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning to the previous example and
renaming bound variables for clarity, notice the types of the
following expressions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143523Z" creationid="tlqk35" creationdate="20220321T143523Z">
        <seg>이전 예제로 돌아가 명확성을 위해 구속변수의 이름을 바꿉시다. 다음 표현식의 유형을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rewrites can be applied sequentially, so that the proof above can be
shortened to this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180445Z" creationid="tlqk35" creationdate="20220321T180445Z">
        <seg>다시쓰기는 연속적으로 쓸 수 있습니다. 따라서 위의 증명은 이와 같이 더 짧아질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Rewriting</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T160714Z" creationid="tlqk35" creationdate="20220524T160714Z">
        <seg>다시쓰기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Roughly speaking, since we know there is an x satisfying
p x, we can give it a name, say, w.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181317Z" creationid="tlqk35" creationdate="20220321T181317Z">
        <seg>대략 말하자면 p x를 만족하는 x가 있다는 것을 알기 때문에 이것에 w라는 이름을 줄 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Run mdbook test to test all lean code blocks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172249Z" creationid="tlqk35" creationdate="20220321T172249Z">
        <seg>모든  lean의 코드 블록을 테스트하려면 mdbook test을 실행하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Second, when writing type expressions, arrows associate to the right; for
example, the type of Nat.add is Nat → Nat → Nat which is equivalent
to Nat → (Nat → Nat).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140808Z" creationid="tlqk35" creationdate="20220321T140808Z">
        <seg>둘째로 유형 표현식을 쓸 때 화살표는오른쪽 먼저 결합합니다. 가령Nat.add의 유형은 Nat → Nat → Nat이고 이는 Nat → (Nat → Nat)과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sections are also useful for delimiting the scope of
commands such as set_option and open.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150626Z" creationid="tlqk35" creationdate="20220321T150626Z">
        <seg>section은 set_option과 open같이 명령의 범위를 제한하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sections can also be nested,
which allows you to declare new variables incrementally.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150155Z" creationid="tlqk35" creationdate="20220321T150155Z">
        <seg>section은 중첩될 수도 있습니다. 이는 여러분에게 새로운 변수를 점진적으로 선언할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See the Setting
Up Lean section of
the Lean 4 Manual to install Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171440Z" creationid="tlqk35" creationdate="20220321T171440Z">
        <seg>Lean을 설치하려면 Lean 4 Manual의  Setting Up Lean section을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly,
Iff.mpr h produces a proof of q → p from h : p ↔ q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164748Z" creationid="tlqk35" creationdate="20220321T164748Z">
        <seg>마찬가지로 Iff.mpr h는 h : p ↔ q으로부터 q → p의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, And.right h is a proof of q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162807Z" creationid="tlqk35" creationdate="20220321T162807Z">
        <seg>마찬가지로 And.right h는 q의 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, Or.intro_right p hq creates a
proof for p ∨ q using a proof hq : q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163629Z" creationid="tlqk35" creationdate="20220321T163629Z">
        <seg>마찬가지로 Or.intro_right p hq는 hq : q의 증명을 사용하여 p ∨ q 의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, Lean detects the occurrence of x in
t1 and t2, and inserts it automatically there, too.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175253Z" creationid="tlqk35" creationdate="20220524T175253Z">
        <seg>마찬가지로 린은 t1와 t2에서 x의 나타남을 감지하고 
거기에도 자동적으로 그것을 삽입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, an object r : α → α → Prop denotes a binary
relation on α: given x y : α, r x y denotes the assertion
that x is related to y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172813Z" creationid="tlqk35" creationdate="20220321T172813Z">
        <seg>마찬가지로 대상 r : α → α → Prop은 α에 대한 이항 관계 즉, x y : α이 주어진다면 , r x y은 x가 y에 연관된다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you use an open command within a
namespace, its effects disappear when the namespace is closed.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150742Z" creationid="tlqk35" creationdate="20220321T150742Z">
        <seg>마찬가지로 여러분이 이름공간 내에서 open 명령을 사용한다면 그것의 효과는 이름공간이 닫힐 때 사라질 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, methods of elaboration and type inference, which can be used to support
flexible forms of algebraic reasoning.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134656Z" creationid="tlqk35" creationdate="20220321T134656Z">
        <seg>비슷하게 대수 추론의 유연한 형태를 지원하는데 사용될 수 있는 협력법과  유형 추론</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, the
expression hnp hp produces a proof of False from hp : p
and hnp : ¬p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164250Z" creationid="tlqk35" creationdate="20220321T164250Z">
        <seg>마찬가지로 표현식 hnp hp은 hp : p과 hnp : ¬p으로부터 False의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, two dashes -- indicate that the rest of
the line contains a comment that is also ignored.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135543Z" creationid="tlqk35" creationdate="20220321T135543Z">
        <seg>마찬가지로 두 개의 대시 --는 이 줄의 나머지는 주석을 포함함을 나타내고 이 또한 무시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, we
can think of an implication p → q between propositions as the
special case of ∀ x : p, q in which the expression q does not
depend on x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173633Z" creationid="tlqk35" creationdate="20220321T173633Z">
        <seg>마찬가지로 우리는 명제들 사이의 함의 p → q를 ∀ x : p, q의 특별한 경우로써 생각할 수 있습니다. 이때 q는 x에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple Type Theory</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135147Z" creationid="tlqk35" creationdate="20220321T135147Z">
        <seg>단순 유형론(Simple Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So
the expressions in the first two #check commands below are
elaborated in the same way, whereas the third #check command
interprets 2 as an integer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153707Z" creationid="tlqk35" creationdate="20220321T153707Z">
        <seg>그래서 아래 첫 두 #check명령에서 표현식은 같은 방식으로 해석됩니다. 반면 세 번째 #check 명령은 2를 정수로 해석합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So def can also be used to simply name a value like this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144224Z" creationid="tlqk35" creationdate="20220321T144224Z">
        <seg>그래서 def는 이 같은 값을 단순히 이름으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So constructing an
element t : p tells us that p is indeed true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160102Z" creationid="tlqk35" creationdate="20220321T160102Z">
        <seg>그러므로 원소 t : p을 생성하는 것은 p가 사실이라고 우리에게 알립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if we have
p q r : Prop, the expression p → q → r reads "if p, then if q,
then r." This is just the "curried" form of p ∧ q → r.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162407Z" creationid="tlqk35" creationdate="20220321T162407Z">
        <seg>그래서 만약 p q r : Prop이 있다면 표현식 p → q → r은 "p이면 그러면q이면r이다."로 읽습니다. 이는 p ∧ q → r의 "커리된(curried)" 형태일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So it makes sense to take the type to be the first argument to
cons, so that for any type, α, cons α is the insertion
function for lists of type α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151156Z" creationid="tlqk35" creationdate="20220321T151156Z">
        <seg>그래서 cons의 첫번째 인수의 유형으로 임의의 유형 α를 받아들이게 하는게 타당합니다. cons α는 α유형을 원소로 하는 리스트에 대한 삽입 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So, for example, we could
have used the same variable, x, in both the hypothesis and
conclusion, and instantiated it by a different variable, z, in the
proof:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173933Z" creationid="tlqk35" creationdate="20220321T173933Z">
        <seg>그럼 예를들어 우리가 같은 변수 x 가정과 결론 양쪽에 사용할 수 있어야 합니다. 그리고 증명에서 다른 변수 z에 의해 이것이 개체화됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So, for example, you
can write fun x =&gt; g (f x) instead of fun x : Nat =&gt; g (f x).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143113Z" creationid="tlqk35" creationdate="20220321T143113Z">
        <seg>그래서 여러분은 fun x : Nat =&gt; g (f x)대신에 fun x =&gt; g (f x)와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So, if t
ordinarily only effects the current goal, focus (all_goals t) has
the same effect as t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T153117Z" creationid="tlqk35" creationdate="20220524T153117Z">
        <seg>그래서 만약 t이 똑같이 현재 목표에만 영향을 미친다면 
focus (all_goals t)은 t와 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some additional tactics are useful for constructing and destructing
propositions and data.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070154Z" creationid="tlqk35" creationdate="20220522T070154Z">
        <seg>몇 가지 추가적인 전략들은 명제와 데이터를 생성하고 파괴하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some mathematically common examples of operations of functions can be
described in terms of lambda abstraction:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142622Z" creationid="tlqk35" creationdate="20220321T142622Z">
        <seg>수학적으로 흔한 함수 연산 예제는 람다 추상화에 대한 것으로 설명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some operations, however, need to be polymorphic over type
universes.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141814Z" creationid="tlqk35" creationdate="20220321T141814Z">
        <seg>그러나 몇몇 연산은 유형 세계에 대해 다형적(polymorphic)일 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some simplifications are possible, however.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155224Z" creationid="tlqk35" creationdate="20220321T155224Z">
        <seg>하지만 몇 가지 단순화는 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes the left-hand side of an identity can match more than one
subterm in the pattern, in which case the rw tactic chooses the
first match it finds when traversing the term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172011Z" creationid="tlqk35" creationdate="20220524T155343Z">
        <seg>때때로 항등식의 좌변은 패턴의 한개 이상의 부분항과 동일할 수 있습니다. 
그 경우 rw 전략은 항들을 가로지면서 처음 일치하는 것을 찾고 선택합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes, however, it is useful to limit
the scope of a variable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150032Z" creationid="tlqk35" creationdate="20220321T150032Z">
        <seg>그러나 때때로 변수의 범위를 제한하는 것이 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153716Z" creationid="tlqk35" creationdate="20220321T153716Z">
        <seg>하지만 때때로 우리는 우리 스스로 함수에 대한 인수가 암시적이도록 선언하는 걸 발견합니다. 그러나 지금 인수를 명시적으로 제공하길 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special modes in Visual Studio Code (VS Code for short) and
Emacs offer powerful support for writing and debugging proofs, and is much better suited for serious use.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131922Z" creationid="tlqk35" creationdate="20220321T131922Z">
        <seg>비주얼 스튜디오 코드(짧게는 VS code)에서 특정 모드와 Emacs는 강력한 편집 기능과 증명 디버깅 기능을 지원합니다. 그리고 진지한 사용을 생각한다면 이게 훨씬 적합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Specifically,
congrArg can be used to replace the argument, congrFun can be
used to replace the term that is being applied, and congr can be
used to replace both at once.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175909Z" creationid="tlqk35" creationdate="20220321T175909Z">
        <seg>구체적으로 congrArg은 인수를 대체하는데 사용될 수 있습니다. congrFun은 적용된 항을 대체하는데 사용할 수 있습니다. 그리고 congr는 한번에 둘 다 대체하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Start writing the proof from the top down, using
sorry to fill in subproofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170320Z" creationid="tlqk35" creationdate="20220321T170320Z">
        <seg>하향식으로 증명 작성을 하작하려면 보조 증명에 sorry를 채워 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Structuring Tactic Proofs</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142401Z" creationid="tlqk35" creationdate="20220524T142401Z">
        <seg>전략 증명 구조화하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Such a
function is polymorphic: you expect the cons function for
Nat, Bool, or an arbitrary type α to behave the same way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151118Z" creationid="tlqk35" creationdate="20220321T151118Z">
        <seg>이러한 함수는 polymorphic입니다. 여러분은 cons는  Nat, Bool 혹은 임의의 유형  α에 대해 동일한 방식으로 동작해야 한다고 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Such systems
can have bugs, and it can be difficult to ensure that the results they deliver are correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131418Z" creationid="tlqk35" creationdate="20220321T131418Z">
        <seg>이런 시스템들은 버그가 생길 수 있고, 그들이 올바르다고 도출한 결과를 확실히 보장하기가 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose that, assuming p as a hypothesis, we have a proof of q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155118Z" creationid="tlqk35" creationdate="20220321T155118Z">
        <seg>p를 가정으로 하면 q의 증명을 가질 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose we define
a function f (x : Nat) {y : Nat} (z : Nat) with the arguments
shown.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184942Z" creationid="tlqk3" creationdate="20220525T184942Z">
        <seg>우리가 인수를 제시하여 함수 f (x : Nat) {y : Nat} (z : Nat)을 정의했다고 합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose we have α : Sort i and β : Sort j, where the
expression β may depend on a variable x : α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174455Z" creationid="tlqk35" creationdate="20220321T174455Z">
        <seg>우리가 α : Sort i과 β : Sort j을 갖고 있다고 가정합시다. 여기서 표현식 β는 변수  x : α에 의존할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose we have an implementation of lists as:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152423Z" creationid="tlqk35" creationdate="20220321T152423Z">
        <seg>우리가 리스트의 구현을 다음과 같이 했다고 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose you have the variable x : α and you can
construct an expression t : β, then the expression fun (x : α)
=&gt; t, or, equivalently, λ (x : α) =&gt; t, is an object of type α
→ β.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142401Z" creationid="tlqk35" creationdate="20220321T142401Z">
        <seg>여러분이 변수 x : α를 갖고 있고 표현식 t : β을 만들 수 있다 가정합시다. 그러면 표현식fun (x : α) =&gt; t 또는 등가적으로 λ (x : α) =&gt; t은 α → β 유형인 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose you wish to write a function cons which inserts a new
element at the head of a list.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151011Z" creationid="tlqk35" creationdate="20220321T151011Z">
        <seg>여러분이 리스트의 머리에 새 원소를 삽입하는 함수 cons를 만들기 원한다 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose, however, that β
is of Sort 0, that is, an element of Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174921Z" creationid="tlqk35" creationdate="20220321T174852Z">
        <seg>그러나 β가 Sort 0형이라고 가정하면 즉, Prop의 원소라면</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Systems of natural deduction for propositional logic also typically rely on the following rule:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155031Z" creationid="tlqk35" creationdate="20220321T155031Z">
        <seg>명제논리의 자연 영역에 대한 체계은 주로 다음 규칙에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactic commands can take compound expressions, not just single
identifiers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060558Z" creationid="tlqk35" creationdate="20220522T060558Z">
        <seg>전략 명령은 하나의 식별자 뿐만 아니라 복합된 식을 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactics</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184229Z" creationid="tlqk35" creationdate="20220321T184229Z">
        <seg>전략</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactics often provide an efficient way of building a proof, but long
sequences of instructions can obscure the structure of the
argument.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142528Z" creationid="tlqk35" creationdate="20220524T142528Z">
        <seg>전략들은 종종 증명을 세우는데 효율적인 방식을 제공합니다. 그러나 
지시사항들의 긴 나열은 인수(argument)의 구조를 모호하게 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tactics that may produce multiple subgoals often tag them.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060948Z" creationid="tlqk35" creationdate="20220522T060948Z">
        <seg>다수의 하위 목표를 생성할 수 있는 전략은 이들에 표식을 붙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Taking the left conjunct
gives the desired conclusion, p y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173906Z" creationid="tlqk35" creationdate="20220321T173906Z">
        <seg>왼쪽의 결합자를 취하는 것은 원하는 결론 p y을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That assignment can also be made local:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183629Z" creationid="tlqk3" creationdate="20220525T183629Z">
        <seg>그 배정는 지역적으로 만들어 질 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That command, which will
be explained in Chapter Type Classes, works by
assigning an [instance] attribute to the associated definition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183540Z" creationid="tlqk3" creationdate="20220525T183540Z">
        <seg> Chapter Type Classes에서 설명할 그 명령은 연관된 정의에 [instance] 특성을 배정하는 것으로 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is, given h1 : a = b and h2 : p a, we
can construct a proof for p b using substitution:
Eq.subst h1 h2.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175735Z" creationid="tlqk35" creationdate="20220321T175735Z">
        <seg>즉, h1 : a = b과 h2 : p a에 대해 p b에 대한 증명을 Eq.subst h1 h2과 같은 대체를 사용하여 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The
canonical way to prove ∀ y : α, p y is to take an arbitrary y,
and prove p y.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173803Z" creationid="tlqk35" creationdate="20220321T173803Z">
        <seg>∀ y : α, p y을 증명하는 표준 방법은 임의의 y를 받고  p y임을 증명하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The
command</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174052Z" creationid="tlqk35" creationdate="20220524T174052Z">
        <seg>명령</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The
difference is that given hp : p and hq : q, And.intro hp
hq has type p ∧ q : Prop, while Prod hp hq has type
p × q : Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162937Z" creationid="tlqk35" creationdate="20220321T162937Z">
        <seg>차이는 hp : p와 hq : q가 주어졌을 때 And.intro hp hq는 p ∧ q : Prop형을 갖는 한편 Prod hp hq는 p × q : Type형을 갖는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The
properties above are stated for the natural numbers (type Nat).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180010Z" creationid="tlqk35" creationdate="20220321T180010Z">
        <seg>위의 성질들은 자연수 (type Nat)에 대해 기술되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The (unstructured) cases is particularly useful when you can close several
subgoals using the same tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070730Z" creationid="tlqk35" creationdate="20220522T070730Z">
        <seg>(비구조화된)cases는 여러분이 여러 개의 하위목표를 같은 전략을 사용해 끝낼 때 특히 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The try tactic ensures that the sequential composition
succeeds.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151824Z" creationid="tlqk35" creationdate="20220524T151824Z">
        <seg>try 전략은 순차적인 함성 성공을 보장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The ; can be omitted when a line break is used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144853Z" creationid="tlqk35" creationdate="20220321T144853Z">
        <seg>세미콜론;은 줄을 분리할 때 사용되므로 생략될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Lean Theorem Prover aims to bridge the gap between interactive and automated theorem proving, by situating
automated tools and methods in a framework that supports user interaction and the construction of fully specified
axiomatic proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131527Z" creationid="tlqk35" creationdate="20220321T131527Z">
        <seg> Lean 증명 보조기는 사용자의 상호작용과 완전히 구체화된 공리적 증명의 생성을 돕는 자동화된 도구와 방법들을 프레임워크에 둠으로써 상호작용과 자동화된 정리 증명 사이의 빈틈을 메우는 것을 목표로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Lean project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131729Z" creationid="tlqk35" creationdate="20220321T131729Z">
        <seg>Lean 프로젝트는 마이크로소프트 연구소 Redmond의 Leonardo de Moura가 2013년 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The apply tactic applies an expression, viewed as denoting a
function with zero or more arguments.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184622Z" creationid="tlqk35" creationdate="20220321T184622Z">
        <seg>apply 전략은 0 또는 그 이상의 인수가 있는 함수를 나타내는 것으로 간주되는 표현식을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The assumption tactic looks through the assumptions in context of
the current goal, and if there is one matching the conclusion, it
applies it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062935Z" creationid="tlqk35" creationdate="20220522T062815Z">
        <seg>assumption 전략은 현재 목표의 맥락 속 가정을 훝어 봅니다. 
그리고 결론과 대응되는 가정이 있다면 그것을 목표에 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The calc command can be configured for any relation that supports
some form of transitivity.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180640Z" creationid="tlqk35" creationdate="20220321T180640Z">
        <seg>calc 명령은 전달성의 몇몇 형태를 지원하는 어떤 관계에 대해서 설정될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The cases tactic can also be used to
decompose a conjunction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071059Z" creationid="tlqk35" creationdate="20220522T071059Z">
        <seg>cases 전략은 결합자를 분해하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The cases tactic will also do a
case distinction on a natural number:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220523T073754Z" creationid="tlqk35" creationdate="20220523T073754Z">
        <seg>cases 전략은 자연수에 대해 경우를 
나눌 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The cases tactic, and its companion, the induction tactic, are discussed in greater detail in
the Tactics for Inductive Types section.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142143Z" creationid="tlqk35" creationdate="20220524T142143Z">
        <seg>cases 전략 그리고 그것의 동반자인 induction 전략은 
Tactics for Inductive Types  섹션에서 더욱 상세히 논의될 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The contradiction tactic searches for a contradiction among the hypotheses of the current goal:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142215Z" creationid="tlqk35" creationdate="20220524T142215Z">
        <seg>contradiction 전략은 현재 목표의 가정 사이에 모순을 탐색합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The def keyword declares new constant symbols into the
working environment.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135611Z" creationid="tlqk35" creationdate="20220321T135611Z">
        <seg>def는 작업 환경에 새로운 상수기호를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example command states a theorem without naming it or storing
it in the permanent context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162659Z" creationid="tlqk35" creationdate="20220321T162659Z">
        <seg>example 명령은 이름이 없이 영구적인 맥락으로 저장하지 않는 정리를 기술합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first | t₁ | t₂ | ... | tₙ applies each tᵢ until one succeeds, or else fails:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150543Z" creationid="tlqk35" creationdate="20220524T150543Z">
        <seg> first | t₁ | t₂ | ... | tₙ은 각각의  tᵢ에 대해 이 중 하나가 성공하거나 실패할 때까지 적용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The intro command can more generally be used to introduce a variable of any type:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062210Z" creationid="tlqk35" creationdate="20220522T062210Z">
        <seg>intro명령은 폭넓게로는 임의 유형의 변수를 도입하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The intros tactic can be used without any arguments, in which
case, it chooses names and introduces as many variables as it can.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062749Z" creationid="tlqk35" creationdate="20220522T062749Z">
        <seg>intros 전략은 어떠한 인수 없이도 사용될 수 있습니다. 
가령, 그것은 이름을 선택할 수 있고, 원하는 한 많이 많은 변수를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The match expression is part of Lean's function definition system,
which provides convenient and expressive ways of defining complex
functions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182612Z" creationid="tlqk35" creationdate="20220321T182458Z">
        <seg>match 표현식은 복잡한 함수를 정의하는데 편리하고 표현력있는 방식을 제공하는 린의 함수 정의 시스템의 일부분입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The open command admits variations.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180911Z" creationid="tlqk35" creationdate="20220524T180911Z">
        <seg>open 명령은 변형을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The open command brings the shorter names into the current
context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150440Z" creationid="tlqk35" creationdate="20220321T150440Z">
        <seg>open 명령은 현재 맥락에서 짧은 이름을 가져옵니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The or-elimination rule is slightly more complicated.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163700Z" creationid="tlqk35" creationdate="20220321T163700Z">
        <seg>or-제거 규칙은 약간 더 복잡합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The repeat combinator can be used to apply a tactic several times.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063805Z" creationid="tlqk35" creationdate="20220522T063805Z">
        <seg>조합자  repeat는 한 전략을 여러 차례 적용하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rewrite tactic (abbreviated rw) and the simp tactic
were introduced briefly in Calculational Proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T153240Z" creationid="tlqk35" creationdate="20220524T153240Z">
        <seg> (rw로 축약되는)rewrite 전략과 simp전략은 
Calculational Proofs에 간략히 도입되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rewrite tactic is not restricted to propositions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171824Z" creationid="tlqk35" creationdate="20220524T160430Z">
        <seg> rewrite 전략은 명제에만 국한되지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rewrite tactic provides a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T153504Z" creationid="tlqk35" creationdate="20220524T153504Z">
        <seg>동등성에 대해 편리하고 효율적인 방식을 제공하면서 
rewrite 전략은 목표와 가정에 치환을 적용하는 기본적인 작동원리를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rfl tactic is syntax sugar for exact rfl.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063726Z" creationid="tlqk35" creationdate="20220522T063726Z">
        <seg>rfl은 exact rfl에 대한 문법 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The show command does
nothing more than annotate the type, and, internally, all the
presentations of t1 that we have seen produce the same term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161127Z" creationid="tlqk35" creationdate="20220321T161127Z">
        <seg>show 명령은 유형에 주석을 달 뿐이고, 내부적으로 우리가 본 t1의 모든 나타남이 동일한 용어를 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The show tactic can actually be used to rewrite a goal to something definitionally equivalent:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143548Z" creationid="tlqk35" creationdate="20220524T143548Z">
        <seg>show 전략은 실제로 무언가 정의 상으로 동등한 목표를 다시 쓰는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simp tactic, instead, rewrites the goal by applying the given
identities repeatedly, in any order, anywhere they are applicable in a
term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180515Z" creationid="tlqk35" creationdate="20220321T180515Z">
        <seg>대신 simp 전략은 주어진 항등식들을 그들이 항에 적용되는 어느 곳이든 임의의 순서대로 반복적으로 사용하여 목표를 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The sorry identifier magically produces a proof of anything, or
provides an object of any data type at all.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170232Z" creationid="tlqk35" creationdate="20220321T170232Z">
        <seg>sorry 식별자는 어떤 증명이든 마법같이 만듭니다. 혹은 임의의 데이터 유형의 객체를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The variable command instructs Lean to insert the declared
variables as bound variables in definitions that refer to them by
name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145922Z" creationid="tlqk35" creationdate="20220321T145922Z">
        <seg> variable명령은 Lean에게 선언된 변수를 그들을 이름으로 참조하는 정의의 구속 변수로 삽입하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The cases tactic can be used to
decompose any element of an inductively defined type; constructor
always applies the first applicable constructor of an inductively defined type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071936Z" creationid="tlqk35" creationdate="20220522T071828Z">
        <seg>cases 전략은 유도적으로 정의된 유형의 임의의 원소를 분해하는데 사용될 수 있습니다.
constructor는 항상 유도적으로 정의된 유형의 처음으로 활용할 수 있는 생성자에 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The exact
command is just a variant of apply which signals that the
expression given should fill the goal exactly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T054950Z" creationid="tlqk35" creationdate="20220522T054950Z">
        <seg>exact
명령은 목표와 동일한 표현식임을 알리는 apply의 변형일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The match
statement "destructs" the existential assertion into the components
w and hw, which can then be used in the body of the statement
to prove the proposition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182639Z" creationid="tlqk35" creationdate="20220321T182639Z">
        <seg>match 구문은 존재 주장 속 성분인 w와 hw로 '파괴'합니다.  이들은 명제를 증명하기 위해 문장의 몸체에서 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The try combinator builds a
tactic that always succeeds, though possibly in a trivial way:
try t executes t and reports success, even if t fails.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151428Z" creationid="tlqk35" creationdate="20220524T151428Z">
        <seg>대개 명백한 방식일지라도 try 조합자는  항상 성공하는 전략을 만들고, 
t가 실패했음에도 try t는 t를 실행하고 성공을 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The @ symbol
and the difference between the round and curly braces will be
explained momentarily.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152129Z" creationid="tlqk35" creationdate="20220321T152129Z">
        <seg>@ 기호와 소괄호와 중괄호 사이의 차이는 곧 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The local modifier tells the simplifier
to use these rules in the current file (or section or namespace, as
the case may be).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T162147Z" creationid="tlqk35" creationdate="20220524T162147Z">
        <seg>local 수정자는 단순화기에게 현재 파일(아마 경우에 따라 섹션, 이름공간) 
속 이 규칙을 사용하라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simp tactic also recognizes the ←t
syntax that rewrite does.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171718Z" creationid="tlqk35" creationdate="20220524T163201Z">
        <seg>rewrite가 그런 것처럼 simp 전략도 ←t 문법을 인식할 수 있습니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The constructor tactic applies the unique
constructor for conjunction, And.intro.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071324Z" creationid="tlqk35" creationdate="20220522T071324Z">
        <seg>constructor 전략은 결합자 And.intro에 대한 단일 생성자를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The #check command asks Lean to report their
types; in Lean, auxiliary commands that query the system for
information typically begin with the hash (#) symbol.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135833Z" creationid="tlqk35" creationdate="20220321T135833Z">
        <seg>#check 명령은 린에게 그것의 유형을 보고하도록 요청합니다. 린에서 시스템에게 정보를 불러오는 보조 명령은 주로 해시(#) 기호로 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rewrite tactic will be discussed below.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070109Z" creationid="tlqk35" creationdate="20220522T070050Z">
        <seg>rewrite전략은 아래에서 더 논의할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The #eval command asks Lean to evaluate the given expression.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135856Z" creationid="tlqk35" creationdate="20220321T135856Z">
        <seg>#eval 명령은 린에게 제시된 표현의 값을 평가하도록 요청합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The let construct is a stronger means of abbreviation, and there
are expressions of the form let a := t1; t2 that cannot be
expressed as (fun a =&gt; t2) t1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145042Z" creationid="tlqk35" creationdate="20220321T145042Z">
        <seg> let 생성은 약어의 의미로 더 강합니다. 그리고 let a := t1; t2 형태의 표현식은 (fun a =&gt; t2) t1같이 표현될 수 없는 식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Calculus of Constructions therefore identifies dependent arrow
types with forall-expressions in this way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173244Z" creationid="tlqk35" creationdate="20220321T173244Z">
        <seg>그러므로 직관주의 계산법은 의존 화살표 유형을 이처럼 모든-표현식으로 바라봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Existential Quantifier</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180810Z" creationid="tlqk35" creationdate="20220321T180810Z">
        <seg>존재 한정기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The Universal Quantifier</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172601Z" creationid="tlqk35" creationdate="20220321T172601Z">
        <seg>전칭 한정기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The advantage is that we can simply write trans_r hab hbc as a
proof of r a c.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174303Z" creationid="tlqk35" creationdate="20220321T174303Z">
        <seg>이것의 장점은 우리가 간단히 trans_r hab hbc을  r a c의 증명으로 쓸 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The arbitrary fact, q, that follows from falsity is an implicit
argument in False.elim and is inferred automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164448Z" creationid="tlqk35" creationdate="20220321T164448Z">
        <seg>q가 어떤 거짓 명제로부터 나온다는 사실은 False.elim에 대한 암시적 인수이며 자동적으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The attribute can also be applied any time after the theorem is declared:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171556Z" creationid="tlqk35" creationdate="20220524T165001Z">
        <seg>이 특성은 정리가 선언된 이후 언제든지 적용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The classical axioms also give you access to additional patterns of
proof that can be justified by appeal to em.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165913Z" creationid="tlqk35" creationdate="20220321T165852Z">
        <seg>고전적 공리도 여러분에게 em에 호소하여 정당화될 수 있는 추가적인 증명 패턴의 접근을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The combinator focus t ensures that t only effects the current
goal, temporarily hiding the others from the scope.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172118Z" creationid="tlqk35" creationdate="20220524T152951Z">
        <seg>결합자 focus t은 일시적으로 범위로부터 다른 것들을 숨겨 t가 오직 현재 목표에만 영향을 끼침을 보장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The command
namespace foo causes foo to be prepended to the name of each
definition and theorem until end foo is encountered.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180339Z" creationid="tlqk35" creationdate="20220524T175824Z">
        <seg>namespace foo 명령은  end foo와 마추치기 전까지 foo가 각 정의와 정리의 이름에 앞에 붙게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The command
open foo then creates temporary aliases to definitions and
theorems that begin with prefix foo.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180329Z" creationid="tlqk35" creationdate="20220524T180021Z">
        <seg>open foo 명령은 접두사 foo로 시작하는 정의와 정리에 일시적인 별명으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The command open List allows you to use the shorter names:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150528Z" creationid="tlqk35" creationdate="20220321T150528Z">
        <seg>open List 명령은 여러분이 더 짧은 이름을 사용할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The connective False has a single elimination rule,
False.elim, which expresses the fact that anything follows from a
contradiction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164351Z" creationid="tlqk35" creationdate="20220321T164351Z">
        <seg>연결사 False은 하나의 제거 규칙 False.elim을 갖습니다. 이것은 모순으로부터 어떤 것이든 도출된다는 사실을 표현합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definition of double does not have to declare x as an
argument; Lean detects the dependence and inserts it
automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175209Z" creationid="tlqk35" creationdate="20220524T175209Z">
        <seg>double의 정의는 x를 인수로서 정의할 필요가 없습니다.
린은 종속성을 감지하고 그것을 자동적으로 삽입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The definitions and theorems in Lean's standard library are spread
across multiple files.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173657Z" creationid="tlqk35" creationdate="20220524T173657Z">
        <seg>린의 정의와 정리 표준 라이브러리는 다수의 파일에 걸쳐 펴져있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between let and have is that
let introduces a local definition in the context, so that the
definition of the local declaration can be unfolded in the proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144703Z" creationid="tlqk35" creationdate="20220524T144703Z">
        <seg> let과 have 사이의 차이는 let은 맥락 속에 지역 정의를 도입하여 
지역 선언의 정의가 증명속에 접힌채로 될 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference is that
given a : α and h : p a, the term Exists.intro a h has
type (∃ x : α, p x) : Prop and Sigma.mk a h has type
(Σ x : α, p x) : Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181721Z" creationid="tlqk35" creationdate="20220321T181721Z">
        <seg>차이점은 a : α와 h : p a에 대해서 항 Exists.intro a h은 e (∃ x : α, p x) : Prop 형을 가지고 Sigma.mk a h는 (Σ x : α, p x) : Type형을 갖는다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The elimination rule states:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172924Z" creationid="tlqk35" creationdate="20220321T172924Z">
        <seg>제거 규칙은 이와 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above shows
that Nat.add 3 has type Nat → Nat, that is, Nat.add 3 returns a
function that "waits" for a second argument, n, which is then
equivalent to writing Nat.add 3 n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185245Z" creationid="tlqk35" creationdate="20220321T140932Z">
        <seg>위의 예제에서 Nat.add 3는 Nat → Nat유형을 가짐을  보였습니다. 즉 Nat.add 3은 두번째 인자 n을 "기다리는" 함수를 반환하는 것입니다. 이것은 Nat.add 3 n로 쓰는 것과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The existential
elimination rule, Exists.elim, performs the opposite operation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181209Z" creationid="tlqk35" creationdate="20220321T181209Z">
        <seg>존재 한정기호 제거 규칙 Exists.elim은 정반대 연산을 수행합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression
fun x : Nat =&gt; x denotes the identity function on Nat, the
expression fun x : Nat =&gt; true denotes the constant function that
always returns true, and fun x : Nat =&gt; g (f x) denotes the
composition of f and g.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142738Z" creationid="tlqk35" creationdate="20220321T142738Z">
        <seg>표현식 fun x : Nat =&gt; x은 Nat에 대한 항등함수를 의미합니다. 표현식 fun x : Nat =&gt; true은 항상  true을 반환하는 상수함수를 가리합니다. 그리고 fun x : Nat =&gt; g (f x)는 f와 g의 합성함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression And.intro h1 h2 builds a proof of p ∧ q using
proofs h1 : p and h2 : q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162538Z" creationid="tlqk35" creationdate="20220321T162538Z">
        <seg>표현식 And.intro h1 h2은 p ∧ q의 증명을 h1 : p과 h2 : q의 증명을 사용하여 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression And.left h creates a proof of p from a proof
h : p ∧ q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162748Z" creationid="tlqk35" creationdate="20220321T162748Z">
        <seg>표현식 And.left h는 h : p ∧ q의 증명으로부터 p의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression Iff.intro h1 h2 produces a proof of p ↔ q from
h1 : p → q and h2 : q → p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164648Z" creationid="tlqk35" creationdate="20220321T164648Z">
        <seg>표현식 Iff.intro h1 h2은 h1 : p → q과 h2 : q → p으로부터  p ↔ q의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression Or.intro_left q hp creates a proof of p ∨ q
from a proof hp : p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163602Z" creationid="tlqk35" creationdate="20220321T163602Z">
        <seg>표현식 Or.intro_left q hp은 hp : p의 증명으로부터 p ∨ q의 증명을 만듭니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression let a := t1; t2 is
definitionally equal to the result of replacing every occurrence of
a in t2 by t1.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144755Z" creationid="tlqk35" creationdate="20220321T144755Z">
        <seg>표현식 let a := t1; t2 는 t2  속 a의 모든 나타남(occurrence)을 t1으로 대체한 결과에 대해 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression Iff.mp h
produces a proof of p → q from h : p ↔ q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164712Z" creationid="tlqk35" creationdate="20220321T164712Z">
        <seg>표현식 Iff.mp h는 h : p ↔ q으로부터 p → q의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The fact that the rules for implication in a
proof system for natural deduction correspond exactly to the rules
governing abstraction and application for functions is an instance of
the Curry-Howard isomorphism, sometimes known as the
propositions-as-types paradigm.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155714Z" creationid="tlqk35" creationdate="20220321T155714Z">
        <seg>자연 추론을 위한 증명 보조기에서 함의에 대한 규칙이 함수 추상화와 함수 적용을 지배하는 규칙과 정확히 일치한다는 사실은 커리-하워드 동형론(Curry-Howard isomorphism) 의 한 예이며, 때때로 유형으로써 명제(propositions-as-types) 패러다임으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first function returns a type
γ so that is also the return type of the compose function.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144609Z" creationid="tlqk35" creationdate="20220321T144609Z">
        <seg>첫 번째 함수는 유형 γ 를 반환하여 이게 compose 함수의 반환형이 되게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first goal is met with the command exact hp.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T054825Z" creationid="tlqk35" creationdate="20220522T054825Z">
        <seg>첫 번째 목표는 exact hp명령으로 달성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first is to run it from the web: a Javascript version of Lean, a standard
library of definitions and theorems, and an editor are actually downloaded to your browser and run there.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131828Z" creationid="tlqk35" creationdate="20220321T131828Z">
        <seg>첫째는 웹으로부터 이것을 실행하는 것입니다.(Lean의 자바스크립트 버전, 정의와 정리들의 표준 라이브러리, 편집자는 실제로 여러분의 브라우저에 다운로드를 시키고 거기서 실행하는 것임)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first step, rw [Nat.add_zero] at h, rewrites the hypothesis a + 0 = 0 to a = 0.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171833Z" creationid="tlqk35" creationdate="20220524T160308Z">
        <seg>첫 단계는 rw [Nat.add_zero] at h는 가정 a + 0 = 0을 a = 0으로 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first tactic in the by block below repeatedly splits
conjunctions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T152742Z" creationid="tlqk35" creationdate="20220524T152742Z">
        <seg> by 블럭 아래에 첫 번째 전략은 반복적으로 결합자를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first version of this book was
written for Lean 2, and the Lean 3 version is is available
here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171622Z" creationid="tlqk35" creationdate="20220321T171622Z">
        <seg>이 책의 첫 번째 버전은 Lean 2을 위해 쓰였습니다. Lean 3 버전도 여기서 이용 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following calls a given function twice passing the output of the
first invocation to the second:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144414Z" creationid="tlqk35" creationdate="20220321T144414Z">
        <seg>다음은 주어진 함수를 첫번째 호출의 출력을 두번째에 전달하는 것으로 두 번 호출합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following definition</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180122Z" creationid="tlqk35" creationdate="20220524T180033Z">
        <seg>다음 정의  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example defines the prefix relation on lists,
proves that this relation is reflexive, and assigns the [simp] attribute to that theorem.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T183037Z" creationid="tlqk3" creationdate="20220525T182849Z">
        <seg>다음 예제에서는 리스트에 대한 접두사 관계를 정의하고, 이 관계는 반사적임을 증명하고, 그 정리에 [simp] 특성을 부여합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following example uses the intros command to introduce the three variables and two hypotheses automatically:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063054Z" creationid="tlqk35" creationdate="20220522T063054Z">
        <seg>다음 예제는 intros 명령을 사용해 세 개의 변수와 두 개의 가정을 자동으로 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following is a more natural example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143211Z" creationid="tlqk35" creationdate="20220524T143211Z">
        <seg>다음은 더 자연스러운 예제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following is a shorter version of the preceding
proof:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060622Z" creationid="tlqk35" creationdate="20220522T060622Z">
        <seg>다음은 이전의 증명보다 더 짧은 버전의 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following is a somewhat toy example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143156Z" creationid="tlqk35" creationdate="20220524T143156Z">
        <seg>다음은 약간 간단한 예제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following is a structured
version of our first tactic proof in this chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061249Z" creationid="tlqk35" creationdate="20220522T061249Z">
        <seg>다음은 이 장의 첫번째 우리의 전략 증명의 구조화된 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following list includes a number of common identities.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170122Z" creationid="tlqk35" creationdate="20220321T170122Z">
        <seg>다음 리스트는 흔히 사용되는 항등식들을 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following yields the same result:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144033Z" creationid="tlqk35" creationdate="20220321T144033Z">
        <seg>다음은 같은 결과를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The full list of axioms that are used in Lean to support classical
reasoning are discussed in Axioms and Computations.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170049Z" creationid="tlqk35" creationdate="20220321T170049Z">
        <seg>고전 추론을 지원하기 위해 린에서 사용된 모든 공리의 리스트는 공리와 계산에서 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function Prod is
similarly polymorphic:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142043Z" creationid="tlqk35" creationdate="20220321T142043Z">
        <seg>마찬가지로 Prod 함수는 다형적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions f and g above denote the same function.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152345Z" creationid="tlqk35" creationdate="20220321T152345Z">
        <seg>위 함수  f와 g는 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The general form of a definition is def foo : α := bar where
α is the type returned from the expression bar.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144127Z" creationid="tlqk35" creationdate="20220321T144127Z">
        <seg>정의의 일반적인 형태는  def foo : α := bar입니다. 여기서  α 는 식 bar로부터 반환되는 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The general form of a lambda expression is fun x : α =&gt; t, where
the variable x is a "bound variable": it is really a placeholder,
whose "scope" does not extend beyond the expression t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143328Z" creationid="tlqk35" creationdate="20220321T143328Z">
        <seg>람다 표현식의 일반적인 형태는 fun x : α =&gt; t입니다. 여기서 변수 x는 "구속변수"입니다. 이는 그것의 "범위"가 표현식  t 안으로 제한되는 '자리차지자'일 뿐 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify
claims in both domains.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131543Z" creationid="tlqk35" creationdate="20220321T131543Z">
        <seg>목표는 수학적 추론과 복잡한 시스템에 대한 추론을 모두 지원하고 양쪽 영역의 주장을 식별하게 만드는 겁이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The goal of Lean's front end is to interpret user input, construct
formal expressions, and check that they are well formed and type
correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173445Z" creationid="tlqk35" creationdate="20220524T173445Z">
        <seg>린의 프론트 엔드의 목표는 사용자의 입력을 해석하고 형식적인 표현을 만들고 그들이 잘 형성되었고 옳바른 유형인지 확인하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic
show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of
foundational systems.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131234Z" creationid="tlqk35" creationdate="20220321T131234Z">
        <seg>수학 진술을 지지하기 위한 황금률은 증명을 제공하는 것이며 20세기 논리학의 발전은 기존은 몇 가지의 공리의 모임과 기초계의 몇 가지 규칙으로 축소될 수 있음을 거의 보여주었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The idea is
that we can prove r from p ∨ q, by showing that r follows
from p and that r follows from q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163752Z" creationid="tlqk35" creationdate="20220321T163752Z">
        <seg>r이 p로부터 나오고 r이 q로부터 나온다는 것을 보임으로써 우리가 p ∨ q로부터 r을 증명할 수 있다는 생각입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The idea is as follows.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174605Z" creationid="tlqk35" creationdate="20220321T174605Z">
        <seg>아이디어는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The impredicativity of Prop means that we
can form propositions that quantify over α → Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175235Z" creationid="tlqk35" creationdate="20220321T175235Z">
        <seg>Prop의 비서술어는 우리가 α → Prop를 한정하는 명제를 세울 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The inscription .{u} tells Lean to instantiate the constants at the universe u.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175555Z" creationid="tlqk35" creationdate="20220321T175555Z">
        <seg>접두사 .{u}은 린에게 세계변수 u로 상수를 개체화하라고 말해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The introduction and elimination rules we have seen so far are all
constructive, which is to say, they reflect a computational
understanding of the logical connectives based on the
propositions-as-types correspondence.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165648Z" creationid="tlqk35" creationdate="20220321T165648Z">
        <seg>지금까지 우리가 본 도입과 제거 규칙은 모두 직관적입니다. 그 말은 그들은 유형으로써 명제 대응에 기반한 논리 연결사의 계산적인 이해를 반영하고 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The introduction rule is
straightforward: to prove ∃ x : α, p x, it suffices to provide a
suitable term t and a proof of p t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180911Z" creationid="tlqk35" creationdate="20220321T180911Z">
        <seg>도입 규칙은 직관적입니다. ∃ x : α, p x을 증명하기 위해 적절한 항 t와 p t의 증명을 제공하는 것으로 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The judicious use of Unicode improves
legibility, and all modern editors have great support for it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140114Z" creationid="tlqk35" creationdate="20220321T140114Z">
        <seg>분별있는 유니코드의 사용은 가독성을 개선합니다. 그리고 현대의 모든 편집기는 그것의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last chapter introduced you to methods that construct proofs of
statements involving the propositional connectives.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172547Z" creationid="tlqk35" creationdate="20220321T172547Z">
        <seg>지난 장에서 여러분에게 명제적 연결사를 포함한 문장의 증명을 구성하는 방법을 소개했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last expression, for example, denotes the function that takes
three types, α, β, and γ, and two functions, g : β → γ
and f : α → β, and returns the composition of g and f.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143241Z" creationid="tlqk35" creationdate="20220321T143241Z">
        <seg>마지막 표현식은 세 유형 α, β, γ과 두 함수 g : β → γ과 f : α → β을 받고 g과 f의 합성을 반환하는 함수를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The letter "f" is for "French," since the unicode
symbols can also be used as French quotation marks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183508Z" creationid="tlqk35" creationdate="20220321T183508Z">
        <seg>"f"는 "프랑스"의 첫머리 글자입니다. 왜냐하면 이 유니코드 기호는 프랑스 인용부호로도 사용되기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The list is indefinite, so
that there is a Type n for every natural number n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141719Z" creationid="tlqk35" creationdate="20220321T141719Z">
        <seg>모든 자연수 n에 대해 Type n가 있어서 이런 리스트를 무한히 나열할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The macro h ▸ e uses more effective heuristics for computing
this implicit parameter, and often succeeds in situations where
applying Eq.subst fails.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180148Z" creationid="tlqk35" creationdate="20220321T180148Z">
        <seg>매크로 h ▸ e은 이 암시적 인자를 계산하는데 더욱 효과적인 경험론을 사용합니다. 그리고 종종 Eq.subst의 적용이 실패하는 상황에서 성공적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main function of Lean is to translate user input to formal
expressions that are checked by the kernel for correctness and then
stored in the environment for later use.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181833Z" creationid="tlqk3" creationdate="20220525T181833Z">
        <seg>린의 주요 기능은 사용자의 입력을 커널에 의해 올바름이 검증된 형식 표현식으로 번역하는 것과 나중에 사용할 수 있도록 환경에 저장해두는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The mnemonic in the notation above is that you are generalizing the
goal by setting 3 to an arbitrary variable x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065006Z" creationid="tlqk35" creationdate="20220522T065006Z">
        <seg>위의 표기에 대한 기억법은 여러분이 3으로 설정한 목표을 임의의 변수 x로 일반화시키는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The most basic form of the
tactic is rewrite [t], where t is a term whose type asserts an
equality.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T153620Z" creationid="tlqk35" creationdate="20220524T153620Z">
        <seg>전략의 가장 기본적인 형태는 rewrite [t]입니다. 
여기서 t는 동등석을 주장하는 유형의 항입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The motivation is to
ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063300Z" creationid="tlqk35" creationdate="20220522T063247Z">
        <seg>그 이유는 여러분의 전략 증명이 자동으로 생성된 이름에 의존하지 않도록 보장하기 위함입니다. 그리고 그 결과로 증명은 더 튼튼하게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name double is defined as a
function that takes an input parameter x of type Nat, where the
result of the call is x + x, so it is returning type Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143946Z" creationid="tlqk35" creationdate="20220321T143946Z">
        <seg>이름 double은 Nat 유형의 입력 매개변수 x를 받고  호출의 결과로 x + x인 함수로 정의되었습니다. 그래서 Nat 유형을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The native version is much faster than
the web version, and is more flexible in other ways, too.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131909Z" creationid="tlqk35" creationdate="20220321T131909Z">
        <seg>원본 버전은 웹 버전보다 더 빠르고 다른 방식보다 유연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The new subgoals can be solved in any order.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070437Z" creationid="tlqk35" creationdate="20220522T070437Z">
        <seg>새로운 하위 목표는 임의의 순서로 풀릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next
section offers syntax that allow you to write calculational proofs in
a more natural and perspicuous way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180201Z" creationid="tlqk35" creationdate="20220321T180201Z">
        <seg>다음 섹션은 여러분이 계산 증명을 더 자연스럽고 안목이 있는 방향으로 작성하게 하는 문법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example simplifies all the hypotheses, and then uses them to prove the goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171642Z" creationid="tlqk35" creationdate="20220524T164111Z">
        <seg>다음 예제는 모든 가정을 단순화하고 그 후 이들로 목표를 증명하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example simply permutes the last two lines in
the previous proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165230Z" creationid="tlqk35" creationdate="20220321T165230Z">
        <seg>다음 예제는 이전 증명에서 마지막 두 줄을 단순히 바꾼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next example uses both these rules to produce a
proof of (p → q) → ¬q → ¬p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164305Z" creationid="tlqk35" creationdate="20220321T164305Z">
        <seg>다음 예제는 (p → q) → ¬q → ¬p의 증명을 만들기 위해 세 가지 규칙 모두를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The next two examples instead apply associativity to
move the parenthesis to the right on both sides, and then switch b
and c.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171936Z" creationid="tlqk35" creationdate="20220524T155903Z">
        <seg>다음 두 예제는 결합성을 적용하는 대신 괄호를 오른쪽으로 옮깁니다. 그리고 b와 c를 교환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The notation
rw [t] at h applies the rewrite t at hypothesis h.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171837Z" creationid="tlqk35" creationdate="20220524T160214Z">
        <seg>rw [t] at h 표기는 가정 h에 t에 다시쓰기를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The notation @[simp] declares reverse_mk_symm to have the
[simp] attribute, and can be spelled out more explicitly:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171549Z" creationid="tlqk35" creationdate="20220524T164926Z">
        <seg> @[simp]표기는 reverse_mk_symm가 [simp] 
특성을 갖고 더 명시적으로 쓸 수 있도록 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The notation . is whitespace sensitive and relies on the indentation
to detect whether the tactic block ends.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145116Z" creationid="tlqk35" creationdate="20220524T145116Z">
        <seg>. 표기는 화이트 스페이스(space key)에 민감하고 전략 블럭의 끝인지 감지하기 위해 인덴트(4개의 빈칸, tab key)에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The notation ←t can be used to instruct the
tactic to use the equality t in the reverse direction.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172026Z" creationid="tlqk35" creationdate="20220524T154937Z">
        <seg>←t 기호는 역방향으로 등식 t을 사용하도록 전략에게 지시하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The one thing you are missing is a mechanism
for defining new data types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172828Z" creationid="tlqk35" creationdate="20220524T172828Z">
        <seg>한 가지 여러분이 놓친 작동원리는 새로운 데이터 형을 정의하는 것에 대한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The order of operations is as follows: unary negation ¬ binds most
strongly, then ∧, then ∨, then →, and finally ↔.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162225Z" creationid="tlqk35" creationdate="20220321T162225Z">
        <seg>연산자의 우선순위는 다음과 같습니다. 일항 부정 ¬ 은 가장 강하게 결합하고 그 다음은 ∧ 그 다음 ∨ 그 다음 → 그리고 마지막으로 ↔입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The other propositional connectives are
defined in Lean's library in the file Prelude.core (see
importing files for more information on the library
hierarchy), and each connective comes with its canonical introduction
and elimination rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162457Z" creationid="tlqk35" creationdate="20220321T162457Z">
        <seg>다른 명제논리적 연결사들은  린의 라이브러리의 Prelude.core 파일 속에 정의되 있습니다. (라이브러리 계층에 대한 더 많은 정보를 위해 파일 불러오기를 보세요.) 그리고 각 연결사들마다 그것의 정식 도입, 제거 규칙이 딸려 나옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The output of the
#check command means that whenever α has type Type n,
List α also has type Type n.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142028Z" creationid="tlqk35" creationdate="20220321T142028Z">
        <seg>#check 명령의 출력은 α가 Type n유형을 갖는 한 List α도 Type n 유형을 가짐을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The output of the first #check
command is r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3, indicating
that the implicit arguments are unspecified in this case.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174351Z" creationid="tlqk35" creationdate="20220321T174351Z">
        <seg>처음 #check 명령의 출력은 r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3입니다. 이들은 여기에서 명시되지 않은 암시적 인자들을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter list can be separated like this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144304Z" creationid="tlqk35" creationdate="20220321T144304Z">
        <seg>매개변수 리스트는 이와 같이 나눠 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parentheses
around h hq are not necessary, but we have added them for clarity.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T154419Z" creationid="tlqk35" creationdate="20220524T154419Z">
        <seg>h hq 주위의 괄호는 필요하지 않습니다만 우리는 명황성을 이해 이들을 추가했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153430Z" creationid="tlqk35" creationdate="20220321T153430Z">
        <seg>암시적 인수의 존재는 현재로는 식의 정확한 의미를 고치기에 정보가 불충분함을 의미할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The previous
examples can therefore be written concisely as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164850Z" creationid="tlqk35" creationdate="20220321T164850Z">
        <seg>그러므로 이전 예제는 다음과 같이 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The previous example can be written as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172036Z" creationid="tlqk35" creationdate="20220524T154605Z">
        <seg>다음 예제는 다음과 같이 쓰일 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The problem goes away if we use weak implicit arguments:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T190406Z" creationid="tlqk3" creationdate="20220525T190406Z">
        <seg>문제는 우리가 약한 암시적인 인수를 사용하면 사라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process of instantiating these
"holes," or "placeholders," in a term is often known as
elaboration.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153423Z" creationid="tlqk35" creationdate="20220321T153423Z">
        <seg>이런 "구멍" 또는 "플레이스 홀더"의 인스턴스화 과정은 협력(elaboration)으로 불리기도 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The propositional connectives come with the following notation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161840Z" creationid="tlqk35" creationdate="20220321T161840Z">
        <seg>명제 연결사는 다음 기호로 따라온다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The results are broken down into small steps: th1 shows that a
relation that is reflexive and euclidean is symmetric, and th2
shows that a relation that is symmetric and euclidean is
transitive.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185920Z" creationid="tlqk3" creationdate="20220525T185920Z">
        <seg>결과는 작은 단계들로 나눠집니다. th1은 반사적이고 유클리디안은 대칭적이다는 관계를 증명하고 th2은 대칭적이고 유클리디언은 추이적이다는 관계를 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The right hand side bar can be any expression, not just a lambda.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144213Z" creationid="tlqk35" creationdate="20220321T144213Z">
        <seg>우변 bar는 lambda뿐만 아니라 어떤 식이든 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The rule Eq.subst is used to define the following auxiliary rules,
which carry out more explicit substitutions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175832Z" creationid="tlqk35" creationdate="20220321T175832Z">
        <seg>Eq.subst의 규칙은 더 명백한 대체를 수행하는 다음의 부가적인 규칙을 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second way to use Lean is to install and run it natively on your computer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131857Z" creationid="tlqk35" creationdate="20220321T131857Z">
        <seg>Lean을 사용하는 두 번째 방법은 여러분의 컴퓨터에 설치하여 로컬로 실행하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The short explanation is that types can depend on parameters.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150811Z" creationid="tlqk35" creationdate="20220321T150811Z">
        <seg>간단한 설명은 유형이 매개변수에 의존할 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The similarity between ∃ and Σ is another
instance of the Curry-Howard isomorphism.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181755Z" creationid="tlqk35" creationdate="20220321T181755Z">
        <seg>∃과Σ의 유사점은 이들이 커리-하워드 동형의 또 다른 개체라는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The similarity between ∧ and × is another instance
of the Curry-Howard isomorphism, but in contrast to implication and
the function space constructor, ∧ and × are treated separately
in Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163016Z" creationid="tlqk35" creationdate="20220321T163016Z">
        <seg>∧과 ×의 유사성은 커리-하워드 동형론의 또다른 예입니다. 그러나 함의와 함수 공간 생성자와는 대조적으로  ∧과 ×은 린에서 별개로 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simplifier then proves isPrefix [1, 2, 3] [1, 2, 3] by rewriting it to True.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T182954Z" creationid="tlqk3" creationdate="20220525T182954Z">
        <seg>그럼 단순화기는 isPrefix [1, 2, 3] [1, 2, 3]을 그것이 True라고 다시쓰기하여 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The simplifier will also do propositional rewriting.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T163741Z" creationid="tlqk35" creationdate="20220524T163741Z">
        <seg>단순화기도 명제 다시쓰기를 할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The source
code, and instructions for building Lean, are available at
https://github.com/leanprover/lean4/.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131946Z" creationid="tlqk35" creationdate="20220321T131946Z">
        <seg>Lean을 만든 소스코드와  명령어들은 https://github.com/leanprover/lean4/에서 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The style of writing proofs is most effective when it is used in
conjunction with the simp and rewrite tactics, which are
discussed in greater detail in the next chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180349Z" creationid="tlqk35" creationdate="20220321T180349Z">
        <seg>증명 작성 스타일은 simp와 rewrite 전략을 결합해 사용되었을 때 가장 효과적입니다. 이것들은 다음 장에서 상세히 논할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The tactic automatically closes any goal of the form
t = t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172057Z" creationid="tlqk35" creationdate="20220524T154238Z">
        <seg>전략은 자동적으로 t = t꼴의 임의의 목표를 자동적으로 마무리짓습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171012Z" creationid="tlqk35" creationdate="20220524T171012Z">
        <seg>The tactic interpreter
-- `triv`에 대한 가능한 모든 매크로 확장을 어떤 것이 macro_rules을 성공할 때까지 시도합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The tactic tries to solve the left disjunct immediately by assumption;
if that fails, it tries to focus on the right disjunct; and if that
doesn't work, it invokes the assumption tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150955Z" creationid="tlqk35" creationdate="20220524T150955Z">
        <seg>전략은 왼쪽의 분리자를 가정으로부터 즉시 풀려고 합니다.
만약 실패하면 이것은 오른쪽 분리자에 초점을 맞춰 시도합니다. 그리고 
이게 성공하지 못하면, 가정 전략을 불러옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The term "predicative" stems from foundational developments around the
turn of the twentieth century, when logicians such as Poincaré and
Russell blamed set-theoretic paradoxes on the "vicious circles" that
arise when we define a property by quantifying over a collection that
includes the very property being defined.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175119Z" creationid="tlqk35" creationdate="20220321T175119Z">
        <seg>"술어"라는 말은 20세기로 접어드는 시기에 기초수학의 발전으로부터 유래되었습니다.  이때 푸엥카레와 레셀 같은 논리학자들은 정의되는 바로 그 정의되는 성질을 포함하는 모임에 대해 한정함으로써 성질을 정의할 때 발생하는 집합론적 역설 "악순환(vicious circles)"을 비난했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The term rewriter and simplifier are described
briefly in the next section, and then in greater detail in the next
chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180218Z" creationid="tlqk35" creationdate="20220321T180218Z">
        <seg>항 다시쓰기와 단순화는 다음 섹션에서 간단히 설명합니다. 그러고 나서 다음 장에서 아주 상세하게 다룹니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The triangle in the second presentation is a macro built on top of
Eq.subst and Eq.symm, and you can enter it by typing \t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175821Z" creationid="tlqk35" creationdate="20220321T175821Z">
        <seg>두번째 보기에서 삼각형은 Eq.subst과 Eq.symm 위에 세워진 매크로입니다. 여러분은 이것은 \t을 쳐서 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The two ways we have suggested thinking about the
propositions-as-types paradigm differ in a fundamental way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160323Z" creationid="tlqk35" creationdate="20220321T160323Z">
        <seg>우리가 제안한 유형별 명제 패러다임에 대해 생각하는 두 가지 방법은 근본적인 면에서 다릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type algebra β → γ and α → β means it is a requirement
that the type of the output of the second function must match the
type of the input to the first function - which makes sense, otherwise
the two functions would not be composable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144512Z" creationid="tlqk35" creationdate="20220321T144512Z">
        <seg> β → γ 와 α → β의 유형 대수는 두 번째 함수의 출력 유형이 첫 번째 함수의 입력 유형과 반드시 일치해야 한다는 요구를 같습니다. 이렇지 않다면 두 함수는 합성될 수 없을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of t1 is now ∀ {p q : Prop}, p → q → p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161439Z" creationid="tlqk35" creationdate="20220321T161439Z">
        <seg>t1의 유형은 이제 ∀ {p q : Prop}, p → q → p입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The types in a have tactic can be omitted, so you can write have
hp := h.left and have hqr := h.right.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143959Z" creationid="tlqk35" creationdate="20220524T143959Z">
        <seg>have 전략에서 유형은 생략될 수 있습니다. 그래서 여러분은  have
hp := h.left과 have hqr := h.right을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unicode symbol × for the Cartesian product
is entered as \times.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140531Z" creationid="tlqk35" creationdate="20220321T140531Z">
        <seg>카테시안 곱을 나타내는 유니코드 기호 ×는 \times을 입력하여 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The universal quantifier, ∀ x : α, p x is supposed to denote the
assertion that "for every x : α, p x" holds.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172839Z" creationid="tlqk35" creationdate="20220321T172839Z">
        <seg>전칭 한정기호 ∀ x : α, p x 은 "모든 x : α에 대해  p x"가 성립한다는 주장을 가리켜야 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then
(x : α) → β is an element of Sort (imax i j), where imax i j is the
maximum of i and j if j is not 0, and 0 otherwise.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174559Z" creationid="tlqk35" creationdate="20220321T174559Z">
        <seg>그러면 (x : α) → β은 Sort (imax i j)의 원소입니다. 여기서 imax i j는 i와 j사이의 최대값이고, j가 0이 아니고, 이외에는 0입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then th3 combines the two results.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185956Z" creationid="tlqk3" creationdate="20220525T185956Z">
        <seg>그런 뒤 th3는 이 두 결과를 결합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then for any list xs, reverse (mk_symm xs) is equal to mk_symm xs,
which can easily be proved by unfolding the definition:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171628Z" creationid="tlqk35" creationdate="20220524T164500Z">
        <seg>그럼 임의의 리스트  xs에 대해 reverse (mk_symm xs)은 mk_symm xs과 같습니다. 
그리고 이는 정의를 펼쳐보는 것으로 쉽게 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then go back and replace each sorry with an actual proof,
until no more remain.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170401Z" creationid="tlqk35" creationdate="20220321T170401Z">
        <seg>그리고 다시 뒤로 돌아가 각각의 sorry가 더 남지 않을 때까지 실제 증명으로 바꾸세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then next applies commutativity to the term
b + c; without specifying the argument, the tactic would instead rewrite
a + (b + c) to (b + c) + a.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171948Z" creationid="tlqk35" creationdate="20220524T155631Z">
        <seg>그 뒤 항 b + c에 교환성을 적용합니다 .
인수의 명시 없이 전략은 a + (b + c)에서 (b + c) + a으로 다시 쓸 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then the new hypothesis a = 0 is used to rewrite the goal to f 0 = f 0.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171829Z" creationid="tlqk35" creationdate="20220524T160355Z">
        <seg>그 뒤 새로운 가정 a = 0 가 목표를 f 0 = f 0으로 다시 쓰도록 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then use e.g. mdbook watch in the root folder:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172040Z" creationid="tlqk35" creationdate="20220321T172040Z">
        <seg>루트 폴더에서 mdbook watch을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then we can "cancel" the hypothesis and obtain a proof of Implies p q.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155131Z" creationid="tlqk35" creationdate="20220321T155131Z">
        <seg>그러면 우리는 가정을 "상쇄"하여 Implies p q의 증명을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, the second one replaces f 0
with 0.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172103Z" creationid="tlqk35" creationdate="20220524T154206Z">
        <seg>그런 뒤 두 번째 것은 f 0을 0으로 대체합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, we use the command macro_rules to specify what should
be done when triv is used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170602Z" creationid="tlqk35" creationdate="20220524T170602Z">
        <seg>그러면 우리는  triv가 사용될 때 macro_rules 명령이 
무엇을 해야 하는지 명시하도록 사용할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, when we write the expression f 7 without further
arguments, it is parsed as f 7 _.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185104Z" creationid="tlqk3" creationdate="20220525T185104Z">
        <seg>그럼, 우리가 표현식 f 7을 추가 인수없이 슬때, 이는 f 7 _와 같이 구문 분석 될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, you can construct lists of Nat as follows.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185331Z" creationid="tlqk35" creationdate="20220321T152432Z">
        <seg>그럼 여러분은  Nat의 리스트를 다음과 같이 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171646Z" creationid="tlqk35" creationdate="20220321T170911Z">
        <seg>린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are a few more things to notice here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140641Z" creationid="tlqk35" creationdate="20220321T140641Z">
        <seg>여기서 몇 개 더 짚고가야 할 것이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are a few pragmatic differences between definitions and
theorems, however.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160855Z" creationid="tlqk35" creationdate="20220321T160855Z">
        <seg>하지만 정의와 정리 사이에 약간의 실용적 차이는 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are at least two ways of thinking about propositions as
types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155833Z" creationid="tlqk35" creationdate="20220321T155833Z">
        <seg>유형으로써 명제에 대해 생각할 수 있는 최소한 두 가지 방법이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are currently two ways to use Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131811Z" creationid="tlqk35" creationdate="20220321T131811Z">
        <seg>현재 Lean을 사용하는 두 가지 방식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two additional modifiers that are useful.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171530Z" creationid="tlqk35" creationdate="20220524T170029Z">
        <seg>이외 유용한 두 수정자들이 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There is a fine line between brevity and obfuscation, and omitting
information in this way can sometimes make a proof harder to read.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163506Z" creationid="tlqk35" creationdate="20220321T163506Z">
        <seg>간결함과 가독성 사이에 미세찬 차이가 있고 이런 식으로 정보를 생략하는 것은 때때로 증명을 읽기 더 어렵게 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There is a third kind of implicit argument that is denoted with square
brackets, [ and ].</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T190539Z" creationid="tlqk3" creationdate="20220525T190539Z">
        <seg>대괄호 [과 ]로 표시된 세 번째 종류의 암시적인 매개변수가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There is also a have tactic, which introduces a new subgoal, just as when writing proof terms:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T143650Z" creationid="tlqk35" creationdate="20220524T143650Z">
        <seg>증명항을 작성할 때처럼 have 전략은 새로운 하위목표를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There is only one
anonymous namespace at the root level.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150427Z" creationid="tlqk35" creationdate="20220321T150427Z">
        <seg>root 계층에서만 익명 이름 공간이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These
aspects of Lean are explored in a companion tutorial to this one, Programming in Lean 4, though computational
aspects of the system will make an appearance here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131657Z" creationid="tlqk35" creationdate="20220321T131657Z">
        <seg>Lean의 이러한 측면은 이 교재의 동반 교재인 Programming in Lean에서 더 찾아볼 수 있다. 그렇지만 여기에서도 린의 계산적인 측면을 찾아봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These
types vary depending on the first argument, α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151505Z" creationid="tlqk35" creationdate="20220321T151500Z">
        <seg>이 유형은 첫번째 인수 α에 따라 달라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These angle brackets are obtained by typing \&lt; and \&gt;, respectively.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163322Z" creationid="tlqk35" creationdate="20220321T163322Z">
        <seg>이 꺽긴 괄호는 \&lt;과 \&gt;을 각각 치는 것으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are the left and
right or-introduction rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163645Z" creationid="tlqk35" creationdate="20220321T163645Z">
        <seg>이들은 왼쪽과 오른쪽 or-도입 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These are used for type classes, as
explained in Chapter Type Classes.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T190606Z" creationid="tlqk3" creationdate="20220525T190606Z">
        <seg>Chapter Type Classes에서 설명할 이들은 유형 클래스에 대해서 사용되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These can include ordinary mathematical theorems, as well as claims that pieces of hardware
or software, network protocols, and mechanical and hybrid systems meet their specifications.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131146Z" creationid="tlqk35" creationdate="20220321T131146Z">
        <seg>이 주장들은 평범한 수학적 정리뿐만 아니라 하드웨어와 소프트웨어, 네트워크 프로토콜, 역학적 복합적 시스템이 그들의 명세를 만족하는지에 대한 주장도 포함될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These require classical reasoning.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170708Z" creationid="tlqk35" creationdate="20220321T170708Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These require classical reasoning:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170211Z" creationid="tlqk35" creationdate="20220321T170211Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These tactics can be used on data just as well as propositions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T072519Z" creationid="tlqk35" creationdate="20220522T072519Z">
        <seg>이 전략들은 명제와 마찬가지로 데이터에 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They
are commonly known as the right and left and-elimination rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162823Z" creationid="tlqk35" creationdate="20220321T162823Z">
        <seg>이들은 흔히 오른쪽과 왼쪽 and-제거 규칙으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They all take values in Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162148Z" creationid="tlqk35" creationdate="20220321T162148Z">
        <seg>이들은 Prop형의 모든 값을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They are considered "the same" by Lean's type
checker, and Lean does its best to recognize and support these
identifications.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143738Z" creationid="tlqk35" creationdate="20220321T143738Z">
        <seg>이런 것은 린의 유형 검사기가 "같은"것으로 봅니다. 그리고 린은 유형을 인식하고 대조하는데 최선을 다합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They are designed to deal
with applicative terms, that is, terms of form s t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175843Z" creationid="tlqk35" creationdate="20220321T175843Z">
        <seg>이들은 응용 항을 다루기 위해 설계되었습니다. 즉,  s t 꼴의 항입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can also
include subscripts, which can be entered by typing \_ followed by
the desired subscripted character.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T191212Z" creationid="tlqk3" creationdate="20220525T191212Z">
        <seg>이들은 아래첨자를 넣고자 하는 문자 다음에  \_을 쳐 넣음으로써 아래첨자도 포함할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They naturally support an incremental style of writing proofs,
in which you decompose a proof and work on goals one step at a time.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184311Z" creationid="tlqk35" creationdate="20220321T184311Z">
        <seg>그들은 증명을 분해하고 한 번에 한 단계씩 목표를 달성하는 점진적인 스타일의 증명을 자연스럽게 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think about what is going on here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174007Z" creationid="tlqk35" creationdate="20220321T174007Z">
        <seg>무슨 일이 생긴 건지 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think about what these expressions mean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142638Z" creationid="tlqk35" creationdate="20220321T142638Z">
        <seg>이 표현식의 의미에 대해 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of Type 0 as a universe of "small" or "ordinary" types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141626Z" creationid="tlqk35" creationdate="20220321T141626Z">
        <seg>Type 0는 "작은" 또는 "평범한" 유형들의 세계라고 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of this as the function from α to β which maps
any value x to the value t.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142516Z" creationid="tlqk35" creationdate="20220321T142516Z">
        <seg>이를  임의의 값 x에서 값 t로 대응시키는 α에서 β까지의 함수로 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This
is not a trivial affair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181031Z" creationid="tlqk35" creationdate="20220321T181031Z">
        <seg>이것은 명백한 문제가 아닙니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This
pattern, deriving an arbitrary fact from contradictory hypotheses, is
quite common, and is represented by absurd.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164500Z" creationid="tlqk35" creationdate="20220321T164500Z">
        <seg>모순적인 가정들로부터 어떤 사실을 얻는 이런 패턴은 꽤 흔하고 absurd로 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This annotation can also be
written using as ⦃y : Nat⦄, where the unicode brackets are entered
as \{{ and \}}, respectively.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185427Z" creationid="tlqk3" creationdate="20220525T185427Z">
        <seg>이런 주석은 ⦃y : Nat⦄으로서 사용해 쓸 수도 있습니다. 여기서 유니코드 괄호는 각각 \{{과 \}}으로 쳐서 입력될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach is more robust than using by assumption, because the
type of the assumption that needs to be inferred is given
explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183641Z" creationid="tlqk35" creationdate="20220321T183641Z">
        <seg>추론될 필요가 있는 가정의 유형은 명백하게 주어져야 하므로 이런 접근법은 by assumption을 사용하는 것보다 더 견고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This approach would provide us with a reasonable way of building assertions and proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155149Z" creationid="tlqk35" creationdate="20220321T155149Z">
        <seg>이런 접근은 주장과 증명을 만드는 합리적인 방법을 우리에게 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This book is designed to teach you to develop and verify proofs in Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132009Z" creationid="tlqk35" creationdate="20220321T132009Z">
        <seg>이 책은 Lean에서 증명을 검증하고 세울 수 있도록 당신을 가르치게끔 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This can be helpful in
indicating the separate proofs of multiple subgoals introduced by a
tactic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144940Z" creationid="tlqk35" creationdate="20220524T144940Z">
        <seg>이는 전략에 의해 생긴 다수의 하위 목표를의 증명을 나누는 것을 지칭하는데 유용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have a matching
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144154Z" creationid="tlqk35" creationdate="20220321T144154Z">
        <seg>이것은 당신의 의도를 명확히 만들고 Lean은 정의의 우변에 일치하는 유형이 아닌 경우 에러를 표시할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This definition of ident here has the same effect as the one
above.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153405Z" creationid="tlqk35" creationdate="20220321T153405Z">
        <seg>ident의 이 정의는 여기서 위의 것과 같이 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This explains the
type annotation of the function List:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141932Z" creationid="tlqk35" creationdate="20220321T141932Z">
        <seg>이는 List함수의 유형 표기를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This feature of the framework is so important that the library defines a notation rfl for Eq.refl _:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T185425Z" creationid="tlqk35" creationdate="20220321T175649Z">
        <seg>프레임워크의 이 특징은 너무 중요해서 라이브러리가 Eq.refl _에 대한 기호 rfl을 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This gives you a way of creating pairs of natural
numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141135Z" creationid="tlqk35" creationdate="20220321T141135Z">
        <seg>이는 여러분에게 자연수의 쌍을 만들 수 있는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This gives you a way of extracting
its two components.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141215Z" creationid="tlqk35" creationdate="20220321T141215Z">
        <seg>이는 여러분에게 순서쌍의 두 성분을 추출하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This instructs Lean's elaborator to use the value
T as the type of e when trying to resolve implicit
arguments.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153538Z" creationid="tlqk35" creationdate="20220321T153538Z">
        <seg>이것은 린의 협력기가 암시적 인수를 해결하려고 시도할 때 e의 유형으로 T값을 사용하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is
known as an "implicit argument."</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152804Z" creationid="tlqk35" creationdate="20220321T152804Z">
        <seg>이것은 "암시적 인자"라고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152741Z" creationid="tlqk35" creationdate="20220321T152741Z">
        <seg>이는 의존 유형론의 핵심 특징입니다. 항은 많은 정보를 전달하고 종종 그 정보의 몇은  맥락으로부터 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a good place to introduce another device Lean offers to help
structure long proofs, namely, the have construct, which
introduces an auxiliary subgoal in a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165101Z" creationid="tlqk35" creationdate="20220321T165101Z">
        <seg>이곳은 린이 긴 증명을 구조화하도록 돕는 또다른 장치를 도입하기에 적절합니다. 주로  have 생성자인데 이는 증명의 보조적인 세부목표를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is an instance of a dependent function type, or dependent
arrow type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151554Z" creationid="tlqk35" creationdate="20220321T151554Z">
        <seg>이것은 의존적 함수 유형 또는 의존적 방향 유형의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is done by putting the arguments in
curly braces, as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153159Z" creationid="tlqk35" creationdate="20220321T153159Z">
        <seg>이것은 다음과 같이 인수를 중괄호 안에 두는 것으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is especially useful when the resulting goals can be finished off
in a uniform way, or, at least, when it is possible to make progress
on all of them uniformly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T150429Z" creationid="tlqk35" creationdate="20220524T150429Z">
        <seg>이는 특히 출력되는 목표가 균일한 방식으로 마무리 될 때 혹은 적어도 
출력목표가 모두를 균일한 방식으로 진전을 만드는게 가능할 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is essentially just alternative notation for the match
construct above.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182820Z" creationid="tlqk35" creationdate="20220321T182820Z">
        <seg>이것은 본질적으로 위의 match 생성을 위한 대체 기호일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is illustrated in the
following example, in which we set the option pp.explicit to true
to ask Lean's pretty-printer to show the implicit arguments.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181146Z" creationid="tlqk35" creationdate="20220321T181146Z">
        <seg>이것은 다음 예제에서 보여주고 있습니다. 여기서 암시적 인자를 보여주는데 린의 깔끔한 출력을 사용하도록 pp.explicit 옵션을 참으로 설정하였습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is known as proof irrelevance, and is
consistent with the interpretation in the last paragraph.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160256Z" creationid="tlqk35" creationdate="20220321T160256Z">
        <seg>이것은 증명 무연관으로 알려져 있고 이것은 마지막 문단에서 해석과 일관성이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is often used for names like Nat.rec and Nat.recOn, to prevent
overloading of common names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180844Z" creationid="tlqk35" creationdate="20220524T180844Z">
        <seg>흔한 이름들의 과부하를 막기 위해 Nat.rec과 Nat.recOn 같은 이름들에 종종 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is often useful as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163536Z" creationid="tlqk35" creationdate="20220321T163536Z">
        <seg>이것도 또한 종종 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is similar to the way
that computer scientists occasionally blur the distinction between
syntax and semantics by saying, at times, that a program "computes" a
certain function, and at other times speaking as though the program
"is" the function in question.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160449Z" creationid="tlqk35" creationdate="20220321T160449Z">
        <seg>이것은 컴퓨터 과학자들이 때때로 프로그램이 특정 함수를 "계산"한다고 말함으로써 문법과 의미론의 구분을 모호하게 하는 방식과 유사합니다. 그리고 다른 때에는 프로그램이 문제의 함수인 것처럼 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the approach followed in the Calculus of Constructions, and
hence in Lean as well.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155654Z" creationid="tlqk35" creationdate="20220321T155654Z">
        <seg>이는 직관주의적 계산법에 따른 접근법입니다. 그리고 이는 린에서도 마찬가지 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the elimination rule.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173854Z" creationid="tlqk35" creationdate="20220321T173854Z">
        <seg>이것은 제거 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the introduction rule.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173809Z" creationid="tlqk35" creationdate="20220321T173809Z">
        <seg>이것은 도입 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This looks exactly like the definition of the constant function in the
last chapter, the only difference being that the arguments are
elements of Prop rather than Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160711Z" creationid="tlqk35" creationdate="20220321T160711Z">
        <seg>이는 지난 장에서 상수함수의 정의와 완전히 동일하게 보입니다. 유일한 차이는 인수는 Prop의 원소 보다는 Type의 원소라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This makes the first argument to ident implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153306Z" creationid="tlqk35" creationdate="20220321T153306Z">
        <seg>이 첫 인수는 ident를 암시적으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This manual is generated by mdBook.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171705Z" creationid="tlqk35" creationdate="20220321T171705Z">
        <seg>이 메뉴얼은 mdBook으로 생성되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means compose is a function that takes any two functions as input
arguments, so long as those functions each take only one input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144440Z" creationid="tlqk35" creationdate="20220321T144440Z">
        <seg>이는 compose가 하나의 입력만 받는 함수인 경우에만 임의의 두 함수를 입력 인수로 받는 함수임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means compose can compose just about any 2 functions
so long as they each take one parameter, and so long as the type of
output of the second matches the input of the first.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144642Z" creationid="tlqk35" creationdate="20220321T144642Z">
        <seg>이는 compose가 그들이 입력받는 두 함수 각각이 한 매개변수만 받고 두번째 함수의 출력 유형이 첫번째 함수의 입력 유형과 같은 한 합성할 수 있다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the system maintains an internal ordering
of terms, and only applies the identity if doing so decreases the
order.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171733Z" creationid="tlqk35" creationdate="20220524T162624Z">
        <seg>이는 시스템이 항들의 내부적인 순서를 유지한다는 의미일 뿐만 아니라 
만약 무한루프가 유발된다면 항등식들의 순위를 줄이도록 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that whenever you write t, a placeholder, or
"hole," is inserted, so that t is replaced by @t _.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T184623Z" creationid="tlqk3" creationdate="20220525T184623Z">
        <seg>이는 우리가 t를 쓰는 언제든지 자리차지자 혹은 "구멍"이 삽입되고 t는 @t _로 대체됨을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This might look more familiar to you if you know how functions work in
other programming languages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143905Z" creationid="tlqk35" creationdate="20220321T143905Z">
        <seg>다른 프로그래밍언어에서 함수가 어떻게 동작하는지 안다면 이게 여러분에게 더 친숙하게 보일지 모르겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This provides
a quick and convenient way to begin experimenting with the system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131839Z" creationid="tlqk35" creationdate="20220321T131839Z">
        <seg>이는 실험적으로 시스템을 시작하는데 편리하고 빠른 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This provides a convenient way of accessing functions without opening
a namespace.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163410Z" creationid="tlqk35" creationdate="20220321T163410Z">
        <seg>이는 이름공간을 열지 않고 함수에 접근하는 편리한 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This reflects the interpretation of Prop as the type
of propositions rather than data, and it is what makes Prop
impredicative.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175109Z" creationid="tlqk35" creationdate="20220321T175109Z">
        <seg>이것은 데이터보다는 명제의 유형으로써 Prop의 해석을 반영했습니다. 그리고 이것이 Prop을 impredicative하게 만드는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This rule is sometimes called ex falso (short for ex
falso sequitur quodlibet), or the principle of explosion.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164428Z" creationid="tlqk35" creationdate="20220321T164428Z">
        <seg>이 규칙은 때때로 ex falso (라틴어 ex falso sequitur quodlibet을 줄인 것), 또는 폭발의 원리(principle of explosion)라고 불립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This sets a very high standard: every rule of inference and every step of a
calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and
rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131444Z" creationid="tlqk35" creationdate="20220321T131444Z">
        <seg>이것은 아주 높은 기준을 설정합니다. 모든 추론 규칙과 계산의 모든 계산 과정은 선행된(기초 공리와 규칙으로 거슬러 내려가는) 정의와 정리에 호소하여 정당화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This simple
device is extremely useful when it comes to structuring long proofs,
since we can use intermediate have's as stepping stones leading to
the final goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165215Z" creationid="tlqk35" creationdate="20220321T165215Z">
        <seg>이 단순한 장치는 긴 증명을 구조화 해야 할 때 아주 유용합니다. 왜냐하면 우리는 간간히 have를 최종 목표로 이끄는 주춧돌로써 쓰기 때문입다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tells Lean to use the assumption tactic, which, in turn,
proves the goal by finding a suitable hypothesis in the local
context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183420Z" creationid="tlqk35" creationdate="20220321T183420Z">
        <seg>이것은 린에게 assumption 전략을 사용하라고 말합니다. 따라서 이 전략은 현재 상황판에서 적절한 가정을 찾아 목표를 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial describes the current version of Lean, known as Lean 4.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131956Z" creationid="tlqk35" creationdate="20220321T131956Z">
        <seg>이 튜토리얼은 린의 현재 버전(린 4)를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial is an open access project maintained on Github.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134813Z" creationid="tlqk35" creationdate="20220321T134813Z">
        <seg>이 튜토리얼은 깃허브로 관리되어 누구나 접근할 수 있는 프로젝트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This type depends on two parameters: the type of the
elements in the vector (α : Type) and the length of the vector
n : Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150957Z" creationid="tlqk35" creationdate="20220321T150957Z">
        <seg>이 유형은 두 매개변수에 의존합니다. 하나는 벡터의 원소의 유형 (α : Type)이고 또 다른 하나는 벡터의 길이n : Nat입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This version of the text assumes you’re using Lean 4.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171351Z" creationid="tlqk35" creationdate="20220321T171351Z">
        <seg>이 버전의 책은 여러분이 Lean 4를 사용한다고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those not inclined to this ideology can view it, rather, as a simple
coding trick.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155921Z" creationid="tlqk35" creationdate="20220321T155921Z">
        <seg>이 이데올로기에 편향되지 않은 사람들은 꽤나 단순한 코딩 트릭으로 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throughout the text you will find examples of Lean code like the one below:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134728Z" creationid="tlqk35" creationdate="20220321T134728Z">
        <seg>이 교재에서 여러분은 아래와 같은 린 코드 예제를 보게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus if the application of
theorem foo to a single goal produces four subgoals, one would
expect the proof to look like this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T145553Z" creationid="tlqk35" creationdate="20220524T145553Z">
        <seg>따라서 foo 정리를 한 목표에 적용하여 네 개의 하위 목표를 만들려고 한다면 
누군가는 이 같은 증명을 기대할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus namespaces
give you a way to manage names in your working environment.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150500Z" creationid="tlqk35" creationdate="20220321T150500Z">
        <seg>따라서 이름공간은 당신의 작업 환경 속에 이름을 관리하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus the
proof term above could be written more concisely:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164020Z" creationid="tlqk35" creationdate="20220321T164020Z">
        <seg>따라서 위의 증명 항을 더 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus you can
view Nat.add as a function that takes a natural number and returns
another function that takes a natural number and returns a natural
number.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140823Z" creationid="tlqk35" creationdate="20220321T140823Z">
        <seg>따라서 여러분은 Nat.add은 자연수를 받아 자연수를 받고 자연수를 반환하는 또 다른 함수를 반환하는 함수로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus, for example, we can specialize the example from the previous section to the equality relation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175602Z" creationid="tlqk35" creationdate="20220321T175602Z">
        <seg>따라서, 우리는 이전 섹션에서 동등 관계까지의 예를 특수화 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To prove that
assertion, we need to exhibit a term t : p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160530Z" creationid="tlqk35" creationdate="20220321T160530Z">
        <seg>주장을 증명하는 것은 t : p의 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To build this manual, first install the fork via</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172002Z" creationid="tlqk35" creationdate="20220321T172002Z">
        <seg>이 메뉴얼을 생성하려면 fork를 다음을 거쳐 설치해야합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To define polymorphic constants, Lean allows you to
declare universe variables explicitly using the universe command:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142059Z" creationid="tlqk35" creationdate="20220321T142059Z">
        <seg>다형적인 상수를 정의하기 위해 린은 여러분이 세계 변수를 universe 명령을 명시적으로 사용하여 선언할 수 있게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To each proposition p we associate a type that is
empty if p is false and has a single element, say *, if p
is true.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155951Z" creationid="tlqk35" creationdate="20220321T155951Z">
        <seg>각 명제 p에 대해, 우리는 p이 거짓이면 원소가 없고, p가 참이면 한 원소(예: *)가 있는 유형을 연관시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To formally
express a mathematical assertion in the language of dependent type
theory, we need to exhibit a term p : Prop.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160507Z" creationid="tlqk35" creationdate="20220321T160507Z">
        <seg>의존 유형론의 언어로 수학적 주장을 형식적으로 표현하기 위해 p : Prop에 대한 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To get used to using universal quantifiers, you should try some of the
exercises at the end of this section.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174413Z" creationid="tlqk35" creationdate="20220321T174413Z">
        <seg>전칭 한정기호 사용에 익숙해지기 위해서 여러분은 이 섹션 끝의 연습문제들을 풀어보아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To illustrate the difference, consider the following example, which
shows that a reflexive euclidean relation is both symmetric and
transitive.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185734Z" creationid="tlqk3" creationdate="20220525T185734Z">
        <seg>차이를 설명하자면 유클리드 관계의 반사성은 모두 대칭적이고 추이적임을 보이는 다음 예제를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To preserve the validity of the previous
goal, the generalize tactic allows us to record the fact that
3 has been replaced by x.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T065607Z" creationid="tlqk35" creationdate="20220522T065607Z">
        <seg>앞선 목표의 유효성을 보존하기 위해 generalize 전략은 3이 
x로 대체되었음에 대한 사실을 기록하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To some who take a constructive view of logic and mathematics,
this is a faithful rendering of what it means to be a proposition: a
proposition p represents a sort of data type, namely, a
specification of the type of data that constitutes a proof.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155851Z" creationid="tlqk35" creationdate="20220321T155851Z">
        <seg>논리와 수학에 직관주의적 관점을 갖는 누군가에게 이것은 명제가 되는 것의 의미를 충실하게 표현합니다. 명제 p은 일종의 데이터 유형을 나타냅니다. 주로 증명을 만드는 데이터 유형의 명세입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To start with, we can
avoid writing the term Proof repeatedly by conflating Proof p
with p itself.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155247Z" creationid="tlqk35" creationdate="20220321T155247Z">
        <seg>그렇기 위해 우리는 Proof p를 p를 같이 쓰는 것으로 Proof에 대한 반복적인 사용을 피할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To start with, we can use anonymous "have" expressions to introduce an
auxiliary goal without having to label it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183308Z" creationid="tlqk35" creationdate="20220321T183308Z">
        <seg>우선, 우리는 익명 "have" 표현식으로 보조 목표의 이름 없이 도입하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To start with, you will learn the logical system that Lean is
based on, a version of dependent type theory that is powerful enough to prove almost any conventional mathematical
theorem, and expressive enough to do it in a natural way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132047Z" creationid="tlqk35" creationdate="20220321T132047Z">
        <seg>먼저 여러분은 Lean이 기초하고 있는 논리 체계 즉 거의 모든 기존의 수학적 정리를 증명할 수 있을 만큼 강력하고 그것을 자연스럽게 할 수 있을 만큼 충분히 표현력이 뛰어난 의존유형론 버전을 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To that end, the string _root_ is an
explicit description of the empty prefix.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180639Z" creationid="tlqk35" creationdate="20220524T180639Z">
        <seg>이 끝에서 문자열 _root_이 빈 접두사를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To the kernel type
checker, there is no difference between the two.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160850Z" creationid="tlqk35" creationdate="20220321T160850Z">
        <seg>커널 유형 확인기에서 둘 사이의 차이는 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use all the hypotheses present in the local context when
simplifying, we can use the wildcard symbol, *:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171708Z" creationid="tlqk35" creationdate="20220524T163644Z">
        <seg>단순화할 때 지역 상황에 나타난 모든 가정을 사용하기 위해서
우리는 와일드카드 기호 *를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To use this
principle, you have to open the classical namespace.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165706Z" creationid="tlqk35" creationdate="20220321T165706Z">
        <seg>이 원리를 사용하기 위해서 여러분은 classical 이름공간을 열어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>True</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162001Z" creationid="tlqk35" creationdate="20220321T162001Z">
        <seg>참</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Try proving these (one direction of the second of these
requires classical logic):</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183820Z" creationid="tlqk35" creationdate="20220321T183820Z">
        <seg>이것들을 증명해 보세요.(이들 두 번째 예제의 한쪽 방향은 고전논리가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two expressions that are equivalent up to
associativity and commutativity are then rewritten to the same
canonical form.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171722Z" creationid="tlqk35" creationdate="20220524T162902Z">
        <seg>그럼 결합성과 교환성에 한해 동등한 두 표현식은 같은 정식 형태로 다시쓰일 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference is an important part of Lean:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144052Z" creationid="tlqk35" creationdate="20220321T144052Z">
        <seg>유형 추론은 Lean의 중요한 기능입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types as objects</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141233Z" creationid="tlqk35" creationdate="20220321T141233Z">
        <seg>대상으로써 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Typically, the expression p
will depend on x : α.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T173332Z" creationid="tlqk35" creationdate="20220321T173332Z">
        <seg>일반적으로 표현식 p는 x : α에 의존할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162031Z" creationid="tlqk35" creationdate="20220321T161850Z">
        <seg>유니코드(Unicode)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike section, namespaces require a name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150420Z" creationid="tlqk35" creationdate="20220321T150420Z">
        <seg>section과는 달리, 이름공간은 이름이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unsurprisingly, it produces exactly the same proof term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T060658Z" creationid="tlqk35" creationdate="20220522T060658Z">
        <seg>놀랄 것 없이, 이것은 정확히 동일한 증명항을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use tactic combinators to obtain a one line proof of the following:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171454Z" creationid="tlqk35" creationdate="20220524T171454Z">
        <seg>다음의 한 줄 증명을 얻도록 전략조합자를 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Users may also wish to make use of additional
libraries, or develop their own projects across multiple files.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173740Z" creationid="tlqk35" creationdate="20220524T173740Z">
        <seg>사용자는 아마 추가적인 라이브러리의 사용 혹은 다수의 파일에 걸쳐 자신만의 프로젝트를 개발하기를 원할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the Simplifier</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T160612Z" creationid="tlqk35" creationdate="20220524T160612Z">
        <seg>단순화기를 사용하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Using the various gadgets described in this chapter --- the match
statement, anonymous constructors, and the rewrite tactic, we can
write this proof concisely as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183003Z" creationid="tlqk35" creationdate="20220321T183003Z">
        <seg>여기서 설명한 다양한 도구-match 구문, 익명 생성자,  다시쓰기전략-를 사용하여 다음과 같이 이 증명을 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables and Sections</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145123Z" creationid="tlqk35" creationdate="20220321T145123Z">
        <seg>변수와 섹션(Variables and Sections)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables are only
included in declarations where they are actually used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175415Z" creationid="tlqk35" creationdate="20220524T175415Z">
        <seg>변수는 오직 그들이 실제로 사용되는 선언에만 포함됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables can also be specified as implicit when they are declared with
the variable command:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153351Z" creationid="tlqk35" creationdate="20220321T153351Z">
        <seg>variable 명령으로 선언될 때 변수도 암시적으로 구체화될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We also leave it to you to determine which are
nonconstructive, and hence require some form of classical reasoning.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183134Z" creationid="tlqk35" creationdate="20220321T183134Z">
        <seg>우리는 또한 어떤 것이 비직관주의적인지 결정하는 것을 여러분에게 맡깁니다. 그러므로 일부는 고전 논리의 형식를 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We are currently using a
fork of it for the following additional features:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T171745Z" creationid="tlqk35" creationdate="20220321T171745Z">
        <seg>우리는 현재 다음 부가 기능을 위해 fork를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan
Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner,
Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey,
Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett for their contributions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134840Z" creationid="tlqk35" creationdate="20220321T134840Z">
        <seg>우리는 Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett에게 그들의 공헌에 대해 감사드립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can
then read t : p as the assertion that t is a proof of p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155526Z" creationid="tlqk35" creationdate="20220321T155526Z">
        <seg>우리는t : p를 t는 p의 증명이라는 주장으로써 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also ask Lean to fill in the proof by writing ‹p›, where
p is the proposition whose proof we want Lean to find in the
context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183449Z" creationid="tlqk35" creationdate="20220321T183449Z">
        <seg>또 우린 린에게 ‹p›라고 써서 증명 속을 채우도록 린에게 요청할수 있습니다. 여기서 p는 명제이고, 그것의 증명은 현재 상황에서 린이 찾기 바라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also use the projection notation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175615Z" creationid="tlqk35" creationdate="20220321T175615Z">
        <seg>또 우리는 투영 기호(인덱싱 기호)를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also use this device in function
definitions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153258Z" creationid="tlqk35" creationdate="20220321T153258Z">
        <seg>우리는 함수 정의에서도 이 기능을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can annotate the types used in the match
for greater clarity:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182644Z" creationid="tlqk35" creationdate="20220321T182644Z">
        <seg>우리는 더 명확함을 위해 match에서 사용되는 유형을 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can even use the match statement to decompose the conjunction at the same time:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182705Z" creationid="tlqk35" creationdate="20220321T182705Z">
        <seg>심지어 우리는 match 문장을 분해하는 동시에 결합하기 위해 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can make the output easier to read by telling Lean not to insert
the implicit arguments (which are displayed here as metavariables).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T175534Z" creationid="tlqk35" creationdate="20220321T175534Z">
        <seg>우리는 린에게 암시적인 인자를 삽입하지 말라 함으로써 출력을 더 쉽게 읽어들이도록 만들 수 있습니다.(메타변수로서 나타난 인자입니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can now prove p ∧ q → q ∧ p with the following proof term.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T162843Z" creationid="tlqk35" creationdate="20220321T162843Z">
        <seg>이제 우리는 p ∧ q → q ∧ p를 따르는 증명 항으로 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can now use this theorem to prove new results:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171620Z" creationid="tlqk35" creationdate="20220524T164538Z">
        <seg>우리는 이 정리로 새로운 결과를 증명하는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can prevent the shorter alias from being created by using the protected keyword:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180742Z" creationid="tlqk35" creationdate="20220524T180742Z">
        <seg>우리느 더 짤은 별명이 생기는 것을 protected  키워드를 사용하여 막을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can read
this as the assertion "for every pair of propositions p q, we have
p → q → p." For example, we can move all parameters to the right
of the colon:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161457Z" creationid="tlqk35" creationdate="20220321T161457Z">
        <seg>우리는 이를 "모든 명제쌍  p q에 대해 p → q → p이다."라고 주장한다고 읽을 수 있다. 예를 들어, 우리는 모든 매개변수들을 콜론의 오른쪽으로 옮길 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can refer to the last
expression introduced in this way using the keyword this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183322Z" creationid="tlqk35" creationdate="20220321T183322Z">
        <seg>이렇게 도입된 마지막 표현식을 키워드  this를 사용하여 참조할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can therefore
rewrite the sample proof above conveniently as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163453Z" creationid="tlqk35" creationdate="20220321T163453Z">
        <seg>우리는 다음과 같이 위의 예시 증명을 간단히 줄여 쓸  수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can use the anonymous constructor notation ⟨t, h⟩ for
Exists.intro t h, when the type is clear from the context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180943Z" creationid="tlqk35" creationdate="20220321T180943Z">
        <seg>우리는 맥락으로부터 형이 명백한 경우 익명 생성자 기호 ⟨t, h⟩을 Exists.intro t h에 대해 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can use the anonymous constructor notation to construct a proof of
p ↔ q from proofs of the forward and backward directions, and we
can also use . notation with mp and mpr.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T164841Z" creationid="tlqk35" creationdate="20220321T164841Z">
        <seg>우리는 앞과 뒷방향 증명으로부터 p ↔ q의 증명을 구성하기 위해 익명 생성자 표기를 사용할 수 있습니다. 그리고 우리는 .와  mp과 mpr을 사용한 표기를 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can view Exists.intro as an information-hiding operation, since
it hides the witness to the body of the assertion.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T181200Z" creationid="tlqk35" creationdate="20220321T181200Z">
        <seg>주장의 몸체의 발견을 감추기 때문에 우리는 Exists.intro을 정보 감추기 연산으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could render this as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155138Z" creationid="tlqk35" creationdate="20220321T155138Z">
        <seg>이를 다음과 같이 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could represent this as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T155008Z" creationid="tlqk35" creationdate="20220321T155008Z">
        <seg>이를 다음과 같이 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could then introduce, for each element p : Prop, another type
Proof p, for the type of proofs of p.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T154913Z" creationid="tlqk35" creationdate="20220321T154913Z">
        <seg>그러면 우리는 각각의 원소 p : Prop와 또 다른 유형인 Proof p을 p의 증명 유형으로 가져올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We have
chosen a nontraditional name here only to avoid a clash of names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153335Z" creationid="tlqk35" creationdate="20220321T153335Z">
        <seg>우리는 여기서 이름의 충돌을 방지하기 위해 비관습적인 이름을 선택할 뿐이었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We have seen that keywords like fun, have, and show make
it possible to write formal proof terms that mirror the structure of
informal mathematical proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183255Z" creationid="tlqk35" creationdate="20220321T183255Z">
        <seg>우리는 fun과 have,show와 같은 키워드가 비형식적인 수학적 증명의 구조를 반영하는 형식적 증명 용어를 쓸 수 있게 만든 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We have used . to create nested tactic blocks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T144734Z" creationid="tlqk35" creationdate="20220524T144734Z">
        <seg>우리는 중첩된 전략 블럭을 만드는데 .를 사용해왔습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We often put the by keyword on the preceding line, and write the
example above as</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184607Z" creationid="tlqk35" creationdate="20220321T184607Z">
        <seg>우리는 종종 by 키워드를 앞줄에 놓고 위의 예를 다음과 같이 작성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We recommend running the examples and experimenting with the code on your own as you work through the chapters
that follow.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134950Z" creationid="tlqk35" creationdate="20220321T134950Z">
        <seg>우리는 여러분이 장을 따라 공부하면서 스스로 예제를 실행해보고 코드를 실험해보는 것을 추천합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We recommend skimming this section to get a sense of Lean's
features, and then returning to it as necessary.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173334Z" creationid="tlqk35" creationdate="20220524T173334Z">
        <seg>우리는 린의 특징에 대한 감을 얻도록 건너뛰고 읽어보는 것을 추천합니다. 그리고 필요하다면 다시 여기로 돌아오세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We saw in Namespaces that Lean provides
mechanisms for working with hierarchical names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T175653Z" creationid="tlqk35" creationdate="20220524T175653Z">
        <seg>우리는 Namespaces에서 린이 계층적인 이름으로 작업하는 메커니즘을 제공하는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We say
it is "focusing" on the selected goal.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061457Z" creationid="tlqk35" creationdate="20220522T061457Z">
        <seg>우리는 이를 선택한 목표에 "초점을 맞췄다"고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184316Z" creationid="tlqk35" creationdate="20220321T184316Z">
        <seg>우리는 전략의 연쇄로 이뤄진 증명을 "전략 스타일" 증명으로 설명할 것이고, 우리가  "항 스타일" 증명이라고 부를 것이고 이제까지 보았던 증명 항를 작성하는 방법과 대조할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will discuss variations of rw and simp in the next chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180620Z" creationid="tlqk35" creationdate="20220321T180620Z">
        <seg>다음 장에서 rw와 simp의 변형을 다룰 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will fill this gap in the next
chapter, which introduces the notion of an inductive data type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172929Z" creationid="tlqk35" creationdate="20220524T172929Z">
        <seg>우리는 다음 장에서 inductive data type의 개념을 도입하여 이 간극을 메울 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will learn more about the assumption tactic in the
next chapter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183427Z" creationid="tlqk35" creationdate="20220321T183427Z">
        <seg>다음 장에서 assumption 전략에 대해 더 배울 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will see in Chapter Induction and Recursion that all these variations are
instances of a more general pattern-matching construct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T182909Z" creationid="tlqk35" creationdate="20220321T182909Z">
        <seg> 유도와 재귀에서 더 일반적인 패턴-매칭 생성 개체들의 모든 변형을 볼 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will see in Chapter Structures and Records that certain
types in Lean are structures, which is to say, the type is defined
with a single canonical constructor which builds an element of the
type from a sequence of suitable arguments.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163058Z" creationid="tlqk35" creationdate="20220321T163058Z">
        <seg>구조체와 레코드 장에서 보겠지만 린의 어떤 유형은 구조체입니다. 그 말은 유형이 하나의 적절한 인수의 배열로부터 유형의 원소를 만드는 정식 생성자로 정의된다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We will see later that there are situations in constructive logic
where principles like excluded middle and double-negation elimination
are permissible, and Lean supports the use of classical reasoning in
such contexts without relying on excluded middle.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170037Z" creationid="tlqk35" creationdate="20220321T170037Z">
        <seg>우리는 나중에 배중률과 이중 부정 제거와 같은 원칙이 허용되는 직관주의적 논리  상황이 있음을 나중에 보게 될 것입니다. 그리고 린은 그런 맥락에서 배중률에 의존하지 않는 고전논리의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What follows are some common identities involving the existential
quantifier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183122Z" creationid="tlqk35" creationdate="20220321T183122Z">
        <seg>다음은 존재 한정기호를 포함한 몇 가지 흔한 항등식들 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What follows is an example
of an identity from propositional logic that we proved in a previous
chapter, now proved using tactics.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062113Z" creationid="tlqk35" creationdate="20220522T062113Z">
        <seg>다음의 것은 전략을 사용해 증명할 이전 장에서 증명한 명제논리의 항등식의 예시들입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What makes dependent type theory dependent?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150804Z" creationid="tlqk35" creationdate="20220321T150804Z">
        <seg>무엇이 의존 유형론을 의존적이게 만드는가?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What makes simple type theory powerful is that you can build new types
out of others.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135919Z" creationid="tlqk35" creationdate="20220321T135919Z">
        <seg>단순 유형론을 강력하게 만드는 것은 기본형 외의 여러분만의 새로운 유형을 만들 수 있다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What type should cons have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151029Z" creationid="tlqk35" creationdate="20220321T151029Z">
        <seg>cons는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When
Lean starts, it automatically imports the contents of the library
Init folder, which includes a number of fundamental definitions
and constructions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T173833Z" creationid="tlqk35" creationdate="20220524T173833Z">
        <seg>린이 시작될 때, 이는 자동적으로 라이브러리 Init 폴더의 내용을 불러옵니다.
여기에는 다수의 기초적인 정의와 구성이 포함되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When β doesn't
depend on a, (a : α) → β is no different from the type
α → β.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152016Z" creationid="tlqk35" creationdate="20220321T152016Z">
        <seg> β가  a에 의존하지 않을 때, (a : α) → β는 유형 α → β유형과 다르지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a
function takes an argument that can generally be inferred from
context, Lean allows you to specify that this argument should, by
default, be left implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153145Z" creationid="tlqk35" creationdate="20220321T153145Z">
        <seg>함수가 일반적으로 맥락으로부터 추론할 수 있는 인수를 받을 때, Lean은 여러분이 이런 인수가 암시적이어야 함을 명시하도록 기본적으로 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When declared in this way, a variable stays in scope until the end of
the file you are working on.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150021Z" creationid="tlqk35" creationdate="20220321T150021Z">
        <seg>이 방식으로 선언되었을 때, 변수는 여러분이 작업하는 파일 끝까지를 범위로 가질 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the goal can be inferred, we can also ask Lean instead to fill in
the proof by writing by assumption:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183356Z" creationid="tlqk35" creationdate="20220321T183356Z">
        <seg>목표가 추론될 수 있을 때, 우리는 by assumption을 써 증명을 채우는 대신 린에게 물어볼 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the section is closed, the variables go out of scope, and cannot
be referenced any more.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150059Z" creationid="tlqk35" creationdate="20220321T150059Z">
        <seg>섹션이 닫히게 될 때, 변수들은 범위를 벗어나게 됩니다. 그리고 구분된 메모리 외에 아무것도 없게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the value of β depends on a (as does, for
example, the expression β a in the previous paragraph),
(a : α) → β denotes a dependent function type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151941Z" creationid="tlqk35" creationdate="20220321T151941Z">
        <seg>β의 값이 a에 의존할 때(예를 들어 앞 단락에서 식 β a처럼), (a : α) → β는 의존적 함수 유형을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When we generalize t1 in such a way, we can then apply it to
different pairs of propositions, to obtain different instances of the
general theorem.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T161654Z" creationid="tlqk35" creationdate="20220321T161654Z">
        <seg>우리가 t1을 그런 식으로 일반화할 때, 그럼 우리는 일반 정리의 다른 예를 얻기 위해 다른 명제쌍에 대해서도 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When we instantiate trans_r at
the values a b c, we end up with a proof of r a b → r b c → r a c.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T174035Z" creationid="tlqk35" creationdate="20220321T174035Z">
        <seg>우리가  trans_r을 값 a b c에 대해 개체화할 때, 우리는 r a b → r b c → r a c의 증명을 갖게됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When we open a namespace, an
identifier may be ambiguous.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180409Z" creationid="tlqk35" creationdate="20220524T180312Z">
        <seg>우리가 이름공간을 열때, 식별자는 모호하다고 할 지 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you declare that you are working in the namespace Foo, every
identifier you declare has a full name with prefix "Foo.".</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150245Z" creationid="tlqk35" creationdate="20220321T150245Z">
        <seg>이름공간 Foo에서 작업한다고 여러분이 선언할 때 여러분이 선언한 모든 식별자들은 "Foo."를 접미사로 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whereas rewrite is designed as a surgical tool for manipulating a
goal, the simplifier offers a more powerful form of automation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T161512Z" creationid="tlqk35" creationdate="20220524T160620Z">
        <seg>반면 rewrite는 목표를 조작하기 위한 외과 수술 도구로써 고안되었습다. 
단순화기는 자동화의 더욱 강력한 형태를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With calc, we can write the proof in the last section in a more
natural and perspicuous way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T180707Z" creationid="tlqk35" creationdate="20220321T180707Z">
        <seg>calc를 통해서 우리는 지난 섹션에서 증명을 더 자연스럽고 안목있는 방식으로 작성할 수 있었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With the analogy, however, the proof we have just constructed
is similar to a function that swaps the elements of a pair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T163021Z" creationid="tlqk35" creationdate="20220321T163021Z">
        <seg>하지만 이 비유에도 우리가 막 만든 증명은 순서쌍의 원소를 바꾸는 함수와 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With the three identities mentioned above, this has the effect
that all the parentheses in an expression are associated to the right,
and the expressions are ordered in a canonical (though somewhat
arbitrary) way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171728Z" creationid="tlqk35" creationdate="20220524T162812Z">
        <seg>세 항등식이 위에서 언급되었는데 이들은 표현식에서 모든 괄호가 오른쪽으로 결합된다는 
효과를 갖고 표현식들은 표준 방식(약간 임의적일지라도)에서 순서화됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With these tactics, an
example from the previous section can be rewritten as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071358Z" creationid="tlqk35" creationdate="20220522T071358Z">
        <seg>이 전략으로 이전 섹션의 예제를 다음과 같이 다시 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With this annotation, the
expression f 7 would be parsed as is, whereas f 7 3 would be
parsed as f 7 _ 3, just as it would be with the strong annotation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T185631Z" creationid="tlqk3" creationdate="20220525T185631Z">
        <seg>이 주석으로 표현식 f 7은 이대로 구문분석 될 수 있습니다. 반면 f 7 3은 강한 주석을 쓸 때처럼 f 7 _ 3으로 구문분석될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With this reduction, there are two ways that a computer can help establish a claim: it can help
find a proof in the first place, and it can help verify that a purported proof is correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131244Z" creationid="tlqk35" creationdate="20220321T131244Z">
        <seg>이러한 축소로부터 컴퓨터가 진술을 만드는데 도움을 주는 두 가지 방법이 있습니다. 처음부터 증명을 찾는 걸 돕는 것과 다른 하나는 제시한 증명이 옳은지 식별하도록 돕게 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Within
the namespace, you can refer to identifiers by their shorter names,
but once you end the namespace, you have to use the longer names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150359Z" creationid="tlqk35" creationdate="20220321T150359Z">
        <seg>이름공간 안에서 여러분은 식별자들을 그들의 약식 이름으로 부를 수 있습니다. 그러나 한번 이름공간에 끝에 오면 여러분은 더 긴 이름을 사용해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Working with Propositions as Types</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160548Z" creationid="tlqk35" creationdate="20220321T160548Z">
        <seg>유형으로써 명제로 작업하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing suffices hq : q leaves us with two goals.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T165549Z" creationid="tlqk35" creationdate="20220321T165549Z">
        <seg>suffices hq : q을 쓰는 것은 우리에게 두 목표를 남깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Writing simp only excludes these defaults,
allowing you to use a more explicitly crafted list of
rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170248Z" creationid="tlqk35" creationdate="20220524T170248Z">
        <seg>simp only를 쓰는 것은 여러분이 더 명시적으로 규칙 리스트를 
만들어 사용하도록 하여 이런 기본설정을 배제합니다,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You
can then invoke this function using:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143957Z" creationid="tlqk35" creationdate="20220321T143957Z">
        <seg>여러분은 이 함수를 다음과 같이 불러낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You
have already seen a nice example of this: the type List α depends
on the argument α, and this dependence is what distinguishes
List Nat and List Bool.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150838Z" creationid="tlqk35" creationdate="20220321T150838Z">
        <seg>여러분은 이것에 대한 멋진 예제를 보았습니다. 유형  List α 는 인수 α에 의존합니다. 여기서  List Nat과 List Bool을 구분하는 것은 이 의존입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You
will see an example of this in a moment.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062825Z" creationid="tlqk35" creationdate="20220522T062806Z">
        <seg>어느 때에 여러분은 이에 대한 예를 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You are now familiar with the fundamentals of dependent type theory,
both as a language for defining mathematical objects and a language
for constructing proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172752Z" creationid="tlqk35" creationdate="20220524T172752Z">
        <seg>정의한 수학적 대상과 증명을 만드는 언어 모두로써 여러분은 이제 기초적인 의존 유형론에 친숙합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
achieve that by marking it as a simplification rule when the theorem
is defined:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171604Z" creationid="tlqk35" creationdate="20220524T164802Z">
        <seg>여러분은 그것을 정리가 정의되었을 때 단순화 규칙으로 
표시함으로써 달성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
enter these particular ones with \a, \b, and \g.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140633Z" creationid="tlqk35" creationdate="20220321T140633Z">
        <seg>여러분은 이들 중 특정한 것은 \a, \b과 \g으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
then construct a proof by incrementally filling in these placeholders.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170510Z" creationid="tlqk35" creationdate="20220321T170510Z">
        <seg>그럼 여러분은 이 자리 차지자들을 점차 재우는 것으로 증명을 구성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
use the command #eval to execute expressions, and it is the
preferred way of testing your functions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143808Z" creationid="tlqk35" creationdate="20220321T143808Z">
        <seg>여러분은 #eval 명령을 사용해 식을 실행할 수 있습니다. 그리고 이것은 당신의 함수를 시험하는 선호되는 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can "combine" intro h with match h ... and write the previous examples as follows</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142341Z" creationid="tlqk35" creationdate="20220524T142341Z">
        <seg>여러분은 intro h에  match h ...을 "결합"할 수 있고 이전 예제를 다음과 같이 썼습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also declare new constants for types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141350Z" creationid="tlqk35" creationdate="20220321T141350Z">
        <seg>여러분은 유형들에 대해 새 상수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define a function that takes another function as input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144405Z" creationid="tlqk35" creationdate="20220321T144405Z">
        <seg>여러분은 또 다른 함수를 입력으로 받는 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also pass types as parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143154Z" creationid="tlqk35" creationdate="20220321T143154Z">
        <seg>여러분은 매개변수로 유형도 전달할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also provide multiple alternatives like in the match expression.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062637Z" creationid="tlqk35" creationdate="20220522T062637Z">
        <seg>여러분은 match 표현식에서처럼 여러 가지 변형들을 제공할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also revert multiple elements of the context at once:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064409Z" creationid="tlqk35" creationdate="20220522T064409Z">
        <seg>여러분은 맥락 속 다수의 요소들을 한번에 되돌려 놓을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use match in tactic blocks.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T142250Z" creationid="tlqk35" creationdate="20220524T142250Z">
        <seg>여러분은 전략 블록에서 match 를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use a (unstructured) cases without the with and a tactic
for each alternative.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070650Z" creationid="tlqk35" creationdate="20220522T070650Z">
        <seg>여러분은 (비구조화된)cases를 각각의 변형과 전략에 대해 with 없이 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use the
ASCII alternative -&gt;, so the expressions Nat -&gt; Nat and Nat →
Nat mean the same thing.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140458Z" creationid="tlqk35" creationdate="20220321T140458Z">
        <seg>여러분은 ASCII 대체 표현으로 -&gt;을 사용할 수 있습니다. 그래서 표현식 Nat -&gt; Nat과 Nat → Nat은 같은 식을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use the rename_i tactic to rename the most recent inaccessible names in your context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T063523Z" creationid="tlqk35" creationdate="20220522T063523Z">
        <seg>혹은 rename_i 전략으로 여러분의 상황에 가장 최근에 접속불가한 이름을 바꿀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use the ascii equivalent, &lt;-.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T172014Z" creationid="tlqk35" creationdate="20220524T155130Z">
        <seg>여러분은 아스키 등가 &lt;-를 사용하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use the combinator tac1 &lt;;&gt; tac2 to apply tac2 to each
subgoal produced by tactic tac1</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T070932Z" creationid="tlqk35" creationdate="20220522T070932Z">
        <seg>또 여러분은 조합자  tac1 &lt;;&gt; tac2를 각각의 하위 목표가 만든
 tac2에 tac1의 전략을 적용하여 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can avoid the universe command by providing the universe parameters when defining F.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142112Z" creationid="tlqk35" creationdate="20220321T142112Z">
        <seg>여러분은 F를 정의할 때 universe 매개변수를 제공하는 것으로 universe 명령을 쓰지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine multiple assignments by chaining let statements:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144834Z" creationid="tlqk35" creationdate="20220321T144834Z">
        <seg>여러분은 다수의 할당을 let 구문으로 연결함으로써 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine the unstructured cases tactic with the case and . notation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071028Z" creationid="tlqk35" creationdate="20220522T071028Z">
        <seg>여러분은 비구조화된 cases 전략을  case와 . 기호와 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can declare variables of any type, not just Type itself:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145206Z" creationid="tlqk35" creationdate="20220321T145206Z">
        <seg>여러분은 Type 그 자체뿐만 아니라 임의의 유형의 변수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can enter the unicode
arrow → by typing \to or \r or \-&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140358Z" creationid="tlqk35" creationdate="20220321T140358Z">
        <seg>여러분은 유니코드 화살표 →를 \to을 치거나 or \r또는 \-&gt;으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can evaluate a lambda function by passing the required parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142224Z" creationid="tlqk35" creationdate="20220321T142224Z">
        <seg>여러분은 필요한 매개변수를 람다 함수에 넘겨줌으로써 값을 평가할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can omit the type declarations when Lean has enough information to
infer it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144044Z" creationid="tlqk35" creationdate="20220321T144044Z">
        <seg>Lean이 유형을 추론하기에 충분한 정보를 갖고있을 때 여러분은 유형 선언을 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can only revert an element of the local context, that is, a
local variable or hypothesis.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T064550Z" creationid="tlqk35" creationdate="20220522T064550Z">
        <seg>여러분은 국부적인 상황 속 요소 즉, 지역변수나 가정을 revert 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can pass functions as parameters and by giving them names f
and g you can then use those functions in the implementation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143134Z" creationid="tlqk35" creationdate="20220321T143134Z">
        <seg>여러분은 매개변수로 함수의 이름  f과 g 을 주는 것으로 함수를 전달할 수 있습니다.  그러면 구현에서 이들 함수를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can probably guess what this one will do.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144354Z" creationid="tlqk35" creationdate="20220321T144354Z">
        <seg>여러분은 이 정의가 아마 뭘 할 지 추측할 수 있을 거예요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can prove the theorem above
in that way:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184540Z" creationid="tlqk35" creationdate="20220321T184540Z">
        <seg>여러분은 위의 정리를 그와 같이 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can provide different expansions, and the tactic
interpreter will try all of them until one succeeds.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170741Z" creationid="tlqk35" creationdate="20220524T170741Z">
        <seg>여러분은 다른 확장을 제공할 수 있다. 그리고 전략 
해석기는 한 개가 성공할 때까지 그들 모두를 시도할 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can see that each one of the expressions above is an object of
type Type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141344Z" creationid="tlqk35" creationdate="20220321T141344Z">
        <seg>여러분도 보다시피 위 각각의 표현식은 Type 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can see the correct order
in an editor by placing the cursor on the simp identifier to see
the documentation string that is associated with it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T165951Z" creationid="tlqk35" creationdate="20220524T165951Z">
        <seg>여려분은 이와 연관된 문서 끈을 보기 위해 simp 식별자에 커서를 놓아
편집기에서 옳은 순서를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can see the resulting proof term with the #print command:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055446Z" creationid="tlqk35" creationdate="20220522T055446Z">
        <seg>여러분은 #print 명령으로 증명항의 결과를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can solve the subgoal right before left using the case
notation</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061342Z" creationid="tlqk35" creationdate="20220522T061342Z">
        <seg>여러분은 case기호를 사용해서 하위목표 left보다 먼저 right을 풀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can structure your tactics using the
notation case &lt;tag&gt; =&gt; &lt;tactics&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T061221Z" creationid="tlqk35" creationdate="20220522T061221Z">
        <seg>여러분은 여러분의 전략을 case &lt;tag&gt; =&gt; &lt;tactics&gt;기호를 사용해 구조화할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can therefore proceed as
though α, β, γ, g, f, h, and x are fixed
objects when you write your definitions, and let Lean abstract the
definitions for you automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150013Z" creationid="tlqk35" creationdate="20220321T150013Z">
        <seg>그러므로 여러분은 여러분의 정의를 작성할 때  α, β, γ, g, f, h, x가 고정된 대상임에도 사용할 수 있습니다. 그리고 lean이 여러분을 위해 자동으로 정의를 축약할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can think of
the inhabitant of p as being the "fact that p is true." A
proof of p → q uses "the fact that p is true" to obtain "the
fact that q is true."</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T160148Z" creationid="tlqk35" creationdate="20220321T160148Z">
        <seg>p의 머무름은 "p가 참이라는 사실"이라 생각할 수 있습니다. p → q의 증명은 "p가 참이라는 사실"을 "q이 참이라는 사실"을 얻기위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can type
things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134940Z" creationid="tlqk35" creationdate="20220321T134940Z">
        <seg>여러분은 편집기에 무언가를 치거나 예제를 수정할 수 있습니다. 그리고 린은 여러분이 치는 동안 지속적으로 결과를 확인하고 피드백을 제공할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can type these corner quotes using \f&lt; and \f&gt;,
respectively.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183500Z" creationid="tlqk35" creationdate="20220321T183500Z">
        <seg>여러분은 이런 인용 꺽쇠를 각각 \f&lt;과 \f&gt;을 사용해서 칠 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use ⟨a, b⟩ or Sigma.mk a b to create a
dependent pair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152318Z" creationid="tlqk35" creationdate="20220321T152318Z">
        <seg>여러분은 ⟨a, b⟩ 또는 Sigma.mk a b를 종속적 쌍을 만드는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use it to introduce several variables:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T062237Z" creationid="tlqk35" creationdate="20220522T062237Z">
        <seg>여러분은 몇 개의 변수들을 도입하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use other more interesting expressions inside a def:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144344Z" creationid="tlqk35" creationdate="20220321T144344Z">
        <seg>여러분은 다른 더 흥미로운 식을 def 안에 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write a tactic script incrementally.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T055516Z" creationid="tlqk35" creationdate="20220522T055516Z">
        <seg>여러분은 점진적으로 전략 스크립트를 쓸 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write this goal as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T184440Z" creationid="tlqk35" creationdate="20220321T184440Z">
        <seg>여러분은 이 목표를 다음과 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can, in general, leave off the
type annotation and let Lean infer it for you.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142754Z" creationid="tlqk35" creationdate="20220321T142754Z">
        <seg>일반적으로 여러분도 유형 표기를 빼고 린에게 유형을 추론하게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do not have to indent the lines within a section.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150121Z" creationid="tlqk35" creationdate="20220321T150121Z">
        <seg>섹션 안에서 줄에 들여쓰기를 하거나 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have actually come up against one of the most subtle aspects of
Lean's typing system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141553Z" creationid="tlqk35" creationdate="20220321T141553Z">
        <seg>여러분은 린의 유형화 시스템의 가장 미묘한 면 중 하나를 마주쳤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have seen that if you have m : Nat and n : Nat, then
(m, n) denotes the ordered pair of m and n which is of
type Nat × Nat.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141120Z" creationid="tlqk35" creationdate="20220321T141120Z">
        <seg>여러분은 m : Nat과  n : Nat이면, (m, n)은 Nat × Nat유형인 m과 n의 순서쌍을 가리킨다는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You saw in Variables and Sections that the
section command makes it possible not only to group together
elements of a theory that go together, but also to declare variables
that are inserted as arguments to theorems and definitions, as
necessary.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174919Z" creationid="tlqk35" creationdate="20220524T174919Z">
        <seg>여러분은 Variables and Sections에서 section 명령으로 필요하다면
함께 할 이론의 요소를 한데 묶을 수 있을 뿐만 아니라 정리와 정의에 인수로 삽입될 변수를 선언할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You should also try to understand why the reverse implication is not derivable in the last example.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183807Z" creationid="tlqk35" creationdate="20220321T183807Z">
        <seg>여러분은 왜 명제의 역이 마지막 예제에서 불가능한지 이해하려고 시도해봐야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You should try
declaring some constants and type checking some expressions on your
own.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135902Z" creationid="tlqk35" creationdate="20220321T135902Z">
        <seg>여러분은 스스로 몇몇 상수를 선언하고 몇 가지 식의 유형을 확인해보길 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will generally use lower-case Greek
letters like α, β, and γ to range over types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140558Z" creationid="tlqk35" creationdate="20220321T140558Z">
        <seg>여러분은 유형을 포괄하기 위해  α, β, γ같은 그리스 소문자 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will have no doubt noticed by now that tactics can fail.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T151032Z" creationid="tlqk35" creationdate="20220524T151032Z">
        <seg>여러분은 이제 의심의 여지없이 전략은 실패할 것임을 눈치챌 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will learn various methods to support this in dependent type
theory.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132230Z" creationid="tlqk35" creationdate="20220321T132230Z">
        <seg>여러분은 의존 유형론에서 이를 지원하는 다양한 방법에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will see in Chapter Inductive Types that
these tactics are quite general.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220522T071625Z" creationid="tlqk35" creationdate="20220522T071625Z">
        <seg>유도형 장에서 이 전략들은 꽤나 일반적임을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will see later how these terms are evaluated.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143658Z" creationid="tlqk35" creationdate="20220321T143658Z">
        <seg>여러분은 나중에 이 항들이 어떻게 평가되는지 볼 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>apply And.intro &lt;;&gt; triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T171116Z" creationid="tlqk35" creationdate="20220524T171116Z">
        <seg>apply And.intro &lt;;&gt; triv

-- 이제 우리는 (재귀적인) 확장을 추가합니다.
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>creates aliases for succ, add, and sub in the current
namespace, so that whenever the namespace is open, these aliases are
available.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181545Z" creationid="tlqk3" creationdate="20220525T181545Z">
        <seg>이 이름공간이 열리기만 하면 별명을 이용할 수 있도록 현재 이름공간에 succ과 add과 sub에 대한 별명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>creates aliases for everything in the Nat namespace except the identifiers listed.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181149Z" creationid="tlqk3" creationdate="20220525T181149Z">
        <seg>나열된 식별자를 제외한 Nat 이름공간 속 모든 것에 대한 별명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>creates aliases for only the identifiers listed.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181029Z" creationid="tlqk3" creationdate="20220525T181029Z">
        <seg>나열된 식별자들만을 위한 별명을 만드세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>creates aliases renaming Nat.mul to times and Nat.add to plus.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk3" changedate="20220525T181256Z" creationid="tlqk3" creationdate="20220525T181256Z">
        <seg>Nat.mul을 times 으로 그리고 Nat.add을 plus로 다시 이름지어 별명을 만드세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>imports the file Bar/Baz/Blah.olean, where the descriptions are
interpreted relative to the Lean search path.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T174156Z" creationid="tlqk35" creationdate="20220524T174156Z">
        <seg>린의 파일 search path에 상대적인 주소로 설명된 곳에서 Bar/Baz/Blah.olean을 불러옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>is treated as a macro, and expands to</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T180127Z" creationid="tlqk35" creationdate="20220524T180054Z">
        <seg>은 매크로로 간주되고 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>mdbook watch --open  # opens the output in `out/` in your default browser</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T172153Z" creationid="tlqk35" creationdate="20220321T172153Z">
        <seg>mdbook watch을 열고 # 여러분의 기본 브라우저에서 `out/`에서 출력을 여세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>notation "‹" p "›" =&gt; show p by assumption</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T183620Z" creationid="tlqk35" creationdate="20220321T183620Z">
        <seg>기호 "‹" p "›" =&gt; 은 가정에 의해 p가 참임을 보입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>open Classical

-- distributivity
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170530Z" creationid="tlqk35" creationdate="20220321T170530Z">
        <seg>open Classical

-- 분배성
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- an example that requires classical reasoning
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170550Z" creationid="tlqk35" creationdate="20220321T170550Z">
        <seg>show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- 고전 추론을 필요로 하는 예제
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>triv

-- You cannot prove the following theorem using `triv`
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220524T170842Z" creationid="tlqk35" creationdate="20220524T170842Z">
        <seg>triv

-- 여러분은 `triv` 사용해 다음 정리를 증명할 수 없습니다.
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>variable (p q r : Prop)

-- commutativity of ∧ and ∨
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- associativity of ∧ and ∨
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- distributivity
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- other properties
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T170650Z" creationid="tlqk35" creationdate="20220321T170650Z">
        <seg>variable (p q r : Prop)

-- ∧과 ∨의 교환성
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- ∧과 ∨의 결합성
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- 분배성
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- 다른 성질들
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
