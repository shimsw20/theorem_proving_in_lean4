<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-5.7.0" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv xml:lang="en-US">
        <seg>"Type theory" gets its name from the fact that every expression has an
associated <bpt i="1" x="1">&lt;g1&gt;</bpt>type<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135220Z" creationid="tlqk35" creationdate="20220321T135220Z">
        <seg>'유형론'은 그것의 이름을 모든 표현은 연관된 <bpt i="1" x="1">&lt;g1&gt;</bpt>유형<ept i="1">&lt;/g1&gt;</ept>을 가지고 있다는 사실로부터 갖게 되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>#check Nat → Nat      -- type the arrow as "\to" or "\r"
#check Nat -&gt; Nat     -- alternative ASCII notation

#check Nat × Nat      -- type the product as "\times"
#check Prod Nat Nat   -- alternative notation

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  same type as above

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- a "functional"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140252Z" creationid="tlqk35" creationdate="20220321T140252Z">
        <seg>#check Nat → Nat      --화살표를 쓰기 위해서 "\to"나 "\r"를 치세요.
#check Nat -&gt; Nat     -- ASCII 표기의 대체표현입니다.

#check Nat × Nat      -- 곱하기를 쓰기 위해 "\times"를 치세요.
#check Prod Nat Nat   -- 대체 표현입니다.

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  -- 위와 같은 유형입니다.

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- "범함수"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- λ and fun mean the same thing
#check fun x : Nat =&gt; x + 5     -- Nat inferred
#check λ x : Nat =&gt; x + 5       -- Nat inferred</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142214Z" creationid="tlqk35" creationdate="20220321T142214Z">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     --  λ 와 fun 같은 의미를 가집니다.
#check fun x : Nat =&gt; x + 5     --  Nat으로 추론됩니다.
#check λ x : Nat =&gt; x + 5       --  Nat으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Lean will tell you that <bpt i="2" x="2">&lt;g2&gt;</bpt>sub2<ept i="2">&lt;/g2&gt;</ept> has been defined in terms
of an internal auxiliary function, <bpt i="3" x="3">&lt;g3&gt;</bpt>sub2.match_1<ept i="3">&lt;/g3&gt;</ept>, but you can print
that out too.) Lean uses these auxiliary functions to compile <bpt i="4" x="4">&lt;g4&gt;</bpt>match<ept i="4">&lt;/g4&gt;</ept> expressions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162747Z" creationid="tlqk3" creationdate="20220529T162747Z">
        <seg>(린은 여러분에게 <bpt i="2" x="2">&lt;g2&gt;</bpt>sub2<ept i="2">&lt;/g2&gt;</ept>가 내부의 보조 함수 <bpt i="3" x="3">&lt;g3&gt;</bpt>sub2.match_1<ept i="3">&lt;/g3&gt;</ept>에 대해서 정의되었다고 말할 것입니다. 그러나 여러분은 그것도 출력해볼 수 있습니다.) 린은 이 보조 함수를 <bpt i="4" x="4">&lt;g4&gt;</bpt>match<ept i="4">&lt;/g4&gt;</ept> 표현식을 컴파일하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Making sense of the type of this function requires an understanding
of dependent products, which will be explained below.)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143305Z" creationid="tlqk35" creationdate="20220321T143305Z">
        <seg>(이 함수의 유형들을 이해하는 것은 아래에서 설명할 의존 곱에 대한 이해가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(Note that this description is somewhat
misleading, in that the arguments to the constructor can appear in any
order as long as the dependencies make sense.) The constraints on the
universe level of <bpt i="4" x="4">&lt;g4&gt;</bpt>C<ept i="4">&lt;/g4&gt;</ept> fall into two cases, depending on whether or
not the inductive type is specified to land in <bpt i="5" x="5">&lt;g5&gt;</bpt>Prop<ept i="5">&lt;/g5&gt;</ept> (that is,
<bpt i="6" x="6">&lt;g6&gt;</bpt>Sort 0<ept i="6">&lt;/g6&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152233Z" creationid="tlqk35" creationdate="20220528T161743Z">
        <seg>(그들의 의존성이 성립되는 한 인자가 생성자에 임의의 순서로 나타날 수 있다는 점에서 이 설명은 약간 오해로 이끌 수 있습니다.) <bpt i="4" x="4">&lt;g4&gt;</bpt>C<ept i="4">&lt;/g4&gt;</ept>의 세계 수준에서 귀납형이 <bpt i="5" x="5">&lt;g5&gt;</bpt>Prop<ept i="5">&lt;/g5&gt;</ept> (즉, <bpt i="6" x="6">&lt;g6&gt;</bpt>Sort 0<ept i="6">&lt;/g6&gt;</ept>)에 머무른다고 나타나져 있는지 아닌지에 따라 제약은 두 경우로 나누어 떨어집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(The notation <bpt i="2" x="2">&lt;g2&gt;</bpt>+<ept i="2">&lt;/g2&gt;</ept>, as we have defined it, associates to the left, so <bpt i="3" x="3">&lt;g3&gt;</bpt>m + n + k<ept i="3">&lt;/g3&gt;</ept> is really <bpt i="4" x="4">&lt;g4&gt;</bpt>(m + n) + k<ept i="4">&lt;/g4&gt;</ept>.)
The hardest part is figuring out which variable to do the induction on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162029Z" creationid="tlqk3" creationdate="20220527T162029Z">
        <seg>(<bpt i="2" x="2">&lt;g2&gt;</bpt>+<ept i="2">&lt;/g2&gt;</ept> 기호는 우리가 정의했다시피 왼쪽으로 결합됩니다. 그래서 <bpt i="3" x="3">&lt;g3&gt;</bpt>m + n + k<ept i="3">&lt;/g3&gt;</ept>은 사실 <bpt i="4" x="4">&lt;g4&gt;</bpt>(m + n) + k<ept i="4">&lt;/g4&gt;</ept>입니다.) 가장 어려운 부분은 어떤 변수에 귀납을 적용할 것인지 알아내는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(The symbol <bpt i="10" x="10">&lt;g10&gt;</bpt>¬<ept i="10">&lt;/g10&gt;</ept> is produced by
typing <bpt i="11" x="11">&lt;g11&gt;</bpt>\not<ept i="11">&lt;/g11&gt;</ept> or <bpt i="12" x="12">&lt;g12&gt;</bpt>\neg<ept i="12">&lt;/g12&gt;</ept>.)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164334Z" creationid="tlqk35" creationdate="20220321T164334Z">
        <seg>(기호 <bpt i="10" x="10">&lt;g10&gt;</bpt>¬<ept i="10">&lt;/g10&gt;</ept>은 <bpt i="11" x="11">&lt;g11&gt;</bpt>\not<ept i="11">&lt;/g11&gt;</ept>이나  <bpt i="12" x="12">&lt;g12&gt;</bpt>\neg<ept i="12">&lt;/g12&gt;</ept>을 치는 것으로 만들어집니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(To run these examples, we put them in a namespace called <bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept>,
so that a name like <bpt i="2" x="2">&lt;g2&gt;</bpt>Bool<ept i="2">&lt;/g2&gt;</ept> does not conflict with the <bpt i="3" x="3">&lt;g3&gt;</bpt>Bool<ept i="3">&lt;/g3&gt;</ept> in
the standard library.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152114Z" creationid="tlqk3" creationdate="20220526T152114Z">
        <seg>(이 예제를 실행하려면 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept>이라는 이름공간에 이들을 두어서 <bpt i="2" x="2">&lt;g2&gt;</bpt>Bool<ept i="2">&lt;/g2&gt;</ept>같은 이름이 표준 라이브러리에서의 <bpt i="3" x="3">&lt;g3&gt;</bpt>Bool<ept i="3">&lt;/g3&gt;</ept>과 출돌하지 않게 해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(You can enter it with <bpt i="2" x="2">&lt;g2&gt;</bpt>\l<ept i="2">&lt;/g2&gt;</ept> or
use the ascii equivalent, <bpt i="3" x="3">&lt;g3&gt;</bpt>&lt;-<ept i="3">&lt;/g3&gt;</ept>.) If brevity is what we are after,
both <bpt i="4" x="4">&lt;g4&gt;</bpt>rw<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>simp<ept i="5">&lt;/g5&gt;</ept> can do the job on their own:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180752Z" creationid="tlqk35" creationdate="20220321T180752Z">
        <seg>(여러분은 이것을 <bpt i="2" x="2">&lt;g2&gt;</bpt>\l<ept i="2">&lt;/g2&gt;</ept>을 치거나 아스키 형식 <bpt i="3" x="3">&lt;g3&gt;</bpt>&lt;-<ept i="3">&lt;/g3&gt;</ept>을 사용할 수 있습니다.) 우리가 간결함을 추구한다면 <bpt i="4" x="4">&lt;g4&gt;</bpt>rw<ept i="4">&lt;/g4&gt;</ept>과<bpt i="5" x="5">&lt;g5&gt;</bpt>simp<ept i="5">&lt;/g5&gt;</ept>이 알아서 처리해 줄 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>(fun x =&gt; x) :: []

-- In this example, implicit lambda introduction has been disabled because
-- we use `@` before `fun`
def id2 : {α : Type} → α → α :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135806Z" creationid="tlqk3" creationdate="20220526T135806Z">
        <seg>(fun x =&gt; x) :: []

-- 우리는 `fun` 앞에 `@`를 쓰기 때문에 
-- 이 예제에서 암시적인 람다의 도입은 해제되었습니다.
def id2 : {α : Type} → α → α :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;" is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135459Z" creationid="tlqk35" creationdate="20220321T135459Z">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;"은 불리언 and
#check b1 || b2     -- 불리언 or
#check true         -- 불리언 "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>-/

def m : Nat := 1       -- m is a natural number
def n : Nat := 0
def b1 : Bool := true  -- b1 is a Boolean
def b2 : Bool := false

/- Check their types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135403Z" creationid="tlqk35" creationdate="20220321T135342Z">
        <seg>-/

def m : Nat := 1       -- m은 자연수입니다.
def n : Nat := 0
def b1 : Bool := true  -- b1은 불리언입니다.
def b2 : Bool := false

/- 그들의 유형을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>/- Define some constants.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135320Z" creationid="tlqk35" creationdate="20220321T135320Z">
        <seg>/-  몇 가지 상수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Automated theorem proving<ept i="1">&lt;/g1&gt;</ept> focuses on the "finding" aspect.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131300Z" creationid="tlqk35" creationdate="20220321T131300Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>자동화된 정리 증명<ept i="1">&lt;/g1&gt;</ept>은 '찾기'에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Axioms and Computation<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171151Z" creationid="tlqk35" creationdate="20220321T171151Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>공리와 계산(Axioms and Computation)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Dependent Type Theory<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170939Z" creationid="tlqk35" creationdate="20220321T170939Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>의존 유형론(Dependent Type Theory)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Formal verification<ept i="1">&lt;/g1&gt;</ept> involves the use of logical and computational methods to establish claims that are expressed in
precise mathematical terms.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131125Z" creationid="tlqk35" creationdate="20220321T131125Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>형식 증명<ept i="1">&lt;/g1&gt;</ept>은 정밀한 수학적 항들로 표현된 주장을 세우는데 논리적이고 계산과학적 방법의 사용을 수반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Induction and Recursion<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171105Z" creationid="tlqk35" creationdate="20220321T171105Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>유도와 재귀(Induction and Recursion)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Inductive Types<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151626Z" creationid="tlqk35" creationdate="20220321T171056Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>귀납형(Inductive Types)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Interacting with Lean<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171019Z" creationid="tlqk35" creationdate="20220321T171019Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>린과 상호작용하기(Interacting with Lean)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Introduction<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170931Z" creationid="tlqk35" creationdate="20220321T170931Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>소개(Introduction)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Propositions and Proofs<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170947Z" creationid="tlqk35" creationdate="20220321T170947Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>명제와 증명(Propositions and Proofs)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Quantifiers and Equality<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170959Z" creationid="tlqk35" creationdate="20220321T170959Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>한정기호와 동등성(Quantifiers and Equality)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Record update<ept i="1">&lt;/g1&gt;</ept> is another common operation which amounts to creating
a new record object by modifying the value of one or more fields in an
old one.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181016Z" creationid="tlqk35" creationdate="20220528T181016Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>레코드 업데이트<ept i="1">&lt;/g1&gt;</ept>는 이전 필드에서 하나 이상의 필드 값을 수정하여 새 레코드 개체를 만드는 것과 같은 또 다른 흔한 연산입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Structures and Records<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171114Z" creationid="tlqk35" creationdate="20220321T171114Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>구조체와 레코드(Structures and Records)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>TODO: waiting for well-founded support in Lean 4<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171705Z" creationid="tlqk3" creationdate="20220603T171705Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>할 것: 린4가 지원하는 잘 세워진 식을 대기하기<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Tactic combinators<ept i="1">&lt;/g1&gt;</ept> are operations that form new tactics from old
ones.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145640Z" creationid="tlqk35" creationdate="20220524T145640Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Tactic combinators<ept i="1">&lt;/g1&gt;</ept>은 이전의 전략으로부터 새로운 전략을 만드는 연산자들 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Tactics for Inductive Types<ept i="1">&lt;/g1&gt;</ept> below will introduce additional
tactics that are specifically designed to make use of inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152003Z" creationid="tlqk3" creationdate="20220526T151619Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>귀납형을 위한 전략<ept i="1">&lt;/g1&gt;</ept> 아래에서 귀납형의 사용을 위해 특별히 고안된 추가 전략들을 도입할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Tactics<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171004Z" creationid="tlqk35" creationdate="20220321T171004Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>전략(Tactics)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>The Conversion Tactic Mode<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171141Z" creationid="tlqk35" creationdate="20220321T171141Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>전략 모드로 전환(The Conversion Tactic Mode)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Theorem Proving in Lean 4<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170925Z" creationid="tlqk35" creationdate="20220321T170925Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>린4로 하는 정리 증명<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Type Classes<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152603Z" creationid="tlqk35" creationdate="20220321T171124Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>유형 클래스(Type Classes)<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>apply &lt;term&gt;<ept i="1">&lt;/g1&gt;</ept> is syntax sugar for <bpt i="2" x="2">&lt;g2&gt;</bpt>tactic =&gt; apply &lt;term&gt;<ept i="2">&lt;/g2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184838Z" creationid="tlqk3" creationdate="20220604T184838Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>apply &lt;term&gt;<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>tactic =&gt; apply &lt;term&gt;<ept i="2">&lt;/g2&gt;</ept>에 대한 문법 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>arg i<ept i="1">&lt;/g1&gt;</ept> enter the <bpt i="2" x="2">&lt;g2&gt;</bpt>i<ept i="2">&lt;/g2&gt;</ept>-th nondependent explicit argument of an application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184113Z" creationid="tlqk3" creationdate="20220604T184113Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>arg i<ept i="1">&lt;/g1&gt;</ept>는 적용의 <bpt i="2" x="2">&lt;g2&gt;</bpt>i<ept i="2">&lt;/g2&gt;</ept>번째 비의존적인 명시적 인수를 입력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>args<ept i="1">&lt;/g1&gt;</ept> alternative name for <bpt i="2" x="2">&lt;g2&gt;</bpt>congr<ept i="2">&lt;/g2&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184152Z" creationid="tlqk3" creationdate="20220604T184152Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>args<ept i="1">&lt;/g1&gt;</ept> <bpt i="2" x="2">&lt;g2&gt;</bpt>congr<ept i="2">&lt;/g2&gt;</ept>의 대체 이름</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>by Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich, with contributions from the Lean Community<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171326Z" creationid="tlqk35" creationdate="20220321T171326Z">
        <seg><it pos="begin" x="1">&lt;g1&gt;</it>Jeremy Avigad, Leonardo de Moura, Soonho Kong and Sebastian Ullrich 및 Lean 커뮤니티의 기여자들 저</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept> also takes a 3rd argument of type <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> which
it uses to invoke the second function (locally named <bpt i="3" x="3">&lt;g3&gt;</bpt>f<ept i="3">&lt;/g3&gt;</ept>) and it
passes the result of that function (which is type <bpt i="4" x="4">&lt;g4&gt;</bpt>β<ept i="4">&lt;/g4&gt;</ept>) as input to the
first function (locally named <bpt i="5" x="5">&lt;g5&gt;</bpt>g<ept i="5">&lt;/g5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144548Z" creationid="tlqk35" creationdate="20220321T144548Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept>는 이는 두 번째 함수(지역적으로 <bpt i="3" x="3">&lt;g3&gt;</bpt>f<ept i="3">&lt;/g3&gt;</ept>라 하는)을 호출하는데 사용되기도 하는 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> 를 세 번째 인수로 받습니다. 그리고 두 번째 합수는 그 함수의 결과(유형 <bpt i="4" x="4">&lt;g4&gt;</bpt>β<ept i="4">&lt;/g4&gt;</ept>의)를 첫 번째 함수(지역적으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>g<ept i="5">&lt;/g5&gt;</ept>라 하는)의 입력으로 전달합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept> is also very general in that it works over any type
<bpt i="2" x="2">&lt;g2&gt;</bpt>α β γ<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144628Z" creationid="tlqk35" creationdate="20220321T144628Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept>는 또 아주 일반적이어서 임의의 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>α β γ<ept i="2">&lt;/g2&gt;</ept>에 대해서도 작동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>congr<ept i="1">&lt;/g1&gt;</ept> creates as many targets as there are (nondependent and explicit) arguments to the current head function
(here the head function is multiplication).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182800Z" creationid="tlqk3" creationdate="20220604T182800Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>congr<ept i="1">&lt;/g1&gt;</ept>은 현재 머리 함수 (여기서 머리 함수은 곱셈)에 대한 (비의존적 및 명시적) 인수만큼 많은 대상을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept> can take multiple input parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144242Z" creationid="tlqk35" creationdate="20220321T144242Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept>는 다수의 입력 매개변수를 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>done<ept i="1">&lt;/g1&gt;</ept> fail if there are unsolved goals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184417Z" creationid="tlqk3" creationdate="20220604T184417Z">
        <seg>미해결 목표가 있으면 <bpt i="1" x="1">&lt;g1&gt;</bpt>done<ept i="1">&lt;/g1&gt;</ept>이 실패합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>enter [1, x, 2, y]<ept i="1">&lt;/g1&gt;</ept> iterate <bpt i="2" x="2">&lt;g2&gt;</bpt>arg<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>intro<ept i="3">&lt;/g3&gt;</ept> with the given arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184319Z" creationid="tlqk3" creationdate="20220604T184319Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>enter [1, x, 2, y]<ept i="1">&lt;/g1&gt;</ept> 주어진 인수로 <bpt i="2" x="2">&lt;g2&gt;</bpt>arg<ept i="2">&lt;/g2&gt;</ept> 및 <bpt i="3" x="3">&lt;g3&gt;</bpt>intro<ept i="3">&lt;/g3&gt;</ept>를 반복합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>lhs<ept i="1">&lt;/g1&gt;</ept> navigates to the left hand side of a relation (here equality), there is also a <bpt i="2" x="2">&lt;g2&gt;</bpt>rhs<ept i="2">&lt;/g2&gt;</ept> navigating to the right hand side.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182652Z" creationid="tlqk3" creationdate="20220604T182639Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>lhs<ept i="1">&lt;/g1&gt;</ept>는 관계식의 좌변으로 이동하고(여기서는 등호), 우변으로 이동하는 <bpt i="2" x="2">&lt;g2&gt;</bpt>rhs<ept i="2">&lt;/g2&gt;</ept>도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> applies the simplifier to the current goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184216Z" creationid="tlqk3" creationdate="20220604T184216Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept>는 현재 목표에 단순화기를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>skip<ept i="1">&lt;/g1&gt;</ept> goes to the next target.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182819Z" creationid="tlqk3" creationdate="20220604T182819Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>skip<ept i="1">&lt;/g1&gt;</ept>는 다음 대상으로 이동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>tactic =&gt; &lt;tactic sequence&gt;<ept i="1">&lt;/g1&gt;</ept> go back to regular tactic mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184602Z" creationid="tlqk3" creationdate="20220604T184602Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt> tactic =&gt; &lt;tactic sequence&gt;<ept i="1">&lt;/g1&gt;</ept>는 보통의 전략 모드로 되돌아갑니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>traceState<ept i="1">&lt;/g1&gt;</ept> display the current tactic state.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184431Z" creationid="tlqk3" creationdate="20220604T184431Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>traceState<ept i="1">&lt;/g1&gt;</ept>는 현재 전략 상태를 표시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>whnf<ept i="1">&lt;/g1&gt;</ept> put term in weak head normal form.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184527Z" creationid="tlqk3" creationdate="20220604T184527Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>whnf<ept i="1">&lt;/g1&gt;</ept>은 항를 약한 머리 정규 형식에 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>Type 1<ept i="2">&lt;/g2&gt;</ept> is then a larger universe of types, which contains <bpt i="3" x="3">&lt;g3&gt;</bpt>Type
0<ept i="3">&lt;/g3&gt;</ept> as an element, and <bpt i="4" x="4">&lt;g4&gt;</bpt>Type 2<ept i="4">&lt;/g4&gt;</ept> is an even larger universe of types,
which contains <bpt i="5" x="5">&lt;g5&gt;</bpt>Type 1<ept i="5">&lt;/g5&gt;</ept> as an element.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141659Z" creationid="tlqk35" creationdate="20220321T141659Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>Type 1<ept i="2">&lt;/g2&gt;</ept>는  <bpt i="3" x="3">&lt;g3&gt;</bpt>Type 0<ept i="3">&lt;/g3&gt;</ept>를 원소로 갖는 유형들의 더 큰 세계이고 <bpt i="4" x="4">&lt;g4&gt;</bpt>Type 2<ept i="4">&lt;/g4&gt;</ept>는 <bpt i="5" x="5">&lt;g5&gt;</bpt>Type 1<ept i="5">&lt;/g5&gt;</ept>을 원소로 하는 유형들의 더욱 큰 세계입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>Section wildcards and overlapping patterns<ept i="4">&lt;/g4&gt;</ept>
expands on the notion of a wildcard, and <bpt i="5" x="5">&lt;g5&gt;</bpt>Section Inaccessible Patterns<ept i="5">&lt;/g5&gt;</ept> explains how
you can use implicit arguments in patterns as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163535Z" creationid="tlqk3" creationdate="20220529T163535Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>와일드카드와 중복된 패턴 섹션<ept i="4">&lt;/g4&gt;</ept>은 와일드카드에 대한 개념을 넓히고 <bpt i="5" x="5">&lt;g5&gt;</bpt>접근할 수 없는 패턴 섹션<ept i="5">&lt;/g5&gt;</ept>은 여러분이 어떻게 패턴속에서도 암시적인 인수를 사용할 수 있는지 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>Prop<ept i="7">&lt;/g7&gt;</ept> has some special
features, but like the other type universes, it is closed under the
arrow constructor: if we have <bpt i="8" x="8">&lt;g8&gt;</bpt>p q : Prop<ept i="8">&lt;/g8&gt;</ept>, then <bpt i="9" x="9">&lt;g9&gt;</bpt>p → q : Prop<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155829Z" creationid="tlqk35" creationdate="20220321T155829Z">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>Prop<ept i="7">&lt;/g7&gt;</ept>은 특별한 특징이 있습니다. 하지만 다른 유형 세계처럼, 화살표 생성자로 달성됩니다. 우리가 <bpt i="8" x="8">&lt;g8&gt;</bpt>p q : Prop<ept i="8">&lt;/g8&gt;</ept>갖는다면  <bpt i="9" x="9">&lt;g9&gt;</bpt>p → q : Prop<ept i="9">&lt;/g9&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg><bpt i="8" x="8">&lt;g8&gt;</bpt>Type<ept i="8">&lt;/g8&gt;</ept> is
an abbreviation for <bpt i="9" x="9">&lt;g9&gt;</bpt>Type 0<ept i="9">&lt;/g9&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141748Z" creationid="tlqk35" creationdate="20220321T141748Z">
        <seg><bpt i="8" x="8">&lt;g8&gt;</bpt>Type<ept i="8">&lt;/g8&gt;</ept>는 <bpt i="9" x="9">&lt;g9&gt;</bpt>Type 0<ept i="9">&lt;/g9&gt;</ept>에 대한 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>&lt;tactics&gt;<it pos="end" x="1">&lt;/g1&gt;</it> (or <bpt i="2" x="2">&lt;g2&gt;</bpt>· &lt;tactics&gt;<ept i="2">&lt;/g2&gt;</ept>) for
structuring proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061833Z" creationid="tlqk35" creationdate="20220522T061810Z">
        <seg>&lt;tactics&gt;<it pos="end" x="1">&lt;/g1&gt;</it> (혹은 <bpt i="2" x="2">&lt;g2&gt;</bpt>· &lt;tactics&gt;<ept i="2">&lt;/g2&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A
number of identities in Lean's library have been tagged with the
<bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept> attribute, and the <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> tactic uses them to iteratively
rewrite subterms in an expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161005Z" creationid="tlqk35" creationdate="20220524T161005Z">
        <seg>Lean의 라이브러리 속 다수의 항등식은 <bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept> 속성으로 표식되었습니다.
그리고 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> 전략은 이들을 표현식에서 부분항 다시쓰기로 반복적으로 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A calculation can be viewed as a proof as well, and these systems,
too, help establish mathematical claims.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131354Z" creationid="tlqk35" creationdate="20220321T131354Z">
        <seg>계산도 증명의 관점으로 볼 수 있으며 이런 시스템들도 수학적 진술을 세우는데 도움을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A calculational proof is just a chain of intermediate results that are
meant to be composed by basic principles such as the transitivity of
equality.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180241Z" creationid="tlqk35" creationdate="20220321T180241Z">
        <seg>계산 증명은 동등의 전달성과 같은 기본 원리로 구성된 것을 의미하는 중간 단계의 결과를 연결할 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A canonical example is the type <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> of
natural numbers:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154042Z" creationid="tlqk3" creationdate="20220527T154042Z">
        <seg>표준 예제는 자연수의 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A common idiom is to simplify a goal using local hypotheses:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T163538Z" creationid="tlqk35" creationdate="20220524T163538Z">
        <seg>흔한 관용구는 국부 가정을 사용해 목표를 단순화하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A constructor with multiple arguments introduces
conjunctive information: from an element <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept> of
<bpt i="6" x="6">&lt;g6&gt;</bpt>Prod α β<ept i="6">&lt;/g6&gt;</ept> we can extract <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept> <bpt i="8" x="8">&lt;g8&gt;</bpt>and<ept i="8">&lt;/g8&gt;</ept> <bpt i="9" x="9">&lt;g9&gt;</bpt>b<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160547Z" creationid="tlqk3" creationdate="20220526T160136Z">
        <seg>다수의 인수들이 있는 생성자는 결합적인 정보를 가져옵니다. <bpt i="6" x="6">&lt;g6&gt;</bpt>Prod α β<ept i="6">&lt;/g6&gt;</ept>의 원소  <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept>으로부터 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept><bpt i="8" x="8">&lt;g8&gt;</bpt>그리고<ept i="8">&lt;/g8&gt;</ept><bpt i="9" x="9">&lt;g9&gt;</bpt>b<ept i="9">&lt;/g9&gt;</ept>를 뽑아낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A disadvantage is that Lean does not have enough
information to infer the types of the arguments in the expressions
<bpt i="3" x="3">&lt;g3&gt;</bpt>trans_r<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>trans_r hab<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174331Z" creationid="tlqk35" creationdate="20220321T174331Z">
        <seg>단점은 린이 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>trans_r<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>trans_r hab<ept i="4">&lt;/g4&gt;</ept>에서 인자의 유형을 추론하기에 충분한 정보가 없다는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A first guess might be
<bpt i="4" x="4">&lt;g4&gt;</bpt>Type → α → list α → list α<ept i="4">&lt;/g4&gt;</ept>, but, on reflection, this does not make
sense: the <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept> in this expression does not refer to anything,
whereas it should refer to the argument of type <bpt i="6" x="6">&lt;g6&gt;</bpt>Type<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151344Z" creationid="tlqk35" creationdate="20220321T151344Z">
        <seg>첫 번째 추측은 <bpt i="4" x="4">&lt;g4&gt;</bpt>Type → α → list α → list α<ept i="4">&lt;/g4&gt;</ept>일지 모릅니다. 그러나 생각해보면 이는 말이 되지 않습니다. 이 식에서 <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept>는 어떤 것도 지칭하지 않으므로 <bpt i="6" x="6">&lt;g6&gt;</bpt>Type<ept i="6">&lt;/g6&gt;</ept> 유형을 인수로 지칭해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A first thought might be to
use the <bpt i="10" x="10">&lt;g10&gt;</bpt>casesOn<ept i="10">&lt;/g10&gt;</ept> function:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175820Z" creationid="tlqk3" creationdate="20220603T175820Z">
        <seg>첫 고려사항은 <bpt i="10" x="10">&lt;g10&gt;</bpt>casesOn<ept i="10">&lt;/g10&gt;</ept> 함수를 사용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A heartbeat is the number of
(small) memory allocations (in thousands), 0 means there is no limit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180827Z" creationid="tlqk3" creationdate="20220604T180827Z">
        <seg>심박수는 (작은) 메모리 할당(천 단위)의 수이고, 0은 제한이 없음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A list of elements of type <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> is either the empty list, <bpt i="2" x="2">&lt;g2&gt;</bpt>nil<ept i="2">&lt;/g2&gt;</ept>, or
an element <bpt i="3" x="3">&lt;g3&gt;</bpt>h : α<ept i="3">&lt;/g3&gt;</ept> followed by a list <bpt i="4" x="4">&lt;g4&gt;</bpt>t : List α<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163137Z" creationid="tlqk3" creationdate="20220527T163137Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>형 원소의 리스트는 빈 리스트 <bpt i="2" x="2">&lt;g2&gt;</bpt>nil<ept i="2">&lt;/g2&gt;</ept>이거나 리스트 <bpt i="4" x="4">&lt;g4&gt;</bpt>t : List α<ept i="4">&lt;/g4&gt;</ept>의 다음의 원소 <bpt i="3" x="3">&lt;g3&gt;</bpt>h : α<ept i="3">&lt;/g3&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A more exotic example is given by the definition of the equality type in Lean:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153402Z" creationid="tlqk35" creationdate="20220528T153402Z">
        <seg>더 특이한 예제는 린의 동등성 유형의 정의에 의해 제시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A more interesting example of structural recursion is given by the Fibonacci function <bpt i="1" x="1">&lt;g1&gt;</bpt>fib<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173634Z" creationid="tlqk3" creationdate="20220529T173634Z">
        <seg>구조적 재귀의 더 흥미로운 예제는 피보나치 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>fib<ept i="1">&lt;/g1&gt;</ept>로부터 제시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A mutual inductive definition can also be used to define the notation
of a finite tree with nodes labelled by elements of <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T165627Z" creationid="tlqk35" creationdate="20220528T165627Z">
        <seg>상호적 재귀 정의는 노드가 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>의 원소로 색인된 유한 트리의 기호를 정의하는데도 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A placeholder with precedence <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>
accepts only notations with precedence at least <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept> in that place.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122822Z" creationid="tlqk3" creationdate="20220526T122822Z">
        <seg>우선순위가 <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>인 자리차지자는 오직 그 자리에 적어도 <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept> 순위인 기호만을 받아들입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A proof of
<bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> is then simply an object <bpt i="3" x="3">&lt;g3&gt;</bpt>t : p<ept i="3">&lt;/g3&gt;</ept> of the right type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155903Z" creationid="tlqk35" creationdate="20220321T155903Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>의 증명은 단순히 <bpt i="3" x="3">&lt;g3&gt;</bpt>t : p<ept i="3">&lt;/g3&gt;</ept> 오른쪽 유형의 객체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184300Z" creationid="tlqk35" creationdate="20220321T184300Z">
        <seg>증명 항는 수학적 증명의 표현입니다. 전술은 그러한 증명를 구축하는 방법을 설명하는 명령 또는 지침입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A sequencing combinator is already implicit in the <bpt i="2" x="2">&lt;g2&gt;</bpt>by<ept i="2">&lt;/g2&gt;</ept> block:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145725Z" creationid="tlqk35" creationdate="20220524T145725Z">
        <seg>순차 조합자는 <bpt i="2" x="2">&lt;g2&gt;</bpt>by<ept i="2">&lt;/g2&gt;</ept> 블럭에 이미 암시적으로 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>A type, like <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod<ept i="1">&lt;/g1&gt;</ept>, that has only one constructor is purely
conjunctive: the constructor simply packs the list of arguments into a
single piece of data, essentially a tuple where the type of subsequent
arguments can depend on the type of the initial argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T160903Z" creationid="tlqk3" creationdate="20220526T160903Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod<ept i="1">&lt;/g1&gt;</ept> 같이 한 생성자만 갖고 있는 유형은 순수하게 결합적입니다. 생성자는 단순히 인수 리스트를 하나의 데이터 조각으로 뭉칩니다. 본질적으로 순차적인 인수들의 유형인 튜플은 초기 인수의 유형에 의존할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>About Lean</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131709Z" creationid="tlqk35" creationdate="20220321T131709Z">
        <seg>린에 대해서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>About this Book</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131959Z" creationid="tlqk35" creationdate="20220321T131959Z">
        <seg>이 책에 대하여</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>According to
its definition, <bpt i="2" x="2">&lt;g2&gt;</bpt>Acc r x<ept i="2">&lt;/g2&gt;</ept> is equivalent to
<bpt i="3" x="3">&lt;g3&gt;</bpt>∀ y, r y x → Acc r y<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T174000Z" creationid="tlqk3" creationdate="20220529T174000Z">
        <seg>이것의 정의에 따르면 <bpt i="2" x="2">&lt;g2&gt;</bpt>Acc r x<ept i="2">&lt;/g2&gt;</ept>는 <bpt i="3" x="3">&lt;g3&gt;</bpt>∀ y, r y x → Acc r y<ept i="3">&lt;/g3&gt;</ept>과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135000Z" creationid="tlqk35" creationdate="20220321T135000Z">
        <seg>감사의 말</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Actually, Lean compiles the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expressions using a definition based on
<bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.rec<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154402Z" creationid="tlqk35" creationdate="20220528T154402Z">
        <seg>실제로, 린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식을 <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.rec<ept i="2">&lt;/g2&gt;</ept>에 기반한 정의를 사용해 컴파일합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Actually, the definition above is expanded to</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162811Z" creationid="tlqk3" creationdate="20220529T162811Z">
        <seg>실제로 위 정의는 다음과 같이 확장됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Add support for hiding lines in other languages <bpt i="1" x="1">&lt;g1&gt;</bpt>#1339<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171831Z" creationid="tlqk35" creationdate="20220321T171831Z">
        <seg>다른 언어 <bpt i="1" x="1">&lt;g1&gt;</bpt>#1339<ept i="1">&lt;/g1&gt;</ept>에서 선을 숨기는 것의 지원을 추가하기.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding such extra information can improve the clarity of a proof and
help detect errors when writing a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161105Z" creationid="tlqk35" creationdate="20220321T161105Z">
        <seg>그런 추가 정보를 더하는 것은 증명의 명확성을 개선하고 증명을 작성할 때 오류를 감지하도록 돕습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Adding the <bpt i="1" x="1">&lt;g1&gt;</bpt>local<ept i="1">&lt;/g1&gt;</ept>
modifier restricts the scope:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183259Z" creationid="tlqk3" creationdate="20220525T183259Z">
        <seg>범위를 제한하기 위해 <bpt i="1" x="1">&lt;g1&gt;</bpt>local<ept i="1">&lt;/g1&gt;</ept> 수정자를 추가하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the first two lines, we have <bpt i="1" x="1">&lt;g1&gt;</bpt>h : m &lt; n ∨ m ≥ n<ept i="1">&lt;/g1&gt;</ept> as a
hypothesis, and we simply do cases on that.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171140Z" creationid="tlqk3" creationdate="20220527T171140Z">
        <seg>첫 두 줄 이후에 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>h : m &lt; n ∨ m ≥ n<ept i="1">&lt;/g1&gt;</ept>을 가정으로 갖습니다. 그리고 우리는 단순히 이에 대해 경우를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>After the initial command name describing the operator kind (its
"fixity"), we give the <bpt i="1" x="1">&lt;g1&gt;</bpt>parsing precedence<ept i="1">&lt;/g1&gt;</ept> of the operator preceded
by a colon <bpt i="2" x="2">&lt;g2&gt;</bpt>:<ept i="2">&lt;/g2&gt;</ept>, then a new or existing token surrounded by double
quotes (the whitespace is used for pretty printing), then the function
this operator should be translated to after the arrow <bpt i="3" x="3">&lt;g3&gt;</bpt>=&gt;<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122055Z" creationid="tlqk3" creationdate="20220526T122055Z">
        <seg>연산자 종류를 설명하는 초기 명령 이름 뒤에 (해당 "결합위치"), 콜론 <bpt i="2" x="2">&lt;g2&gt;</bpt>:<ept i="2">&lt;/g2&gt;</ept>으로 앞서는 연산자의  <bpt i="1" x="1">&lt;g1&gt;</bpt>구문분석 우선순위<ept i="1">&lt;/g1&gt;</ept>를 줍니다. 그 뒤 새로운 혹은 존재하는 토큰(깔끔한 출력을 위해 공백기호가 사용됨)은 큰 따옴표로 둘러쌓입니다. 그러면 이 연산자의 기능은 뒤따르는 화살표 <bpt i="3" x="3">&lt;g3&gt;</bpt>=&gt;<ept i="3">&lt;/g3&gt;</ept>로 번역되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Algorithmically speaking, the <bpt i="3" x="3">&lt;g3&gt;</bpt>Decidable<ept i="3">&lt;/g3&gt;</ept> type class can
be used to infer a procedure that effectively determines whether or
not the proposition is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171745Z" creationid="tlqk3" creationdate="20220604T171745Z">
        <seg>알고리즘적으로 말하자면 <bpt i="3" x="3">&lt;g3&gt;</bpt>Decidable<ept i="3">&lt;/g3&gt;</ept> 유형 클래스는 명제가 참인지 여부를 효과적으로 결정하는 절차를 추론하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All that has changed are the braces around <bpt i="1" x="1">&lt;g1&gt;</bpt>α : Type u<ept i="1">&lt;/g1&gt;</ept> in the
declaration of the variables.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153209Z" creationid="tlqk35" creationdate="20220321T153209Z">
        <seg>바뀐 것이라곤 변수 선언에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>α : Type u<ept i="1">&lt;/g1&gt;</ept> 주위의 괄호뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All the examples of pattern matching we considered in
:numref:<bpt i="1" x="1">&lt;g1&gt;</bpt>pattern_matching<ept i="1">&lt;/g1&gt;</ept> can easily be written using <bpt i="2" x="2">&lt;g2&gt;</bpt>cases_on<ept i="2">&lt;/g2&gt;</ept>
and <bpt i="3" x="3">&lt;g3&gt;</bpt>rec_on<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175350Z" creationid="tlqk3" creationdate="20220603T175350Z">
        <seg>패턴 매칭의 모든 예제로부터 우리는 :numref:<bpt i="1" x="1">&lt;g1&gt;</bpt>패턴 매칭<ept i="1">&lt;/g1&gt;</ept>에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>cases_on<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>rec_on<ept i="3">&lt;/g3&gt;</ept>를 사용해 쉽게 쓸 수 있음을 고려했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All this is also available to rewrite an hypothesis <bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept> from the local context using <bpt i="2" x="2">&lt;g2&gt;</bpt>conv at h<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183515Z" creationid="tlqk3" creationdate="20220604T183515Z">
        <seg>이 모든 것은 <bpt i="2" x="2">&lt;g2&gt;</bpt>conv at h<ept i="2">&lt;/g2&gt;</ept>를 사용하여 지역 상황에서 가정 <bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept>를 다시쓰기 하는 데에도 이용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>All you need to do is to provide a
label, and <bpt i="7" x="7">&lt;g7&gt;</bpt>generalize<ept i="7">&lt;/g7&gt;</ept> uses it to store the assignment in the local
context:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065819Z" creationid="tlqk35" creationdate="20220522T065819Z">
        <seg>여러분이 해야할 것은 레이블을 제공하는 것과 <bpt i="7" x="7">&lt;g7&gt;</bpt>generalize<ept i="7">&lt;/g7&gt;</ept>가 그 레이블을 지역 상황에 할당물을 저장하는데 사용하도록 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Alternatively, you can
define tactic blocks usind curly braces and semicolons.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145218Z" creationid="tlqk35" creationdate="20220524T145218Z">
        <seg>대신 여러분은 전략 블럭을 중괄호와 세미콜론을 사용해 전략 블록을 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although the names of theorems and definitions have to be unique, the
aliases that identify them do not.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180325Z" creationid="tlqk35" creationdate="20220524T180059Z">
        <seg>로 확장됩니다. 정리와 정의의 이름은 고유하여야 함에도 별명은 그들을 식별하는 별명은 그렇지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Although we love this feature and use it extensively when implementing Lean,
we realize some users may feel uncomfortable with it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134917Z" creationid="tlqk3" creationdate="20220526T134917Z">
        <seg>우리가 이 기능을 좋아하고 린을 구현할 때 광범위하게 이를 사용했지만 우리는 어떤 사용자들이 이것에 대해 불편하게 느끼는 것을 깨달았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An
element of <bpt i="4" x="4">&lt;g4&gt;</bpt>Option β<ept i="4">&lt;/g4&gt;</ept> is either <bpt i="5" x="5">&lt;g5&gt;</bpt>none<ept i="5">&lt;/g5&gt;</ept> or of the form <bpt i="6" x="6">&lt;g6&gt;</bpt>some b<ept i="6">&lt;/g6&gt;</ept>,
for some value <bpt i="7" x="7">&lt;g7&gt;</bpt>b : β<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T150327Z" creationid="tlqk3" creationdate="20220527T150327Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>Option β<ept i="4">&lt;/g4&gt;</ept>의 원소는 <bpt i="5" x="5">&lt;g5&gt;</bpt>none<ept i="5">&lt;/g5&gt;</ept>이거나 어떤 값 <bpt i="7" x="7">&lt;g7&gt;</bpt>b : β<ept i="7">&lt;/g7&gt;</ept>에 대한 <bpt i="6" x="6">&lt;g6&gt;</bpt>some b<ept i="6">&lt;/g6&gt;</ept>꼴 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An "axiom" would be a
constant of such a type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154916Z" creationid="tlqk35" creationdate="20220321T154916Z">
        <seg>"공리"는 그러한 유형의 상수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An arbitrary inductive type can
include both features, by having any number of constructors, each of
which takes any number of arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152027Z" creationid="tlqk3" creationdate="20220526T160235Z">
        <seg>임의의 귀납형은 다수의 생성자를 갖거나 각각이 다수의 인수를 받게 함으로써 양쪽의 특징을 모두 포함할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element of <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited α<ept i="1">&lt;/g1&gt;</ept> is simply a witness to the fact that
there is an element of <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151406Z" creationid="tlqk3" creationdate="20220527T150730Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited α<ept i="1">&lt;/g1&gt;</ept>의 원소는 단지 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>의 원소가 있다는 사실에 대한 증인입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An element of the class <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited a<ept i="1">&lt;/g1&gt;</ept> is simply an expression of the form <bpt i="2" x="2">&lt;g2&gt;</bpt>Inhabited.mk x<ept i="2">&lt;/g2&gt;</ept>, for some element <bpt i="3" x="3">&lt;g3&gt;</bpt>x : a<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160235Z" creationid="tlqk3" creationdate="20220604T160235Z">
        <seg>클래스 <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited a<ept i="1">&lt;/g1&gt;</ept>의 원소는 단순히 어떤 원소 <bpt i="3" x="3">&lt;g3&gt;</bpt>x : a<ept i="3">&lt;/g3&gt;</ept>에 대한 <bpt i="2" x="2">&lt;g2&gt;</bpt>Inhabited.mk x<ept i="2">&lt;/g2&gt;</ept>꼴의 표현식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An expression like <bpt i="2" x="2">&lt;g2&gt;</bpt>id<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>List.nil<ept i="3">&lt;/g3&gt;</ept> is
said to be <bpt i="4" x="4">&lt;g4&gt;</bpt>polymorphic<ept i="4">&lt;/g4&gt;</ept>, because it can take on different meanings in
different contexts.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153452Z" creationid="tlqk35" creationdate="20220321T153452Z">
        <seg>다른 맥락에서 다른 의미를 가질 수 있기 때문에 <bpt i="2" x="2">&lt;g2&gt;</bpt>id<ept i="2">&lt;/g2&gt;</ept> 나 <bpt i="3" x="3">&lt;g3&gt;</bpt>List.nil<ept i="3">&lt;/g3&gt;</ept> 같은 표현식을 <bpt i="4" x="4">&lt;g4&gt;</bpt>다형적<ept i="4">&lt;/g4&gt;</ept>이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>An inductive family is an indexed family of types defined by a
simultaneous induction of the following form:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152145Z" creationid="tlqk35" creationdate="20220528T152723Z">
        <seg>귀납군은 다음 형태를 따르는 동시 재귀로 정의되는 유형의 색인된 군입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162058Z" creationid="tlqk35" creationdate="20220321T162058Z">
        <seg>논리곱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And, indeed,
we do: the standard library defines <bpt i="7" x="7">&lt;g7&gt;</bpt>WellFounded.fix<ept i="7">&lt;/g7&gt;</ept>, which serves
exactly that purpose.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T175108Z" creationid="tlqk3" creationdate="20220529T174953Z">
        <seg>그리고 물론 우리는 이를 갖습니다. 표준 라이브러리는 바로 그 목적을 담당하는 <bpt i="7" x="7">&lt;g7&gt;</bpt>WellFounded.fix<ept i="7">&lt;/g7&gt;</ept>를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>And, indeed, it does:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143641Z" creationid="tlqk35" creationdate="20220321T143641Z">
        <seg>그리고 당연히 그럽니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another good example of a recursive definition is the list <bpt i="1" x="1">&lt;g1&gt;</bpt>append<ept i="1">&lt;/g1&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165213Z" creationid="tlqk3" creationdate="20220603T165213Z">
        <seg>재귀적 정의의 또 다른 좋은 예제는 리스트 <bpt i="1" x="1">&lt;g1&gt;</bpt>append<ept i="1">&lt;/g1&gt;</ept> 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Another tactic that is sometimes useful is the <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept> tactic,
which is, in a sense, an inverse to <bpt i="2" x="2">&lt;g2&gt;</bpt>intro<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063942Z" creationid="tlqk35" creationdate="20220522T063942Z">
        <seg>때떄로 유용한 또 다른 전략은 <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="2" x="2">&lt;g2&gt;</bpt>intro<ept i="2">&lt;/g2&gt;</ept>의 역방향 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Any text between <bpt i="1" x="1">&lt;g1&gt;</bpt>/-<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>-/<ept i="2">&lt;/g2&gt;</ept> constitutes a comment block that is
ignored by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135531Z" creationid="tlqk35" creationdate="20220321T135531Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>/-<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>-/<ept i="2">&lt;/g2&gt;</ept> 사이의 모든 글은 린에게 무시하라고 가리키는 주석을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Application can be
viewed as an "elimination rule," showing how to "eliminate" or use an
implication in a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162433Z" creationid="tlqk35" creationdate="20220321T162433Z">
        <seg>적용은 어떻게 "제거"하는지 증명에서 함의를 사용하는지를 보여주는 "제거 규칙"으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying
it again yields <bpt i="6" x="6">&lt;g6&gt;</bpt>succ (succ zero) : Nat<ept i="6">&lt;/g6&gt;</ept>, and so on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154310Z" creationid="tlqk3" creationdate="20220527T154310Z">
        <seg>이를 다시 적용하여 <bpt i="6" x="6">&lt;g6&gt;</bpt>succ (succ zero) : Nat<ept i="6">&lt;/g6&gt;</ept>을 얻습니다. 그리고 계속됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying it to <bpt i="4" x="4">&lt;g4&gt;</bpt>zero<ept i="4">&lt;/g4&gt;</ept> yields <bpt i="5" x="5">&lt;g5&gt;</bpt>succ zero : Nat<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154246Z" creationid="tlqk3" creationdate="20220527T154246Z">
        <seg>이를 <bpt i="4" x="4">&lt;g4&gt;</bpt>zero<ept i="4">&lt;/g4&gt;</ept>에 적용하여<bpt i="5" x="5">&lt;g5&gt;</bpt>succ zero : Nat<ept i="5">&lt;/g5&gt;</ept>을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying the theorem
<bpt i="4" x="4">&lt;g4&gt;</bpt>t1 : p → q → p<ept i="4">&lt;/g4&gt;</ept> to the fact <bpt i="5" x="5">&lt;g5&gt;</bpt>hp : p<ept i="5">&lt;/g5&gt;</ept> that <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept> is true yields the theorem
<bpt i="7" x="7">&lt;g7&gt;</bpt>t1 hp : q → p<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161351Z" creationid="tlqk35" creationdate="20220321T161351Z">
        <seg>정리<bpt i="4" x="4">&lt;g4&gt;</bpt>t1 : p → q → p<ept i="4">&lt;/g4&gt;</ept>를 사실 <bpt i="5" x="5">&lt;g5&gt;</bpt>hp : p<ept i="5">&lt;/g5&gt;</ept>에 적용하는 것은 <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept>가 참임을 정리<bpt i="7" x="7">&lt;g7&gt;</bpt>t1 hp : q → p<ept i="7">&lt;/g7&gt;</ept>을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Applying this to the "hypothesis" <bpt i="4" x="4">&lt;g4&gt;</bpt>hab : r a b<ept i="4">&lt;/g4&gt;</ept>, we get a proof
of the implication <bpt i="5" x="5">&lt;g5&gt;</bpt>r b c → r a c<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174050Z" creationid="tlqk35" creationdate="20220321T174050Z">
        <seg>이를 "가정"  <bpt i="4" x="4">&lt;g4&gt;</bpt>hab : r a b<ept i="4">&lt;/g4&gt;</ept>에 적용함으로써 우리는 함의 <bpt i="5" x="5">&lt;g5&gt;</bpt>r b c → r a c<ept i="5">&lt;/g5&gt;</ept>의 증명을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Architectures like SMT ("satisfiability
modulo theories") combine domain-general search methods with domain-specific procedures.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131338Z" creationid="tlqk35" creationdate="20220321T131338Z">
        <seg>SMT(Satisfiability Modulo Theories)같은 구조는 영역-일반 탐색법을 영역-특정 절차와 결합했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a
result, we can also prove the theorem as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180525Z" creationid="tlqk35" creationdate="20220321T180525Z">
        <seg>결론적으로 다음과 같이 정리를 증명할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a convenience, pattern-matching has been integrated into tactics such as <bpt i="1" x="1">&lt;g1&gt;</bpt>intro<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>funext<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172409Z" creationid="tlqk3" creationdate="20220527T172409Z">
        <seg>편리하기에 패턴 매칭은 <bpt i="1" x="1">&lt;g1&gt;</bpt>intro<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>funext<ept i="2">&lt;/g2&gt;</ept> 같은 전략에 합쳐졌습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a final example, we observe that Ackermann's function can be
defined directly, because it is justified by the well foundedness of
the lexicographic order on the natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172925Z" creationid="tlqk3" creationdate="20220603T172925Z">
        <seg>마지막 예제로 우리는 Ackermann 함수가 직접적으로 정의되는 것을 관찰합니다. 왜냐하면 이것은 자연수에 대해 사전적 순서로 잘 세워짐으로 정당활 될 수 있기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a first example, let us prove example
<bpt i="1" x="1">&lt;g1&gt;</bpt>(a b c : Nat) : a * (b * c) = a * (c * b)<ept i="1">&lt;/g1&gt;</ept>
(examples in this file are somewhat artificial since
other tactics could finish them immediately).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182230Z" creationid="tlqk3" creationdate="20220604T182230Z">
        <seg>첫 번째 예로서 <bpt i="1" x="1">&lt;g1&gt;</bpt>(a b c : Nat) : a * (b * c) = a * (c * b)<ept i="1">&lt;/g1&gt;</ept> 예제를 증명해 봅시다. (다른 전술로 이 예제를 즉시 끝낼 수 있기에 이것은 다소 인위적입니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a further exercise, we
suggest defining boolean operations <bpt i="1" x="1">&lt;g1&gt;</bpt>and<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>or<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>not<ept i="3">&lt;/g3&gt;</ept> on the
<bpt i="4" x="4">&lt;g4&gt;</bpt>Bool<ept i="4">&lt;/g4&gt;</ept> type, and verifying common identities.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152416Z" creationid="tlqk3" creationdate="20220526T152416Z">
        <seg>추가 연습으로 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Bool<ept i="4">&lt;/g4&gt;</ept>형에 불리언연산 <bpt i="1" x="1">&lt;g1&gt;</bpt>and<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>or<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>not<ept i="3">&lt;/g3&gt;</ept>을 정의하는 것을 제안합니다. 그리고 일반적인 항등식을 확인해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a notational convention, we give the universal quantifier the
widest scope possible, so parentheses are needed to limit the
quantifier over <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept> to the hypothesis in the example above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173738Z" creationid="tlqk35" creationdate="20220321T173738Z">
        <seg>기호 규약으로써 우리는 전칭 한정기호에게 가능한 가장 넓은 범위를 줍니다. 그래서 위의 예제에서 가정의 <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>에만 한정사를 제한하도록 괄호가 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, <bpt i="4" x="4">&lt;g4&gt;</bpt>Eq.subst<ept i="4">&lt;/g4&gt;</ept> doesn't always do what you want it
to.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180122Z" creationid="tlqk35" creationdate="20220321T180122Z">
        <seg>그러므로 <bpt i="4" x="4">&lt;g4&gt;</bpt>Eq.subst<ept i="4">&lt;/g4&gt;</ept>은 여러분이 원하는 대로 항상 행하지 못합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, given <bpt i="1" x="1">&lt;g1&gt;</bpt>h : p ∧ q<ept i="1">&lt;/g1&gt;</ept>, we can write <bpt i="2" x="2">&lt;g2&gt;</bpt>h.left<ept i="2">&lt;/g2&gt;</ept> for
<bpt i="3" x="3">&lt;g3&gt;</bpt>And.left h<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>h.right<ept i="4">&lt;/g4&gt;</ept> for <bpt i="5" x="5">&lt;g5&gt;</bpt>And.right h<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163449Z" creationid="tlqk35" creationdate="20220321T163449Z">
        <seg>결과적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>h : p ∧ q<ept i="1">&lt;/g1&gt;</ept>라면 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>h.left<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>And.left h<ept i="3">&lt;/g3&gt;</ept>을 나타내는데 그리고 <bpt i="4" x="4">&lt;g4&gt;</bpt>h.right<ept i="4">&lt;/g4&gt;</ept> 를 <bpt i="5" x="5">&lt;g5&gt;</bpt>And.right h<ept i="5">&lt;/g5&gt;</ept>을 나타내는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, most of the examples we present here
work "out of the box."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173932Z" creationid="tlqk35" creationdate="20220524T173932Z">
        <seg>그 결과 우리가 여기에 소개하는 대부분의 예제는 상식 밖의 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, some nontrivial identities can be proved by
reflexivity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175642Z" creationid="tlqk35" creationdate="20220321T175642Z">
        <seg>결과적으로 어떤 비직관적인 항등식들이 대칭성으로부터 증명됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, the
next argument to the recursor specifies a value for <bpt i="12" x="12">&lt;g12&gt;</bpt>f (succ n)<ept i="12">&lt;/g12&gt;</ept> in
terms of <bpt i="13" x="13">&lt;g13&gt;</bpt>n<ept i="13">&lt;/g13&gt;</ept> and <bpt i="14" x="14">&lt;g14&gt;</bpt>f n<ept i="14">&lt;/g14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155230Z" creationid="tlqk3" creationdate="20220527T155230Z">
        <seg>그 결과 재귀자에 대한 다음 인수는 <bpt i="13" x="13">&lt;g13&gt;</bpt>n<ept i="13">&lt;/g13&gt;</ept>과 <bpt i="14" x="14">&lt;g14&gt;</bpt>f n<ept i="14">&lt;/g14&gt;</ept>에 대해서 <bpt i="12" x="12">&lt;g12&gt;</bpt>f (succ n)<ept i="12">&lt;/g12&gt;</ept>에 대한 값을 명시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, the introduction of the connective
<bpt i="7" x="7">&lt;g7&gt;</bpt>Implies<ept i="7">&lt;/g7&gt;</ept> is entirely redundant: we can use the usual function space
constructor <bpt i="8" x="8">&lt;g8&gt;</bpt>p → q<ept i="8">&lt;/g8&gt;</ept> from dependent type theory as our notion of
implication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155647Z" creationid="tlqk35" creationdate="20220321T155647Z">
        <seg>결과적으로 연결사 <bpt i="7" x="7">&lt;g7&gt;</bpt>Implies<ept i="7">&lt;/g7&gt;</ept>의 도입은 완전히 중복됩니다. 그래서 우리는 의존 유형론의 함의에 대한 개념으로써 종종 함수 공간 생성자<bpt i="8" x="8">&lt;g8&gt;</bpt>p → q<ept i="8">&lt;/g8&gt;</ept>를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a result, the type class supports such
computational definitions when they are possible while at the same
time allowing a smooth transition to the use of classical definitions
and classical reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172056Z" creationid="tlqk3" creationdate="20220604T172056Z">
        <seg>결과적으로 유형 클래스는 그들이 가능할 때 그런 계산적 정의를 지원하는 동시에 고전적 정의와 고전 추론의 사용으로 원활히 넘어가는 것을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As a theorem of propositional logic, what does <bpt i="1" x="1">&lt;g1&gt;</bpt>t2<ept i="1">&lt;/g1&gt;</ept> say?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161756Z" creationid="tlqk35" creationdate="20220321T161756Z">
        <seg>명제 논리의 정리로써 <bpt i="1" x="1">&lt;g1&gt;</bpt>t2<ept i="1">&lt;/g1&gt;</ept>가 말하는 것은 무엇인가요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an example, the following settings yield much longer output:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130037Z" creationid="tlqk3" creationdate="20220526T130037Z">
        <seg>예제로 다음 설정은 훨씬 더 긴 출력을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, prove the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163244Z" creationid="tlqk3" creationdate="20220527T163244Z">
        <seg>연습으로 다음을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, try defining default instances for other types, such as <bpt i="1" x="1">&lt;g1&gt;</bpt>List<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Sum<ept i="2">&lt;/g2&gt;</ept> types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161618Z" creationid="tlqk3" creationdate="20220604T161618Z">
        <seg>연습으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>List<ept i="1">&lt;/g1&gt;</ept>형과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Sum<ept i="2">&lt;/g2&gt;</ept>형 같은 다른 유형에 대한 기본 개체를 정의해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, try to understand
why the definition of <bpt i="12" x="12">&lt;g12&gt;</bpt>foo<ept i="12">&lt;/g12&gt;</ept> below type checks, but the definition of
<bpt i="13" x="13">&lt;g13&gt;</bpt>bar<ept i="13">&lt;/g13&gt;</ept> does not.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145104Z" creationid="tlqk35" creationdate="20220321T145104Z">
        <seg>연습으로 아래 유형 확인에서 <bpt i="12" x="12">&lt;g12&gt;</bpt>foo<ept i="12">&lt;/g12&gt;</ept>의 정의가 왜 그런지 그러나  <bpt i="13" x="13">&lt;g13&gt;</bpt>bar<ept i="13">&lt;/g13&gt;</ept>의 정의는 그렇지 않은지 이해하려고 해 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, you might
try proving the converse, that is, showing that <bpt i="5" x="5">&lt;g5&gt;</bpt>em<ept i="5">&lt;/g5&gt;</ept> can be proved
from <bpt i="6" x="6">&lt;g6&gt;</bpt>dne<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165907Z" creationid="tlqk35" creationdate="20220321T165846Z">
        <seg>연습으로 여러분은 역을 증명해보세요, 즉 <bpt i="5" x="5">&lt;g5&gt;</bpt>em<ept i="5">&lt;/g5&gt;</ept>이 <bpt i="6" x="6">&lt;g6&gt;</bpt>dne<ept i="6">&lt;/g6&gt;</ept>로부터 증명될 수 있음을 보이세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As an exercise, you should think about what the introduction and
elimination rules for these types do.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152259Z" creationid="tlqk3" creationdate="20220526T152259Z">
        <seg>연습으로 여러분은 이 유형들에 대한 도입과 제거 규칙이 하는 것에 대해 생각해봐야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As another example, here is how we can express the fact that a relation, <bpt i="1" x="1">&lt;g1&gt;</bpt>r<ept i="1">&lt;/g1&gt;</ept>, is transitive:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173951Z" creationid="tlqk35" creationdate="20220321T173951Z">
        <seg>또 다른 예제처럼 여기서 관계 <bpt i="1" x="1">&lt;g1&gt;</bpt>r<ept i="1">&lt;/g1&gt;</ept>이 추이적이라는 사실을 어떻게 표현할지를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As another example, let us consider the composition function discussed
in the last chapter, now with propositions instead of types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161738Z" creationid="tlqk35" creationdate="20220321T161738Z">
        <seg>또 다른 예로써 지금은 유형 대신 명제로 지난 장에서 논한 합성함수를 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As before, the recursor for <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> is designed to define a dependent
function <bpt i="2" x="2">&lt;g2&gt;</bpt>f<ept i="2">&lt;/g2&gt;</ept> from <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept> to any domain, that is, an element <bpt i="4" x="4">&lt;g4&gt;</bpt>f<ept i="4">&lt;/g4&gt;</ept>
of <bpt i="5" x="5">&lt;g5&gt;</bpt>(n : nat) → motive n<ept i="5">&lt;/g5&gt;</ept> for some <bpt i="6" x="6">&lt;g6&gt;</bpt>motive : Nat → Sort u<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154854Z" creationid="tlqk3" creationdate="20220527T154854Z">
        <seg>전처럼 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>에 대한 재귀자는 의존함수 <bpt i="2" x="2">&lt;g2&gt;</bpt>f<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept>에서 임의의 영역으로 정의하도록 설계되었습니다. 즉,  어떤 <bpt i="6" x="6">&lt;g6&gt;</bpt>motive : Nat → Sort u<ept i="6">&lt;/g6&gt;</ept>에 대해 <bpt i="5" x="5">&lt;g5&gt;</bpt>(n : nat) → motive n<ept i="5">&lt;/g5&gt;</ept>의 원소가 <bpt i="4" x="4">&lt;g4&gt;</bpt>f<ept i="4">&lt;/g4&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As described in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Inductive Types<ept i="1">&lt;/g1&gt;</ept>,
inductive data types can depend on parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163609Z" creationid="tlqk3" creationdate="20220529T163609Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>재귀형 장<ept i="1">&lt;/g1&gt;</ept>에서 설명했다시피 재귀 데이터형은 매개변수에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As exercises, we encourage you to develop a notion of composition for
partial functions from <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>γ<ept i="4">&lt;/g4&gt;</ept>, and show
that it behaves as expected.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151124Z" creationid="tlqk3" creationdate="20220527T151124Z">
        <seg>연습으로 우리는 여러분이 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>에서<bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept>까지 그리고 <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>γ<ept i="4">&lt;/g4&gt;</ept>까지 부분 함수에 대한 합성의 개념을 만들도록 권장합니다. 그리고 그것이 기대한 바처럼 행동하는 것을 보여주세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As expected, the expression <bpt i="1" x="1">&lt;g1&gt;</bpt>(fun x : Nat =&gt;  x) 1<ept i="1">&lt;/g1&gt;</ept> has type <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143602Z" creationid="tlqk35" creationdate="20220321T143602Z">
        <seg>예상했다시피 표현식<bpt i="1" x="1">&lt;g1&gt;</bpt>(fun x : Nat =&gt; x) 1<ept i="1">&lt;/g1&gt;</ept> 은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept> 유형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As in Lean 3, the notation is activated using parentheses, and the lambda abstraction is created by collecting the nested <bpt i="1" x="1">&lt;g1&gt;</bpt>·<ept i="1">&lt;/g1&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140247Z" creationid="tlqk3" creationdate="20220526T140247Z">
        <seg>린 3에서처럼 표기는 괄호를 사용해 활성화되고 람다 추상화는 중첩된 <bpt i="1" x="1">&lt;g1&gt;</bpt>·<ept i="1">&lt;/g1&gt;</ept>의 모음으로 만들어집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As mentioned above, the <bpt i="1" x="1">&lt;g1&gt;</bpt>notation<ept i="1">&lt;/g1&gt;</ept> command allows us to define
arbitrary <bpt i="2" x="2">&lt;g2&gt;</bpt>mixfix<ept i="2">&lt;/g2&gt;</ept> syntax freely mixing tokens and placeholders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123756Z" creationid="tlqk3" creationdate="20220526T123756Z">
        <seg>위에서 언급한 대로, <bpt i="1" x="1">&lt;g1&gt;</bpt>notation<ept i="1">&lt;/g1&gt;</ept> 명령은 우리가 임의의 자유롭게 토큰과 자리차지자를 혼합한 <bpt i="2" x="2">&lt;g2&gt;</bpt>mixfix<ept i="2">&lt;/g2&gt;</ept> 문법을 정의하도록 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As noted above, the type class instances in a given context represent
a Prolog-like program, which gives rise to a backtracking search.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181125Z" creationid="tlqk3" creationdate="20220604T181125Z">
        <seg>위에서 언급했듯이 주어진 상황의 유형 클래스 개체는 역추적 검색을 발생시키는 Prolog와 유사한 프로그램을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As observed above, the induction principle is just a special case of the recursion principle,
when the codomain <bpt i="2" x="2">&lt;g2&gt;</bpt>motive n<ept i="2">&lt;/g2&gt;</ept> is an element of <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160920Z" creationid="tlqk3" creationdate="20220527T160920Z">
        <seg>위에서 봤듯이 공동역역 <bpt i="2" x="2">&lt;g2&gt;</bpt>motive n<ept i="2">&lt;/g2&gt;</ept>이 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>의 원소일 때 귀납 원리는 재귀 원리의 특별한 경우일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> tactic is a command for constructing function
applications interactively, the <bpt i="2" x="2">&lt;g2&gt;</bpt>intro<ept i="2">&lt;/g2&gt;</ept> tactic is a command for
constructing function abstractions interactively (i.e., terms of the
form <bpt i="3" x="3">&lt;g3&gt;</bpt>fun x =&gt; e<ept i="3">&lt;/g3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062425Z" creationid="tlqk35" creationdate="20220522T062425Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> 전략이 함수의 활용을 상호작용으로 만드는 명령인 것처럼 
<bpt i="2" x="2">&lt;g2&gt;</bpt>intro<ept i="2">&lt;/g2&gt;</ept> 전략은 상호작용 방식으로 함수 추상화를 만드는 명령입니다. 
(예, <bpt i="3" x="3">&lt;g3&gt;</bpt>fun x =&gt; e<ept i="3">&lt;/g3&gt;</ept>꼴의 항들).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the example above suggests, you have already seen an example of a function of type
<bpt i="1" x="1">&lt;g1&gt;</bpt>Type → Type → Type<ept i="1">&lt;/g1&gt;</ept>, namely, the Cartesian product <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141444Z" creationid="tlqk35" creationdate="20220321T141444Z">
        <seg>위 예에서 제안한 것처럼 여러분은 이미 주로 카테시안 곱 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>Type → Type → Type<ept i="1">&lt;/g1&gt;</ept> 유형의 함수의 예를 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As the second example shows, the <bpt i="1" x="1">&lt;g1&gt;</bpt>contradiction<ept i="1">&lt;/g1&gt;</ept> tactic also detects contradictions of this form.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T173201Z" creationid="tlqk3" creationdate="20220527T173201Z">
        <seg>두 번째 예제가 보여주다시피 <bpt i="1" x="1">&lt;g1&gt;</bpt>contradiction<ept i="1">&lt;/g1&gt;</ept> 전략도 이 형태의 모순을 감지합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As usual, the constructors are kept in a namespace that is named after the type being defined, and the command <bpt i="4" x="4">&lt;g4&gt;</bpt>open even odd<ept i="4">&lt;/g4&gt;</ept> allows us to access them move conveniently.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174833Z" creationid="tlqk3" creationdate="20220603T174833Z">
        <seg>평소처럼, 생성자는 유형이 정의된 이름을 딴 이름공간에 남아있고, 명령  <bpt i="4" x="4">&lt;g4&gt;</bpt>open even odd<ept i="4">&lt;/g4&gt;</ept>는 우리가 그들에게 더 편리하게 접근하도록 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As usual, you can avoid the prefix <bpt i="1" x="1">&lt;g1&gt;</bpt>Point<ept i="1">&lt;/g1&gt;</ept> by using
the command <bpt i="2" x="2">&lt;g2&gt;</bpt>open Point<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174304Z" creationid="tlqk35" creationdate="20220528T174304Z">
        <seg>평소처럼 여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>open Point<ept i="2">&lt;/g2&gt;</ept>명령을 사용해 접두사 <bpt i="1" x="1">&lt;g1&gt;</bpt>Point<ept i="1">&lt;/g1&gt;</ept>를 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As was the case for implication, the propositions-as-types
interpretation now comes into play.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173005Z" creationid="tlqk35" creationdate="20220321T173005Z">
        <seg>함의의 경우 때와 같이 유형으로써 명제 해석은 이제 제 역할을 하기 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As we
have seen, a pattern is either a variable, a constructor applied to
other patterns, or an expression that normalizes to something of that
form (where the non-constructors are marked with the <bpt i="7" x="7">&lt;g7&gt;</bpt>[matchPattern]<ept i="7">&lt;/g7&gt;</ept>
attribute).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171023Z" creationid="tlqk3" creationdate="20220529T171023Z">
        <seg>우리가 봤던 것처럼 패턴은 생성자가 다른 패턴을 적용한 변수이거나 그 형태를 무언가로 정규화한 표현식입니다. (여기서 비생성자는 <bpt i="7" x="7">&lt;g7&gt;</bpt>[matchPattern]<ept i="7">&lt;/g7&gt;</ept> 속성으로 표시되었습니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As we mentioned above, the argument <bpt i="1" x="1">&lt;g1&gt;</bpt>{n : Nat}<ept i="1">&lt;/g1&gt;</ept> is part of the
pattern matching, because it cannot be held fixed throughout the
definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T150906Z" creationid="tlqk3" creationdate="20220604T150906Z">
        <seg>위에서 언급했듯이 인수 <bpt i="1" x="1">&lt;g1&gt;</bpt>{n : Nat}<ept i="1">&lt;/g1&gt;</ept>은 패턴 매칭의 일부입니다. 왜냐하면 이것은 정의 전체에 대해 고정될 수 없기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As we saw in the last section, the terms <bpt i="1" x="1">&lt;g1&gt;</bpt>t₁, ..., tₙ<ept i="1">&lt;/g1&gt;</ept> can make use
of any of the parameters <bpt i="2" x="2">&lt;g2&gt;</bpt>a<ept i="2">&lt;/g2&gt;</ept>, as well as any of the variables that
are introduced in the corresponding patterns.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171859Z" creationid="tlqk3" creationdate="20220529T171859Z">
        <seg>우리가 지난 섹션에서 보았듯이, 항 <bpt i="1" x="1">&lt;g1&gt;</bpt>t₁, ..., tₙ<ept i="1">&lt;/g1&gt;</ept>은 대응되는 패턴에서 도입된 임의의 변수 뿐만 아니라 임의의 매개변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>a<ept i="2">&lt;/g2&gt;</ept>를 사용할 수 있게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As we will discuss further in
<bpt i="1" x="1">&lt;g1&gt;</bpt>Attributes<ept i="1">&lt;/g1&gt;</ept>, one can limit the scope of an attribute to the
current file or section using the <bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> modifier:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171536Z" creationid="tlqk35" creationdate="20220524T165401Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Attributes<ept i="1">&lt;/g1&gt;</ept>에서 더 논의할 것이지만 누군가는 <bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> 수정자를 
사용해 특성의 범위를 현재 파일이나 섹션으로 제한할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept>, you can leave the type implicit by writing <bpt i="2" x="2">&lt;g2&gt;</bpt>let a
:= 3 * 2<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144507Z" creationid="tlqk35" creationdate="20220524T144507Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept>처럼 여러분은  <bpt i="2" x="2">&lt;g2&gt;</bpt>let a:= 3 * 2<ept i="2">&lt;/g2&gt;</ept>와 같이 작성하여 유형을 암시적으로 정해지게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept>, you can send <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept> a list of facts to use,
including general lemmas, local hypotheses, definitions to unfold, and
compound expressions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T163106Z" creationid="tlqk35" creationdate="20220524T163106Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept>처럼 여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept>를 일반적인 보조정리, 국부적인 가정, 
펼쳐지지 않은 정의와 복합 표현식을 포함한 사실들의 리스트를 사용하도록 보낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>, you can use the keyword <bpt i="2" x="2">&lt;g2&gt;</bpt>at<ept i="2">&lt;/g2&gt;</ept> to simplify a hypothesis:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171814Z" creationid="tlqk35" creationdate="20220524T161708Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>처럼 여러분은 키워드 <bpt i="2" x="2">&lt;g2&gt;</bpt>at<ept i="2">&lt;/g2&gt;</ept>으로 가정을 간단히 하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with definition by pattern matching, parameters to a structural
recursion or induction may appear before the colon.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173445Z" creationid="tlqk3" creationdate="20220529T173445Z">
        <seg>패턴 매칭의 정의에서처럼 구조적 재귀나 귀납에 대한 매개변수는 콜론 앞에 나타날 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with definitions, the <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept> command will show you the proof of
a theorem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161013Z" creationid="tlqk35" creationdate="20220321T161013Z">
        <seg>정의와 마찬가지로 <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept>명령은 정리의 증명을 여러분에게 보여줄 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with function definitions, Lean's inductive definition syntax will
let you put named arguments to the constructors before the colon:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160612Z" creationid="tlqk3" creationdate="20220526T160315Z">
        <seg>함수 정의에서 처럼 린의 유도 정의 문법은 여러분이 이름붙은 인수를 콜론 앞에 생성자에 놓게 할 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with lambda abstraction notation, the
<bpt i="4" x="4">&lt;g4&gt;</bpt>intro<ept i="4">&lt;/g4&gt;</ept> tactic allows us to use an implicit <bpt i="5" x="5">&lt;g5&gt;</bpt>match<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062521Z" creationid="tlqk35" creationdate="20220522T062511Z">
        <seg>람다 추상화 기호처럼 <bpt i="4" x="4">&lt;g4&gt;</bpt>intro<ept i="4">&lt;/g4&gt;</ept> 전략은 암시적인 <bpt i="5" x="5">&lt;g5&gt;</bpt>match<ept i="5">&lt;/g5&gt;</ept>를 쓸 수 있도록 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with ordinary definitions, we can move the lambda-abstracted
variables to the left of the colon:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161130Z" creationid="tlqk35" creationdate="20220321T161130Z">
        <seg>평범한 정의처럼 우리는 람다 추상화된 변수를 콜론의 왼쪽으로 옮길 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with proof terms, you can omit the label in the <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> tactic, in
which case, the default label <bpt i="2" x="2">&lt;g2&gt;</bpt>this<ept i="2">&lt;/g2&gt;</ept> is used:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143904Z" creationid="tlqk35" creationdate="20220524T143904Z">
        <seg>증명항과 마찬가지로 여러분은  <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> 전략 속에 레이블을 생략할 수 있습니다. 그 경우 
기본 레이블로 <bpt i="2" x="2">&lt;g2&gt;</bpt>this<ept i="2">&lt;/g2&gt;</ept>가 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with the
propositional connectives, in systems of natural deduction, "forall"
is governed by an introduction and elimination rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172849Z" creationid="tlqk35" creationdate="20220321T172849Z">
        <seg>명제적 연결사와 마찬가지로 자연 연역에서 "모든"은  도입과 제거 규칙에 지배받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As with the logical connectives, every inductive type comes with
introduction rules, which show how to construct an element of the
type, and elimination rules, which show how to "use" an element of the
type in another construction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151833Z" creationid="tlqk3" creationdate="20220526T144324Z">
        <seg>논리 연결사와 마찬가지로 모든 귀납형은 유형의 원소를 어떻게 생성하는지 보여주는 도입 규칙과 또다른 생성에서 유형의 원소를 어떻게 "사용"하는지 보여주는 제거 규칙을 동반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>As you should by now expect, the library includes both an introduction
rule and an elimination rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180850Z" creationid="tlqk35" creationdate="20220321T180850Z">
        <seg>지금 예상한 대로 라이브러리는 도입 규칙과 소거 규칙 둘 다 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ascii</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162017Z" creationid="tlqk35" creationdate="20220321T161846Z">
        <seg>아스키(Ascii)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Associativity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170134Z" creationid="tlqk35" creationdate="20220321T170134Z">
        <seg>결합성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Assuming that
expression occurs in the goal, the cases tactic will generalize over
the expression, introduce the resulting universally quantified
variable, and case on that.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170049Z" creationid="tlqk3" creationdate="20220527T165926Z">
        <seg>표현식이 목표에서 나타남을 가정하면, cases 전략은 표현식을 일반화하고 결과적으로 보편적으로 정량화된 변수를 도입하고 이에 대한 경우를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At that point, <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept> applies
reflexivity to finish it off.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161449Z" creationid="tlqk35" creationdate="20220524T161228Z">
        <seg>이점에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept>는 이를 끝내는데 반사성을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At this point, we see that we need another supporting fact, namely, that <bpt i="1" x="1">&lt;g1&gt;</bpt>succ (n + m) = succ n + m<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162648Z" creationid="tlqk3" creationdate="20220527T162459Z">
        <seg>이 시점에서 우리는 또다른 지지하는 사실 <bpt i="1" x="1">&lt;g1&gt;</bpt>succ (n + m) = succ n + m<ept i="1">&lt;/g1&gt;</ept>이 필요함을 알게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>At times, you may find that the type class inference fails to find an
expected instance, or, worse, falls into an infinite loop and times
out.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180351Z" creationid="tlqk3" creationdate="20220604T180351Z">
        <seg>때때로 유형 클래스 추론이 예상한 인스턴스를 찾지 못하거나 더 심하게는 무한 루프에 빠져 시간이 초과되는 것을 발견할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Attributes</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181632Z" creationid="tlqk3" creationdate="20220525T181632Z">
        <seg>특성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Auto Bound Implicit Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134129Z" creationid="tlqk3" creationdate="20220526T134129Z">
        <seg>자동적으로 구속된 암시적인 인자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131401Z" creationid="tlqk35" creationdate="20220321T131401Z">
        <seg>자동화된 추론 시스템은 종종 건전성 보장을 희생해서라도 성능과 효율성을 끌어올리기 위해 애쓰고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Axiomatic Details</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T155116Z" creationid="tlqk35" creationdate="20220528T155116Z">
        <seg>공리적 세부사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Axioms and Computation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184902Z" creationid="tlqk3" creationdate="20220604T184902Z">
        <seg>공리와 계산</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic Tactics</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061845Z" creationid="tlqk35" creationdate="20220522T061845Z">
        <seg>기본 전략들</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Basic navigation and rewriting</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182034Z" creationid="tlqk3" creationdate="20220604T182034Z">
        <seg>기본 탐색 및 다시쓰기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Be careful: <bpt i="1" x="1">&lt;g1&gt;</bpt>repeat (try t)<ept i="1">&lt;/g1&gt;</ept> will loop forever, because the inner tactic never fails.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151930Z" creationid="tlqk35" creationdate="20220524T151930Z">
        <seg>조심하세요. <bpt i="1" x="1">&lt;g1&gt;</bpt>repeat (try t)<ept i="1">&lt;/g1&gt;</ept>는 내부 전략은 항상 실패하기 때문에 무한루프를 돌 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Be careful: not
every generalization preserves the validity of the goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065050Z" creationid="tlqk35" creationdate="20220522T065050Z">
        <seg>조심하세요. 모든 일반화가 목표의 유효성을 보존하지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because <bpt i="1" x="1">&lt;g1&gt;</bpt>Or<ept i="1">&lt;/g1&gt;</ept> has two constructors, we cannot use anonymous
constructor notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164120Z" creationid="tlqk35" creationdate="20220321T164120Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Or<ept i="1">&lt;/g1&gt;</ept>은 두 개의 생성자가 있기 때문에 우리는 익명 생성자 표기를 사용할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because addition and the zero notation have been assigned the
<bpt i="1" x="1">&lt;g1&gt;</bpt>[matchPattern]<ept i="1">&lt;/g1&gt;</ept> attribute, they can be used in pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161406Z" creationid="tlqk3" creationdate="20220529T161406Z">
        <seg>왜냐하면 덧셈과 0 기호는 <bpt i="1" x="1">&lt;g1&gt;</bpt>[matchPattern]<ept i="1">&lt;/g1&gt;</ept> 특성이 할당되어 있기에 그들은 패턴 매칭에 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because equational reasoning is so common and important, Lean provides
a number of mechanisms to carry it out more effectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180155Z" creationid="tlqk35" creationdate="20220321T180155Z">
        <seg>방정식적인 추론은 꽤 흔하고 중요하기 때문에 린은 그것을 더 효과적으로 수행하는 다수의 메커니즘을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer
fill in as many of the details as possible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132211Z" creationid="tlqk35" creationdate="20220321T132211Z">
        <seg>완전히 상세한 공리적 증명은 너무 복잡하기 때문에, 증명 보조기의 문제점은 컴퓨터에 가능한 많이 상세한 것들을 두어야 한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Because the constructors are polymorphic over types, we have to insert
the type <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> as an argument repeatedly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152448Z" creationid="tlqk35" creationdate="20220321T152448Z">
        <seg>생성자들이 유형에 대해 다형적이기 때문에, 우리는 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>를 인수로써 반복적으로 삽입해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Behind the scenes, these descriptions are
"compiled" down to primitive recursors, using a procedure that we
refer to as the "equation compiler." The equation compiler is not part
of the trusted code base; its output consists of terms that are
checked independently by the kernel.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160547Z" creationid="tlqk3" creationdate="20220529T160547Z">
        <seg>막의 뒤에서 이 설명은 "방정식 컴파일러"라고 부르는 절차를 사용하여 기초적인 재귀자로 "컴파일되어" 내려갑니다. 방정식 컴파일러는 신뢰받는 코드 기반의 일부가 아닙니다. 그것의 출력은 커널에 의해 독립적으로 검증된 항으로 구성됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Below we will see that Lean's
editor modes can also help you find things you need, but studying the
contents of the library directly is often unavoidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131223Z" creationid="tlqk3" creationdate="20220526T131223Z">
        <seg>아래에서 우리는 린의 편집기 모드는 여러분이 필요한 것을 찾도록 돕는 것을 봅니다. 그러나 라이브러리의 내용을 공부하는 것은 대게 불가피합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both
the efficiency of the program and the solutions that are found can
depend on the order in which the system tries the instance.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181235Z" creationid="tlqk3" creationdate="20220604T181235Z">
        <seg>프로그램의 효율성과 발견된 해결책은 모두 시스템이 개체를 시도하는 순서에 따라 달라질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both expressions denote the type of
functions that take a natural number as input and return a natural
number as output.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140507Z" creationid="tlqk35" creationdate="20220321T140507Z">
        <seg>두 표현식 모두 자연수를 입력으로 받아 자연수를 출력으로 반환하는 함수 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Both versions are
actually notationally convenient abbreviations for a more long-winded
expression, <bpt i="3" x="3">&lt;g3&gt;</bpt>Exists (fun x : α =&gt; p x)<ept i="3">&lt;/g3&gt;</ept>, defined in Lean's library.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180843Z" creationid="tlqk35" creationdate="20220321T180843Z">
        <seg>두 버전 다 린의 라이브러리에 정의된 길고 장황한 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>Exists (fun x : α =&gt; p x)<ept i="3">&lt;/g3&gt;</ept>을 위한 기호적으로 편리한 약어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But
complicated definitions may use several nested <bpt i="2" x="2">&lt;g2&gt;</bpt>casesOn<ept i="2">&lt;/g2&gt;</ept>
applications, and may be hard to read and understand.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160949Z" creationid="tlqk3" creationdate="20220529T160949Z">
        <seg>그러나 복잡해진 정의는 몇 단계로 중첩하여 <bpt i="2" x="2">&lt;g2&gt;</bpt>casesOn<ept i="2">&lt;/g2&gt;</ept>를 사용할 수도 있습니다. 그리고 읽고 이해하기 어렵게 될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But
first, in this chapter, we take a break from the mechanics of type
theory to explore some pragmatic aspects of interacting with Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173156Z" creationid="tlqk35" creationdate="20220524T173121Z">
        <seg>그러나 우선 이 장에서 우리는 유형론의 원리로부터 떨어져서 린과 상호작용하는 것에 대한 실용적인 면을 탐색해봅시다</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But
for straightforward constructions like the one above, when the type of
<bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept> and the goal of the construction are salient, the notation is
clean and effective.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163519Z" creationid="tlqk35" creationdate="20220321T163519Z">
        <seg>위와 같은 간단한 구성의 경우 <bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept>의 유형과 구성의 목표가 두드러질 때 이 표기법은 깨끗하고 효과적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But
these universe levels do have a bearing on the elimination
rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T162734Z" creationid="tlqk35" creationdate="20220528T162505Z">
        <seg>그러나 이 세계 수준은 제거 규칙으로부터 영향을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But
wherever a term is expected, Lean allows us to insert instead a <bpt i="1" x="1">&lt;g1&gt;</bpt>by
&lt;tactics&gt;<ept i="1">&lt;/g1&gt;</ept> block, where <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;tactics&gt;<ept i="2">&lt;/g2&gt;</ept> is a sequence of commands,
separated by semicolons or line breaks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184535Z" creationid="tlqk35" creationdate="20220321T184535Z">
        <seg>그러나 항이 예상되는 어디든지 린은 우리가 <bpt i="2" x="2">&lt;g2&gt;</bpt>by &lt;tactics&gt;<ept i="2">&lt;/g2&gt;</ept> 블록 대신 <bpt i="1" x="1">&lt;g1&gt;</bpt>&lt;tactics&gt;<ept i="1">&lt;/g1&gt;</ept>이 세미콜론이나 줄 분리자로 나눠진 일련의 명령들을 삽입하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept> is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064249Z" creationid="tlqk35" creationdate="20220522T064249Z">
        <seg>그러나 <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept>는 맥락 속 요소들 뿐만 아니라 그에 의존하는 맥락의 뒤에 올 모든 요소를 되돌려 놓는 다는 점에서 아주 영리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But Lean handles
the ambiguity by using the first applicable equation, so in this example
the net result is the same.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164859Z" creationid="tlqk3" creationdate="20220529T164859Z">
        <seg>그러나 린은 활용할 수 있는 첫 방정식을 사용하여 모호성을 해소합니다. 그래서 이 예제에서 최종 결과는 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But because the
notion of an inductive type is so fundamental, we feel it is important
to start with a low-level, hands-on understanding.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151908Z" creationid="tlqk3" creationdate="20220526T144954Z">
        <seg>그러나 귀납형의 개념은 너무 근본적이라 우리는 저수준의 실습 이해부터 시작하는 것이 중요하다고 느낍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But if we use the classical principle,
say, to define a function by cases, that function will not be
computable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171539Z" creationid="tlqk3" creationdate="20220604T171539Z">
        <seg>그러나 우리가 고전 원리를 사용해 경우에 따라 함수를 정의하면 그 함수는 계산 불가일 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But it is very useful for building long proofs
incrementally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170310Z" creationid="tlqk35" creationdate="20220321T170310Z">
        <seg>하지만 이것은 긴 증명을 점진적으로 만들어 나갈 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But notice that we
have to manually disable the implicit arguments in <bpt i="4" x="4">&lt;g4&gt;</bpt>th1<ept i="4">&lt;/g4&gt;</ept>, <bpt i="5" x="5">&lt;g5&gt;</bpt>th2<ept i="5">&lt;/g5&gt;</ept>,
and <bpt i="6" x="6">&lt;g6&gt;</bpt>euclr<ept i="6">&lt;/g6&gt;</ept>, because otherwise too many implicit arguments are
inserted.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T190327Z" creationid="tlqk3" creationdate="20220525T190327Z">
        <seg>하지만 <bpt i="4" x="4">&lt;g4&gt;</bpt>th1<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="5" x="5">&lt;g5&gt;</bpt>th2<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>euclr<ept i="6">&lt;/g6&gt;</ept>에서 암시적인 인수를 수동적으로 이 기능을 해제했음을 보세요. 그렇지 않으면 너무 많은 암시적인 인수가 삽입됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But some commands have other
effects on the environment, either assigning attributes to objects in
the environment, defining notation, or declaring instances of type
classes, as described in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Type Classes<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T182230Z" creationid="tlqk3" creationdate="20220525T182230Z">
        <seg>그러나 환경 속 대상에 특성을 할당하는 것이나  기호를 정의하는 것 또는<bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Type Classes<ept i="1">&lt;/g1&gt;</ept>에서 설명할 유형 클래스의 개체를 선언하는 것으로 몇 가지 명령은 환경에 대해 다른 영향을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But sometimes you will want to leave this information
protected by a fully qualified name, for example, when they conflict
with identifiers in another namespace you want to use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150453Z" creationid="tlqk35" creationdate="20220321T150453Z">
        <seg>그러나 때로는 당신이 사용할 다른 이름공간과 식별자가 충돌할 때 여러분이 이 정보가 완전히 자격을 갖춘 이름으로 보호되길 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But the act of opening a
namespace, which provides shorter names, does not carry over.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130924Z" creationid="tlqk3" creationdate="20220526T130924Z">
        <seg>그러나 더 짧은 이름을 제공하는 이름공간을 여는 동작은 앞에서처럼 다른 파일에 영향을 주지 못합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But the simplifier detects identities that
permute their arguments, and uses a technique known as <bpt i="4" x="4">&lt;g4&gt;</bpt>ordered
rewriting<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171747Z" creationid="tlqk35" creationdate="20220524T162449Z">
        <seg>그러나 단순화기는 항등식들이 그들의 인자를 교환한다는 것을 감지합니다. 
그리고 <bpt i="4" x="4">&lt;g4&gt;</bpt>ordered rewriting<ept i="4">&lt;/g4&gt;</ept>으로 알려진 기법을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But there is
no reason to multiply languages in this way: dependent type theory is
flexible and expressive, and there is no reason we cannot represent
assertions and proofs in the same general framework.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154828Z" creationid="tlqk35" creationdate="20220321T154828Z">
        <seg>그러나 의존유형론은 유연하고 표현력 있어 이런 식으로 언어들을 늘릴 이유는 없습니다. 그리고 주장과 증명은 한 동일한 일반적 프레임워크에서 표현하지 못할 이유도 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But there is a function <bpt i="3" x="3">&lt;g3&gt;</bpt>Int.ofNat<ept i="3">&lt;/g3&gt;</ept> that
embeds the natural numbers in the integers, meaning that we can view
any natural number as an integer, when needed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124714Z" creationid="tlqk3" creationdate="20220526T124605Z">
        <seg>그러나 정수에 자연수가 내장되도록 하는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Int.ofNat<ept i="3">&lt;/g3&gt;</ept> 함수가 있어서 필요할 때 임의의 자연수를 정수로 볼 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But they can also be shorter and easier to
write.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184339Z" creationid="tlqk35" creationdate="20220321T184339Z">
        <seg>그러나 그것들은 더 짧고 더 쓰기 쉬울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But this
transforms the goal into <bpt i="3" x="3">&lt;g3&gt;</bpt>b * c * a = a * (c * b)<ept i="3">&lt;/g3&gt;</ept>, after commuting the
very first multiplication appearing in the term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182352Z" creationid="tlqk3" creationdate="20220604T182352Z">
        <seg>그러나 이것은 항에 나타나는 맨 처음 곱셈을 교환한 뒤 목표를 <bpt i="3" x="3">&lt;g3&gt;</bpt>b * c * a = a * (c * b)<ept i="3">&lt;/g3&gt;</ept>로 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But this fails with a frustrating</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183040Z" creationid="tlqk3" creationdate="20220604T183040Z">
        <seg>그러나 이것은 좌절과 함께 실패합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But this information is
redundant: one can infer the argument <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> in
<bpt i="3" x="3">&lt;g3&gt;</bpt>Lst.cons Nat 5 (Lst.nil Nat)<ept i="3">&lt;/g3&gt;</ept> from the fact that the second argument, <bpt i="4" x="4">&lt;g4&gt;</bpt>5<ept i="4">&lt;/g4&gt;</ept>, has
type <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152522Z" creationid="tlqk35" creationdate="20220321T152522Z">
        <seg>그러나 이 정보는 중복적입니다. <bpt i="3" x="3">&lt;g3&gt;</bpt>Lst.cons Nat 5 (Lst.nil Nat)<ept i="3">&lt;/g3&gt;</ept>에서 두번째 인수 <bpt i="4" x="4">&lt;g4&gt;</bpt>5<ept i="4">&lt;/g4&gt;</ept>가 <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept> 유형을 가진다는 사실로부터 인수 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But using <bpt i="1" x="1">&lt;g1&gt;</bpt>reverse_mk_symm<ept i="1">&lt;/g1&gt;</ept> is generally the right thing to do, and
it would be nice if users did not have to invoke it explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171616Z" creationid="tlqk35" creationdate="20220524T164657Z">
        <seg>하지만 <bpt i="1" x="1">&lt;g1&gt;</bpt>reverse_mk_symm<ept i="1">&lt;/g1&gt;</ept>을 사용하는 것은 일반적으로 해야 하는 것입니다. 그리고 
사용자가 이를 명시적으로 불러올 필요가 없다면 좋을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But using the
type annotations in the longer version makes the proof more readable,
and can help catch and debug errors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164102Z" creationid="tlqk35" creationdate="20220321T164102Z">
        <seg>하지만 더 긴 버전의 유형 주석을 사용하는 것은 증명을 더 가독성있게 하 에러를 잡고 고치는 걸 도와줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But using type class
inference (see <bpt i="2" x="2">&lt;g2&gt;</bpt>Chapter Type Classes<ept i="2">&lt;/g2&gt;</ept>), Lean can actually
find the relevant decision procedure, which means that you can use the
case split in a computable function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171702Z" creationid="tlqk3" creationdate="20220527T171702Z">
        <seg>그러나 유형 클래스 추론을 사용하여 (<bpt i="2" x="2">&lt;g2&gt;</bpt>유형 클래스 장<ept i="2">&lt;/g2&gt;</ept> 참조), 린이 실제로 연관된 결정 절차를 찾을 수 있다. 이 말은 여러분이 셀 수 있는 함수에 대해 경우를 나누는 것이 가능하다는 의미이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But we can prove that <bpt i="1" x="1">&lt;g1&gt;</bpt>certain<ept i="1">&lt;/g1&gt;</ept> propositions are
decidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172923Z" creationid="tlqk3" creationdate="20220604T172923Z">
        <seg>그래도 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>특정<ept i="1">&lt;/g1&gt;</ept> 명제가 결정 가능임을 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But we can still write <bpt i="2" x="2">&lt;g2&gt;</bpt>h.elim<ept i="2">&lt;/g2&gt;</ept> instead of
<bpt i="3" x="3">&lt;g3&gt;</bpt>Or.elim h<ept i="3">&lt;/g3&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164139Z" creationid="tlqk35" creationdate="20220321T164135Z">
        <seg>그러나 우리는 여전히 <bpt i="3" x="3">&lt;g3&gt;</bpt>Or.elim h<ept i="3">&lt;/g3&gt;</ept>대신 <bpt i="2" x="2">&lt;g2&gt;</bpt>h.elim<ept i="2">&lt;/g2&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But we will not need to use such inaccessible patterns
before <bpt i="9" x="9">&lt;g9&gt;</bpt>Section Dependent Pattern Matching<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171645Z" creationid="tlqk3" creationdate="20220529T171645Z">
        <seg>그러나 우리는 <bpt i="9" x="9">&lt;g9&gt;</bpt>의존적인 패턴 매칭 섹션<ept i="9">&lt;/g9&gt;</ept> 전까지 그런 접근할 수 없는 패턴을 사용할 필요는 없을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But what type should <bpt i="3" x="3">&lt;g3&gt;</bpt>cons<ept i="3">&lt;/g3&gt;</ept> have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151314Z" creationid="tlqk35" creationdate="20220321T151314Z">
        <seg>그러나  <bpt i="3" x="3">&lt;g3&gt;</bpt>cons<ept i="3">&lt;/g3&gt;</ept>는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But what value should we return in the <bpt i="1" x="1">&lt;g1&gt;</bpt>nil<ept i="1">&lt;/g1&gt;</ept> case?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175854Z" creationid="tlqk3" creationdate="20220603T175854Z">
        <seg>그러나 <bpt i="1" x="1">&lt;g1&gt;</bpt>nil<ept i="1">&lt;/g1&gt;</ept> 경우에 우리가 돌려줘야 하는 값은 무엇인가요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But you can replace an arbitrary
expression in the goal by a fresh variable using the <bpt i="2" x="2">&lt;g2&gt;</bpt>generalize<ept i="2">&lt;/g2&gt;</ept>
tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064654Z" creationid="tlqk35" creationdate="20220522T064654Z">
        <seg>하지만 여러분은 목표 속 임의의 표현식을 <bpt i="2" x="2">&lt;g2&gt;</bpt>generalize<ept i="2">&lt;/g2&gt;</ept> 전략을 사용해 새 변수로 대체할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But, in fact, a case split is not required on the first argument; the
<bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> eliminator for <bpt i="2" x="2">&lt;g2&gt;</bpt>Vector<ept i="2">&lt;/g2&gt;</ept> automatically abstracts this
argument and replaces it by <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>n + 1<ept i="4">&lt;/g4&gt;</ept> when we do a case
split on the second argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T150511Z" creationid="tlqk3" creationdate="20220604T150321Z">
        <seg>그러나 사실 경우 분할은 첫 번째 인수에 대해 필요하지 않습니다. 두 번째 인수에 대해 경우를 나누었을 때 <bpt i="2" x="2">&lt;g2&gt;</bpt>Vector<ept i="2">&lt;/g2&gt;</ept>를 위한 <bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> 제거자가 자동적으로 이 인수를 추출하고 그것을 <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>n + 1<ept i="4">&lt;/g4&gt;</ept>으로 대체합니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>But, more importantly, equational
reasoning is supported by a term rewriter, a simplifier, and other
kinds of automation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180214Z" creationid="tlqk35" creationdate="20220321T180214Z">
        <seg>그러나 더 중요한 것은 방정식적인 추론은 항 다시쓰기, 단순화, 그리고 여타의 자동화에서도 지원된다는 점 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default,
<bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> includes all theorems that have been marked with the
attribute <bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170118Z" creationid="tlqk35" creationdate="20220524T170118Z">
        <seg>기본적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept> 특성으로 표시한 모든 정리를 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> uses an equation in the forward direction, matching
the left-hand side with an expression, and replacing it with the
right-hand side.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172032Z" creationid="tlqk35" creationdate="20220524T154749Z">
        <seg>기본적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>은 표현식의 좌변과 일치하면 좌변을 우변으로 대체하여 앞방향으로 방정식을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, Lean only tries to synthesize an instance <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited T<ept i="1">&lt;/g1&gt;</ept> when the term <bpt i="2" x="2">&lt;g2&gt;</bpt>T<ept i="2">&lt;/g2&gt;</ept> is known and does not
contain missing parts.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163214Z" creationid="tlqk3" creationdate="20220604T163214Z">
        <seg>항 <bpt i="2" x="2">&lt;g2&gt;</bpt>T<ept i="2">&lt;/g2&gt;</ept>는 알려져 있고 모르는 부분이 없을 때 기본적으로 린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited T<ept i="1">&lt;/g1&gt;</ept> 개체만 합성하려고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, it includes the standard library directory, and (in some contexts)
the root of the user's local project.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174406Z" creationid="tlqk35" creationdate="20220524T174406Z">
        <seg>기본적으로 이는 표준 라이브러리 경로와 (같은 맥락에서) 사용자의 로컬 프로젝트의 루트 경로를 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By default, the <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic affects only the goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171841Z" creationid="tlqk35" creationdate="20220524T160101Z">
        <seg>기본적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> 전략은 목표에만 영향을 미칩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By design, the elements of an inductive type are freely
generated, which is to say, the constructors are injective and have
disjoint ranges.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152129Z" creationid="tlqk3" creationdate="20220527T172827Z">
        <seg>설계하면서 귀납형의 원소는 자유롭게 생성됩니다. 그말은 생성자는 주입적이고 분리된 범위를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By now, you have seen some ways of defining objects and functions in
Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154758Z" creationid="tlqk35" creationdate="20220321T154758Z">
        <seg>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By tagging the instance above with the attribute <bpt i="1" x="1">&lt;g1&gt;</bpt>defaultInstance<ept i="1">&lt;/g1&gt;</ept>, we are instructing Lean
to use this instance on pending type class synthesis problems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165239Z" creationid="tlqk3" creationdate="20220604T165239Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>defaultInstance<ept i="1">&lt;/g1&gt;</ept> 속성으로 위의 개체를 표시함으로써 우리는 린에게 유형 클래스 합성 문제로 보류 중인 이 개체를 사용하라고 가르킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By the above considerations, if <bpt i="3" x="3">&lt;g3&gt;</bpt>r<ept i="3">&lt;/g3&gt;</ept> is a well-founded
relation on a type <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>, we should have a principle of well-founded
recursion on <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept>, with respect to the relation <bpt i="6" x="6">&lt;g6&gt;</bpt>r<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T174959Z" creationid="tlqk3" creationdate="20220529T174926Z">
        <seg>위의 고려로부터 만약 <bpt i="3" x="3">&lt;g3&gt;</bpt>r<ept i="3">&lt;/g3&gt;</ept>이 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>형에 대해 잘 세워진 관계이면, 우리는 관계 <bpt i="6" x="6">&lt;g6&gt;</bpt>r<ept i="6">&lt;/g6&gt;</ept>에 대해서 <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept>에 대해 잘 세워진 재귀의 원리를 가져야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By the end
of this chapter, you will understand much of what this means.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135143Z" creationid="tlqk35" creationdate="20220321T135143Z">
        <seg>2장의 끝에서 여러분은 이것의 의미하는 바의 대부분을 이해하게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By the previous observations,
<bpt i="13" x="13">&lt;g13&gt;</bpt>decide<ept i="13">&lt;/g13&gt;</ept> will succeed any time the inferred decision procedure
for <bpt i="14" x="14">&lt;g14&gt;</bpt>c<ept i="14">&lt;/g14&gt;</ept> has enough information to evaluate, definitionally, to the <bpt i="15" x="15">&lt;g15&gt;</bpt>isTrue<ept i="15">&lt;/g15&gt;</ept> case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T175600Z" creationid="tlqk3" creationdate="20220604T175600Z">
        <seg>전의 관찰로부터 <bpt i="13" x="13">&lt;g13&gt;</bpt>decide<ept i="13">&lt;/g13&gt;</ept>는 <bpt i="14" x="14">&lt;g14&gt;</bpt>c<ept i="14">&lt;/g14&gt;</ept>에 대한 추론된 결정 절차가 <bpt i="15" x="15">&lt;g15&gt;</bpt>isTrue<ept i="15">&lt;/g15&gt;</ept> 사례에 대해 정의로부터 평가하기에 충분한 정보를 가질 때마다 성공할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>By the propositions-as-types correspondence,
this means that induction is the fundamental method of proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160040Z" creationid="tlqk3" creationdate="20220529T160040Z">
        <seg>유형으로써 명제 대응에 따르면 이것은 귀납은 증명의 기초적인 방식임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Calculational Proofs</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180228Z" creationid="tlqk35" creationdate="20220321T180228Z">
        <seg>계산 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Chaining Instances</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160614Z" creationid="tlqk3" creationdate="20220604T160614Z">
        <seg>연결 개체</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Choosing induction on the second argument, we might begin as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162338Z" creationid="tlqk3" creationdate="20220527T162338Z">
        <seg>두 번째 인수에 귀납을 선택하는 것으로 우리는 다음과 같이 시작할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Classical Logic</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165639Z" creationid="tlqk35" creationdate="20220321T165639Z">
        <seg>고전 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Coercions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124417Z" creationid="tlqk3" creationdate="20220526T124329Z">
        <seg>강제 형 변환</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comment blocks can
be nested, making it possible to "comment out" chunks of code, just as
in many programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135553Z" creationid="tlqk35" creationdate="20220321T135553Z">
        <seg>주석 블록은 중첩될 수 있으며 대부분의 프로그래밍 언어처럼 코드 조각을 "주석 처리"할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Comment headers at the top of each file provide
additional information.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131540Z" creationid="tlqk3" creationdate="20220526T131540Z">
        <seg>각 파일의 꼭대기에 도입부 주석은 추가 정보를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Commutativity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170129Z" creationid="tlqk35" creationdate="20220321T170129Z">
        <seg>교환성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Computer algebra systems and
specialized mathematical software packages provide means of carrying out mathematical computations, establishing
mathematical bounds, or finding mathematical objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131347Z" creationid="tlqk35" creationdate="20220321T131347Z">
        <seg>컴퓨터 대수 시스템(CAS, Computer Algebra Systems)과 특정 수학 소프트웨어 패키지는 수학 계산을 수행하고 수학적 한계를 세우며, 수학적 대상을 찾는 수단을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Computers and Theorem Proving</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131055Z" creationid="tlqk35" creationdate="20220321T131055Z">
        <seg>컴퓨터와 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conceptually, stating a theorem or introducing a <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> statement
creates a goal, namely, the goal of constructing a term with the
expected type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185523Z" creationid="tlqk35" creationdate="20220321T184354Z">
        <seg>개념적으로, 정리를 진술하거나 <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> 문장을 도입하는 것은 예상되는 유형으로 항를 생성하는 목표를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conjunction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162506Z" creationid="tlqk35" creationdate="20220321T162506Z">
        <seg>연결사</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider one of the examples from the last section:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164710Z" creationid="tlqk3" creationdate="20220529T164705Z">
        <seg>지난 섹션의 예제 중 하나를 고려해 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the "barber paradox," that is, the claim that in a certain
town there is a (male) barber that shaves all and only the men who
do not shave themselves.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183829Z" creationid="tlqk35" creationdate="20220321T183829Z">
        <seg>"이발사의 역설"을 고려해보세요. 즉, 그들 자신을 면도하지 않는 남자만 면도해 준다고 주장하는 어떤 마을의 (남자) 이발사의 주장입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the definitions of the product type and
sum type in the library:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152848Z" creationid="tlqk3" creationdate="20220526T152848Z">
        <seg>라이브러리에서 곱 유형의 정의와 합 유형의 정의를 고려해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the following
definition of the function <bpt i="1" x="1">&lt;g1&gt;</bpt>Vector.add,<ept i="1">&lt;/g1&gt;</ept> which adds two vectors of
elements of a type, assuming that type has an associated addition
function:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145437Z" creationid="tlqk3" creationdate="20220604T145437Z">
        <seg>유형의 원소의 두 벡터를 더하는 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>Vector.add,<ept i="1">&lt;/g1&gt;</ept>의 다음 정의를 고려해보세요. 그 유형은 연관된 덧셈함수를 가지고 있다고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the following three function definitions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145126Z" creationid="tlqk35" creationdate="20220321T145126Z">
        <seg>다음 세 함수 정의를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the following type of arithmetic expressions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181654Z" creationid="tlqk3" creationdate="20220603T181654Z">
        <seg>다음의 산술적 표현식 유형을 고려하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider the inductively defined type of natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161107Z" creationid="tlqk3" creationdate="20220529T161107Z">
        <seg>자연수의 재귀적으로 정의된 유형을 고려해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Consider, for example, the addition function <bpt i="1" x="1">&lt;g1&gt;</bpt>add m n<ept i="1">&lt;/g1&gt;</ept> on the
natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155946Z" creationid="tlqk3" creationdate="20220527T155946Z">
        <seg>예를 들어 자연수에 대한 추가 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>add m n<ept i="1">&lt;/g1&gt;</ept>을 고려해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Constructing such proofs typically requires much more input and interaction from users, but it
allows you to obtain deeper and more complex proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131511Z" creationid="tlqk35" creationdate="20220321T131511Z">
        <seg>전형적으로 이런 증명을 작성하는 것은 사용자에게 훨씬 많은 입력과 상호작용을 요구합니다. 그러나 이것은 우리가 더 깊고 복잡한 증명을 얻을 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Constructors with Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152605Z" creationid="tlqk3" creationdate="20220526T152605Z">
        <seg>인수를 가지는 생성자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, if you have <bpt i="7" x="7">&lt;g7&gt;</bpt>p : Nat × Nat<ept i="7">&lt;/g7&gt;</ept>, then you can write
<bpt i="8" x="8">&lt;g8&gt;</bpt>p.1 : Nat<ept i="8">&lt;/g8&gt;</ept> and <bpt i="9" x="9">&lt;g9&gt;</bpt>p.2 : Nat<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141208Z" creationid="tlqk35" creationdate="20220321T141208Z">
        <seg>반대로 여러분이 <bpt i="7" x="7">&lt;g7&gt;</bpt>p : Nat × Nat<ept i="7">&lt;/g7&gt;</ept>을 갖고 있다면 <bpt i="8" x="8">&lt;g8&gt;</bpt>p.1 : Nat<ept i="8">&lt;/g8&gt;</ept>과 <bpt i="9" x="9">&lt;g9&gt;</bpt>p.2 : Nat<ept i="9">&lt;/g9&gt;</ept>처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, the <bpt i="4" x="4">&lt;g4&gt;</bpt>cases<ept i="4">&lt;/g4&gt;</ept> tactic can be used to decompose a
disjunction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070342Z" creationid="tlqk35" creationdate="20220522T070342Z">
        <seg>반대로 <bpt i="4" x="4">&lt;g4&gt;</bpt>cases<ept i="4">&lt;/g4&gt;</ept> 전략은 분리자를 분해하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, the proof of a mathematical theorem may require a
lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what
it is supposed to do.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131219Z" creationid="tlqk35" creationdate="20220321T131219Z">
        <seg>반대로 수학적 정리의 증명은 긴 계산이 필요하는데 이 경우 정리의 참을 증명하는 건 계산한 것을 증명하는 걸 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Conversely, when writing an arbitrary Lean term, you can
always invoke the tactic mode by inserting a <bpt i="5" x="5">&lt;g5&gt;</bpt>by<ept i="5">&lt;/g5&gt;</ept>
block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143110Z" creationid="tlqk35" creationdate="20220524T143110Z">
        <seg>반대로 임의의 Lean 항을 작성했다면 <bpt i="5" x="5">&lt;g5&gt;</bpt>by<ept i="5">&lt;/g5&gt;</ept> 블럭을 삽입하는 것으로 
전략모드를 불러올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Creating a function from another expression is a process known as
<bpt i="1" x="1">&lt;g1&gt;</bpt>lambda abstraction<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142243Z" creationid="tlqk35" creationdate="20220321T142243Z">
        <seg>다른 표현식으로부터 함수를 만드는 것은 <bpt i="1" x="1">&lt;g1&gt;</bpt>람다 추상화(lambda abstraction)<ept i="1">&lt;/g1&gt;</ept>과정으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Curly brackets and <bpt i="1" x="1">&lt;g1&gt;</bpt>.<ept i="1">&lt;/g1&gt;</ept> can also be used in <bpt i="2" x="2">&lt;g2&gt;</bpt>conv<ept i="2">&lt;/g2&gt;</ept> mode to structure tactics.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183851Z" creationid="tlqk3" creationdate="20220604T183851Z">
        <seg>중괄호와 <bpt i="1" x="1">&lt;g1&gt;</bpt>.<ept i="1">&lt;/g1&gt;</ept>은 전략을 구조화하기위해 <bpt i="2" x="2">&lt;g2&gt;</bpt>conv<ept i="2">&lt;/g2&gt;</ept> 모드에서도 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Decidable Propositions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171113Z" creationid="tlqk3" creationdate="20220604T171113Z">
        <seg>결정 가능한 명제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring Structures</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173333Z" creationid="tlqk35" creationdate="20220528T173333Z">
        <seg>구조체 선언하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring an "axiom" <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept> is tantamount to declaring that <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>
is true, as witnessed by <bpt i="3" x="3">&lt;g3&gt;</bpt>hp<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161252Z" creationid="tlqk35" creationdate="20220321T161252Z">
        <seg>"공리" <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept>를 선언하는 것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>hp<ept i="3">&lt;/g3&gt;</ept>에서 본 바와 같이 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>가 참이라고 선언하는 것과 마찬가지입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Declaring new objects in this manner is a good way to experiment
with the system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135914Z" creationid="tlqk35" creationdate="20220321T135914Z">
        <seg>이처럼 새로운 대상을 선언하는 것은 시스템을 실험해보는 좋은 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Default instances</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164532Z" creationid="tlqk3" creationdate="20220604T164532Z">
        <seg>기본 개체</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Define an inductive data type consisting of terms built up from the following constructors:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171429Z" creationid="tlqk35" creationdate="20220528T171429Z">
        <seg>다음 생성자로부터 세워진 항으로 구성된 유도 데이터 형을 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Define some operations on lists, like a <bpt i="1" x="1">&lt;g1&gt;</bpt>length<ept i="1">&lt;/g1&gt;</ept> function or the
<bpt i="2" x="2">&lt;g2&gt;</bpt>reverse<ept i="2">&lt;/g2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171334Z" creationid="tlqk35" creationdate="20220528T171334Z">
        <seg>리스트에 대한 <bpt i="1" x="1">&lt;g1&gt;</bpt>length<ept i="1">&lt;/g1&gt;</ept>함수나 <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse<ept i="2">&lt;/g2&gt;</ept> 함수같은 몇 가지 연산을 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Define your own function to carry out course-of-value recursion on
the natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181350Z" creationid="tlqk3" creationdate="20220603T181350Z">
        <seg>자연수에 대해 재귀의 과정(course-of-value recursion)을 수행하는 여러분만의 함수를 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Defining the Natural Numbers</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153647Z" creationid="tlqk3" creationdate="20220527T153647Z">
        <seg>자연수를 정의하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Definition</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161926Z" creationid="tlqk35" creationdate="20220321T161926Z">
        <seg>정의(Definition)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143811Z" creationid="tlqk35" creationdate="20220321T143811Z">
        <seg>정의(Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent Pattern Matching</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175146Z" creationid="tlqk3" creationdate="20220603T175146Z">
        <seg>의존적 패턴 매칭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent Type Theory</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135104Z" creationid="tlqk35" creationdate="20220321T135104Z">
        <seg>의존 유형론</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent products
are also called <bpt i="7" x="7">&lt;g7&gt;</bpt>sigma<ept i="7">&lt;/g7&gt;</ept> types, and you can also write them as
<bpt i="8" x="8">&lt;g8&gt;</bpt>Σ a : α, β a<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152302Z" creationid="tlqk35" creationdate="20220321T152302Z">
        <seg>의존적 곱은 <bpt i="7" x="7">&lt;g7&gt;</bpt>sigma<ept i="7">&lt;/g7&gt;</ept>유형이라고 불립니다. 그리고 여러분은 그것을 <bpt i="8" x="8">&lt;g8&gt;</bpt>Σ a : α, β a<ept i="8">&lt;/g8&gt;</ept>처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent type theory is a powerful and expressive language, allowing
you to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135117Z" creationid="tlqk35" creationdate="20220321T135117Z">
        <seg>의존 유형론은 여러분이 복잡한 수학적 진술을 표현할 수 있게 하고, 복잡한 하드웨어와 소프트웨어 명제를 작성할 수 있게 하며 이 둘에 대해 자연스럽고 일관성있게 추론할 수 있게 하는 강력하고 표현력 있는 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Dependent type theory is powerful enough to encode and justify
well-founded recursion.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173719Z" creationid="tlqk3" creationdate="20220529T173719Z">
        <seg>종속 유형론은 잘 세워진 재귀를 부호화하고 정당화하기에 충분히 강력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Despite the different placement of the parameter <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> in these two
examples, in both cases it treated in the same way, in that it does
not participate in a case split.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164316Z" creationid="tlqk3" creationdate="20220529T164316Z">
        <seg>이 두 예제에서 매개변수 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>의 다른 배치에도 불구하고 두 경우 모두 같은 방식으로 다뤄집니다. 그러므로 이것은 경우 분할에 참여하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Determining that an expression <bpt i="1" x="1">&lt;g1&gt;</bpt>t<ept i="1">&lt;/g1&gt;</ept> is a correct proof of assertion <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> would then
simply be a matter of checking that <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept> has type <bpt i="4" x="4">&lt;g4&gt;</bpt>Proof p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155215Z" creationid="tlqk35" creationdate="20220321T155215Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>t<ept i="1">&lt;/g1&gt;</ept>는 주장 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>의 올바른 증명이다를 결정하는 것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>Proof p<ept i="4">&lt;/g4&gt;</ept>형임을 확인하는 문제가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Disjunction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163542Z" creationid="tlqk35" creationdate="20220321T163542Z">
        <seg>분리자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Displaying Information</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124724Z" creationid="tlqk3" creationdate="20220526T124724Z">
        <seg>정보 표시하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Distributivity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170141Z" creationid="tlqk35" creationdate="20220321T170141Z">
        <seg>분배성:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Double-negation elimination allows one to prove any proposition,
<bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>, by assuming <bpt i="2" x="2">&lt;g2&gt;</bpt>¬p<ept i="2">&lt;/g2&gt;</ept> and deriving <bpt i="3" x="3">&lt;g3&gt;</bpt>false<ept i="3">&lt;/g3&gt;</ept>, because that amounts
to proving <bpt i="4" x="4">&lt;g4&gt;</bpt>¬¬p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165828Z" creationid="tlqk35" creationdate="20220321T165828Z">
        <seg>이중 부정 제거는 여러분에게 어떤 명제  <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>에 대해서 <bpt i="2" x="2">&lt;g2&gt;</bpt>¬p<ept i="2">&lt;/g2&gt;</ept>를 가정하면 <bpt i="4" x="4">&lt;g4&gt;</bpt>¬¬p<ept i="4">&lt;/g4&gt;</ept>의 증명을 고려하기 때문에 <bpt i="3" x="3">&lt;g3&gt;</bpt>false<ept i="3">&lt;/g3&gt;</ept>를 유도할 수 있게 허용해 줍니다.&lt;부분 1098 ¶&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each <bpt i="1" x="1">&lt;g1&gt;</bpt>&lt;proof&gt;_i<ept i="1">&lt;/g1&gt;</ept> is a proof for <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180313Z" creationid="tlqk35" creationdate="20220321T180313Z">
        <seg>각  <bpt i="1" x="1">&lt;g1&gt;</bpt>&lt;proof&gt;_i<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;expr&gt;_{i-1} op_i &lt;expr&gt;_i<ept i="2">&lt;/g2&gt;</ept>에 대한 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each constructor <bpt i="5" x="5">&lt;g5&gt;</bpt>c<ept i="5">&lt;/g5&gt;</ept> in the definition of a family <bpt i="6" x="6">&lt;g6&gt;</bpt>C<ept i="6">&lt;/g6&gt;</ept> of
inductive types is of the form</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152226Z" creationid="tlqk35" creationdate="20220528T160951Z">
        <seg>귀납형의 <bpt i="6" x="6">&lt;g6&gt;</bpt>C<ept i="6">&lt;/g6&gt;</ept> 군의 정의에서 각 생성자 <bpt i="5" x="5">&lt;g5&gt;</bpt>c<ept i="5">&lt;/g5&gt;</ept>는 다음 형태와 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each constructor should have a type, where the
argument types are built up from previously defined types, the
parameter and index types, and the inductive family currently being
defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152204Z" creationid="tlqk35" creationdate="20220528T160242Z">
        <seg>각 생성자는 이전에 정의된 유형, 매개변수와 색인 유형, 현재 정의 중인 귀납군으로 만들어져서 유형을 가져야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each constructor then
constructs an element of some member of the family.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153107Z" creationid="tlqk35" creationdate="20220528T153107Z">
        <seg>그럼 각 생성자는 군의 일부 구성원의 원소를 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each line should
contain the same number of patterns, one for each element of <bpt i="6" x="6">&lt;g6&gt;</bpt>β<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170842Z" creationid="tlqk3" creationdate="20220529T170842Z">
        <seg>각 줄은 <bpt i="6" x="6">&lt;g6&gt;</bpt>β<ept i="6">&lt;/g6&gt;</ept>의 각 원소에 대해 한 개씩 같은 수의 패턴을 포함해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Each style has its own advantages and disadvantages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184324Z" creationid="tlqk35" creationdate="20220321T184324Z">
        <seg>각 스타일은 그것의 장단점을 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Editor shortcut</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162042Z" creationid="tlqk35" creationdate="20220321T161859Z">
        <seg>편집 단축기(Editor shortcut)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ellipses are also useful when explicit argument can be automatically
inferred by Lean, and we want to avoid a sequence of <bpt i="1" x="1">&lt;g1&gt;</bpt>_<ept i="1">&lt;/g1&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T141432Z" creationid="tlqk3" creationdate="20220526T141432Z">
        <seg>Ellipses도 명시적인 인자가 린으로부터 자동적으로 추론될 수 있을 때와 우리가  <bpt i="1" x="1">&lt;g1&gt;</bpt>_<ept i="1">&lt;/g1&gt;</ept>들의 나열을 피하고자 할 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Entering Tactic Mode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184348Z" creationid="tlqk35" creationdate="20220321T184348Z">
        <seg>전략 모드 진입</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerated Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T145134Z" creationid="tlqk3" creationdate="20220526T145134Z">
        <seg>열거 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Enumerated types are a very special case of inductive types, in which
the constructors take no arguments at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152011Z" creationid="tlqk3" creationdate="20220526T152727Z">
        <seg>열거 유형은 귀납형의 아주 특별한 경우 입니다. 이들의 생성자는 인수를 전혀 받지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175300Z" creationid="tlqk35" creationdate="20220321T175300Z">
        <seg>동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Equality is much more than an equivalence relation, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175705Z" creationid="tlqk35" creationdate="20220321T175705Z">
        <seg>하지만 동등은 등가 관계 그 이상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Essentially, it just checks that the
given term has the indicated type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162706Z" creationid="tlqk35" creationdate="20220321T162706Z">
        <seg>본질적으로 어떤 항이 가리키는 유형을 갖는 것을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Essentially, the <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> tactic uses a given equality (which can be a
hypothesis, a theorem name, or a complex term) to "rewrite" the
goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180428Z" creationid="tlqk35" creationdate="20220321T180428Z">
        <seg>본질적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> 전략은 주어진 동등성을 목표(혹은 가정, 정리, 복잡한 항이 될 수도 있음)를 "다시 쓰는데" 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Even the existential quantifier is inductively defined:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T152715Z" creationid="tlqk3" creationdate="20220527T152715Z">
        <seg>심지어 존재 한정기호도 유도적으로 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every
natural number is either <bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept> or <bpt i="2" x="2">&lt;g2&gt;</bpt>succ x<ept i="2">&lt;/g2&gt;</ept>, and so you can define
a function from the natural numbers to an arbitrary type by specifying
a value in each of those cases:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161213Z" creationid="tlqk3" creationdate="20220529T161213Z">
        <seg>모든 자연수는 <bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept>이거나 <bpt i="2" x="2">&lt;g2&gt;</bpt>succ x<ept i="2">&lt;/g2&gt;</ept>입니다. 그래서 여러분은 각 경우에 대한 값을 나타내줌으로써 자연수에서 임의의 유형으로 가는 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> declaration introduces a
namespace with the same name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173625Z" creationid="tlqk35" creationdate="20220528T173625Z">
        <seg>모든 <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> 선언은 같은 이름을 가진 이름공간을 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Every element of a function type <bpt i="1" x="1">&lt;g1&gt;</bpt>α → β<ept i="1">&lt;/g1&gt;</ept> or a
dependent function type <bpt i="2" x="2">&lt;g2&gt;</bpt>(a : α) → β<ept i="2">&lt;/g2&gt;</ept> is assumed to have a value
at every input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T150156Z" creationid="tlqk3" creationdate="20220527T150156Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>α → β<ept i="1">&lt;/g1&gt;</ept>형 함수나 <bpt i="2" x="2">&lt;g2&gt;</bpt>(a : α) → β<ept i="2">&lt;/g2&gt;</ept>형 의존 함수의 모든 원소는 매 입력에 대한 함숫값을 갖는다고 가정됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Examples of Propositional Validities</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170104Z" creationid="tlqk35" creationdate="20220321T170104Z">
        <seg>명제 유효성 예제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Exercises</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170558Z" creationid="tlqk35" creationdate="20220321T170558Z">
        <seg>연습문제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>False</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161944Z" creationid="tlqk35" creationdate="20220321T161944Z">
        <seg>거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Fill in the definitions of <bpt i="2" x="2">&lt;g2&gt;</bpt>prime<ept i="2">&lt;/g2&gt;</ept>
and <bpt i="3" x="3">&lt;g3&gt;</bpt>Fermat_prime<ept i="3">&lt;/g3&gt;</ept> below, and construct each of the given
assertions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183913Z" creationid="tlqk35" creationdate="20220321T183913Z">
        <seg>아래의 <bpt i="2" x="2">&lt;g2&gt;</bpt>prime<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>Fermat_prime<ept i="3">&lt;/g3&gt;</ept>의 정의를 채우세요. 그리고 주어진 주장의 각각을 생성하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally,
we have to show <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165632Z" creationid="tlqk35" creationdate="20220321T165632Z">
        <seg>마지막으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>임을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, applying it to the
hypothesis <bpt i="6" x="6">&lt;g6&gt;</bpt>hbc<ept i="6">&lt;/g6&gt;</ept> yields a proof of the conclusion <bpt i="7" x="7">&lt;g7&gt;</bpt>r a c<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174116Z" creationid="tlqk35" creationdate="20220321T174116Z">
        <seg>마침내, 이것을 가정 <bpt i="6" x="6">&lt;g6&gt;</bpt>hbc<ept i="6">&lt;/g6&gt;</ept>에 적용하는 것으로 결론 <bpt i="7" x="7">&lt;g7&gt;</bpt>r a c<ept i="7">&lt;/g7&gt;</ept>의 증명을 거둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, consider the existential quantifier, which can be written as
either <bpt i="1" x="1">&lt;g1&gt;</bpt>exists x : α, p x<ept i="1">&lt;/g1&gt;</ept> or <bpt i="2" x="2">&lt;g2&gt;</bpt>∃ x : α, p x<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180827Z" creationid="tlqk35" creationdate="20220321T180827Z">
        <seg>마지막으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>exists x : α, p x<ept i="1">&lt;/g1&gt;</ept>나 <bpt i="2" x="2">&lt;g2&gt;</bpt>∃ x : α, p x<ept i="2">&lt;/g2&gt;</ept>으로 쓸 수 있는 존재 한정기호를 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, the <bpt i="5" x="5">&lt;g5&gt;</bpt>t : Nat<ept i="5">&lt;/g5&gt;</ept>, is the input to the function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155737Z" creationid="tlqk3" creationdate="20220527T155737Z">
        <seg>마침내 <bpt i="5" x="5">&lt;g5&gt;</bpt>t : Nat<ept i="5">&lt;/g5&gt;</ept>가 함수에 대한 입력입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, the last step applies
associativity in the reverse direction rewriting <bpt i="6" x="6">&lt;g6&gt;</bpt>a + (c + b)<ept i="6">&lt;/g6&gt;</ept> to
<bpt i="7" x="7">&lt;g7&gt;</bpt>a + c + b<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171939Z" creationid="tlqk35" creationdate="20220524T155726Z">
        <seg>마침내 마지막 단계는 <bpt i="6" x="6">&lt;g6&gt;</bpt>a + (c + b)<ept i="6">&lt;/g6&gt;</ept>에서 <bpt i="7" x="7">&lt;g7&gt;</bpt>a + c + b<ept i="7">&lt;/g7&gt;</ept>으로 다시쓰기를 역방향으로 결합성을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Finally, you will learn about features that are specific to Lean, including the language you use to communicate
with the system, and the mechanisms Lean offers for managing complex theories and data.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134710Z" creationid="tlqk35" creationdate="20220321T134710Z">
        <seg>마지막으로 린에 여러분이 시스템과 소통하기 위해 사용하는 언어와 복잡한 이론과 자료를 관리하기 위해 린이 제공하는 메커니즘을 포함하는 구체적인 특징에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, Lean supports <bpt i="1" x="1">&lt;g1&gt;</bpt>mutually defined<ept i="1">&lt;/g1&gt;</ept> inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152347Z" creationid="tlqk35" creationdate="20220528T165028Z">
        <seg>우선 린은 귀납형의 <bpt i="1" x="1">&lt;g1&gt;</bpt>상호적으로 정의됨(mutually defined)<ept i="1">&lt;/g1&gt;</ept>을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, the application of
a function <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept> to a value <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> is denoted <bpt i="3" x="3">&lt;g3&gt;</bpt>f x<ept i="3">&lt;/g3&gt;</ept> (e.g., <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.succ 2<ept i="4">&lt;/g4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140728Z" creationid="tlqk35" creationdate="20220321T140728Z">
        <seg>우선 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>에 값 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>의 활용은 <bpt i="3" x="3">&lt;g3&gt;</bpt>f x<ept i="3">&lt;/g3&gt;</ept> 를 지칭합니다. (예를 들어 <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.succ 2<ept i="4">&lt;/g4&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>First, we have
to show that it indeed suffices to show <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept>, by proving the original
goal of <bpt i="3" x="3">&lt;g3&gt;</bpt>q ∧ p<ept i="3">&lt;/g3&gt;</ept> with the additional hypothesis <bpt i="4" x="4">&lt;g4&gt;</bpt>hq : q<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165620Z" creationid="tlqk35" creationdate="20220321T165620Z">
        <seg>우선, 우리는 원래 목표<bpt i="2" x="2">&lt;g2&gt;</bpt>q ∧ p<ept i="2">&lt;/g2&gt;</ept> 과 추가적인 가정 <bpt i="4" x="4">&lt;g4&gt;</bpt>hq : q<ept i="4">&lt;/g4&gt;</ept>으로 증명함으로써 <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept>임을 충분히 보일 수 있는 것을 보여야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Fixing <bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept>, we can define addition by recursion on
<bpt i="3" x="3">&lt;g3&gt;</bpt>n<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160027Z" creationid="tlqk3" creationdate="20220527T160027Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept>을 고치면 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>n<ept i="3">&lt;/g3&gt;</ept>에 대한 재귀로부터 덧셈을 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Following the examples in <bpt i="1" x="1">&lt;g1&gt;</bpt>Section Dependent Pattern Matching<ept i="1">&lt;/g1&gt;</ept>,
define a function that will append two vectors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181535Z" creationid="tlqk3" creationdate="20220603T181535Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>종속 패턴 매칭 섹션<ept i="1">&lt;/g1&gt;</ept>의 다음 예제는 벡터에 벡터를 추가하는 함수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
any type, <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, the type <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept> of lists of elements of <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept> is
defined in the library.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162958Z" creationid="tlqk3" creationdate="20220527T162958Z">
        <seg>임의의 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>에 대한 <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept> 원소의 리스트 <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept>형은 라이브러리에 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, <bpt i="6" x="6">&lt;g6&gt;</bpt>a ∧ b → c ∨ d ∧ e<ept i="6">&lt;/g6&gt;</ept> means <bpt i="7" x="7">&lt;g7&gt;</bpt>(a ∧ b) → (c ∨ (d ∧
e))<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162247Z" creationid="tlqk35" creationdate="20220321T162247Z">
        <seg>예를 들어 <bpt i="6" x="6">&lt;g6&gt;</bpt>a ∧ b → c ∨ d ∧ e<ept i="6">&lt;/g6&gt;</ept>은 <bpt i="7" x="7">&lt;g7&gt;</bpt>(a ∧ b) → (c ∨ (d ∧ e))<ept i="7">&lt;/g7&gt;</ept>을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, for the expression <bpt i="4" x="4">&lt;g4&gt;</bpt>if p then a else b<ept i="4">&lt;/g4&gt;</ept> to make sense, we
need to know that <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> is decidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172410Z" creationid="tlqk3" creationdate="20220604T172410Z">
        <seg>예를 들어 표현식 <bpt i="4" x="4">&lt;g4&gt;</bpt>if p then a else b<ept i="4">&lt;/g4&gt;</ept>를 이해하려면 우리는 <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>가 결정 가능인지 알 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, it would be more natural to define the previous example as a
function of two arguments:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162924Z" creationid="tlqk3" creationdate="20220529T162924Z">
        <seg>예를 들어 이전 예제를 두 인수를 받는 함수로 정의하는 것이 더 자연스럽습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184328Z" creationid="tlqk35" creationdate="20220321T184328Z">
        <seg>예를 들어, 전략 스타일의 증명은 독자가 각 명령의 결과를 예측하거나 추측해야 하기 때문에 읽기가 더 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, the following defines a record to store a color as a triple
of RGB values:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T162402Z" creationid="tlqk3" creationdate="20220526T162402Z">
        <seg>예를 들어 다음은 RGB 3개의 값을 갖는 triple로서 색을 저장하는 레코드를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, the product type comes with the following operations:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132815Z" creationid="tlqk3" creationdate="20220526T132815Z">
        <seg>예를들어 곱 유형은 다음 연산을 동반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, the tactic <bpt i="1" x="1">&lt;g1&gt;</bpt>apply And.intro<ept i="1">&lt;/g1&gt;</ept> tagged the first sugoal as
<bpt i="2" x="2">&lt;g2&gt;</bpt>left<ept i="2">&lt;/g2&gt;</ept>, and the second as <bpt i="3" x="3">&lt;g3&gt;</bpt>right<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061050Z" creationid="tlqk35" creationdate="20220522T061050Z">
        <seg>예를 들어, 전략  <bpt i="1" x="1">&lt;g1&gt;</bpt>apply And.intro<ept i="1">&lt;/g1&gt;</ept>는 첫번째 목표를 <bpt i="2" x="2">&lt;g2&gt;</bpt>left<ept i="2">&lt;/g2&gt;</ept>으로
두번째 목표를 <bpt i="3" x="3">&lt;g3&gt;</bpt>right<ept i="3">&lt;/g3&gt;</ept>으로 표식을 붙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, the variable <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept> in the expression <bpt i="5" x="5">&lt;g5&gt;</bpt>fun (b : β) (x : α) =&gt; b<ept i="5">&lt;/g5&gt;</ept>
has nothing to do with the constant <bpt i="6" x="6">&lt;g6&gt;</bpt>b<ept i="6">&lt;/g6&gt;</ept> declared earlier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143414Z" creationid="tlqk35" creationdate="20220321T143414Z">
        <seg>예를 들어 표현식 <bpt i="5" x="5">&lt;g5&gt;</bpt>fun (b : β) (x : α) =&gt; b<ept i="5">&lt;/g5&gt;</ept> 속 변수 <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept>는 앞서 선언된 상수 <bpt i="6" x="6">&lt;g6&gt;</bpt>b<ept i="6">&lt;/g6&gt;</ept>와는 아무런 연관이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For
example, we can use it to postulate the empty type <bpt i="2" x="2">&lt;g2&gt;</bpt>False<ept i="2">&lt;/g2&gt;</ept> has an
element.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161224Z" creationid="tlqk35" creationdate="20220321T161224Z">
        <seg>예를 들어 우리는 그것을 빈 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>False<ept i="2">&lt;/g2&gt;</ept>이 원소를 갖는다고 가정하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, consider the
type <bpt i="5" x="5">&lt;g5&gt;</bpt>Vector α n<ept i="5">&lt;/g5&gt;</ept>, the type of vectors of elements of <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept> of
length <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150928Z" creationid="tlqk35" creationdate="20220321T150928Z">
        <seg>또 다른 예시로 유형 <bpt i="5" x="5">&lt;g5&gt;</bpt>Vector α n<ept i="5">&lt;/g5&gt;</ept>을 고려해보세요. 이 벡터의 유형은 길이 <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>인 <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>를 원소로 하는 리스트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, let us prove the associativity of addition,
<bpt i="1" x="1">&lt;g1&gt;</bpt>∀ m n k, m + n + k = m + (n + k)<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T161843Z" creationid="tlqk3" creationdate="20220527T161843Z">
        <seg>다른 예제에서 덧셈의 결합성 <bpt i="1" x="1">&lt;g1&gt;</bpt>∀ m n k, m + n + k = m + (n + k)<ept i="1">&lt;/g1&gt;</ept>을 증명해 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, suppose we use a nested inductive type to define a set of terms inductively, so that a term is either a constant (with a name given by a string), or the result of applying a constant to a list of constants.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175018Z" creationid="tlqk3" creationdate="20220603T175018Z">
        <seg>또 다른 예제에서 우리가 중접된 귀납형을 재귀적으로 항들의 집합을 정의하고자 사용한다고 합시다. 그러면 항은 (문자열로 이름이 주어진)상수이거나 상수의 리스트에 상수를 적용한 결과입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, we can define the type of binary trees:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163512Z" creationid="tlqk3" creationdate="20220527T163512Z">
        <seg>또 다른 예제로 우리는 이진 트리의 유형을 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For another example, we can use the <bpt i="1" x="1">&lt;g1&gt;</bpt>instance<ept i="1">&lt;/g1&gt;</ept> command to assign the
notation <bpt i="2" x="2">&lt;g2&gt;</bpt>≤<ept i="2">&lt;/g2&gt;</ept> to the <bpt i="3" x="3">&lt;g3&gt;</bpt>isPrefix<ept i="3">&lt;/g3&gt;</ept> relation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183450Z" creationid="tlqk3" creationdate="20220525T183356Z">
        <seg>다른 예제에서 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>instance<ept i="1">&lt;/g1&gt;</ept> 명령을 <bpt i="3" x="3">&lt;g3&gt;</bpt>isPrefix<ept i="3">&lt;/g3&gt;</ept>관계에 <bpt i="2" x="2">&lt;g2&gt;</bpt>≤<ept i="2">&lt;/g2&gt;</ept>기호를 부여하는 데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For each constructor <bpt i="1" x="1">&lt;g1&gt;</bpt>c<ept i="1">&lt;/g1&gt;</ept> as above, and each <bpt i="2" x="2">&lt;g2&gt;</bpt>βk[a]<ept i="2">&lt;/g2&gt;</ept> in the sequence <bpt i="3" x="3">&lt;g3&gt;</bpt>β[a]<ept i="3">&lt;/g3&gt;</ept>, if <bpt i="4" x="4">&lt;g4&gt;</bpt>βk[a] : Sort v<ept i="4">&lt;/g4&gt;</ept>, we have <bpt i="5" x="5">&lt;g5&gt;</bpt>u<ept i="5">&lt;/g5&gt;</ept> ≥ <bpt i="6" x="6">&lt;g6&gt;</bpt>v<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T162047Z" creationid="tlqk35" creationdate="20220528T162047Z">
        <seg>위처럼 각 생성자 <bpt i="1" x="1">&lt;g1&gt;</bpt>c<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>β[a]<ept i="3">&lt;/g3&gt;</ept>열에서 각 <bpt i="2" x="2">&lt;g2&gt;</bpt>βk[a]<ept i="2">&lt;/g2&gt;</ept>에 대해 만약 <bpt i="4" x="4">&lt;g4&gt;</bpt>βk[a] : Sort v<ept i="4">&lt;/g4&gt;</ept>이면 <bpt i="5" x="5">&lt;g5&gt;</bpt>u<ept i="5">&lt;/g5&gt;</ept> ≥ <bpt i="6" x="6">&lt;g6&gt;</bpt>v<ept i="6">&lt;/g6&gt;</ept>이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For each fixed <bpt i="1" x="1">&lt;g1&gt;</bpt>α : Sort u<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>a : α<ept i="2">&lt;/g2&gt;</ept>, this definition
constructs a family of types <bpt i="3" x="3">&lt;g3&gt;</bpt>Eq a x<ept i="3">&lt;/g3&gt;</ept>, indexed by <bpt i="4" x="4">&lt;g4&gt;</bpt>x : α<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153521Z" creationid="tlqk35" creationdate="20220528T153521Z">
        <seg>각 고정된  <bpt i="1" x="1">&lt;g1&gt;</bpt>α : Sort u<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>a : α<ept i="2">&lt;/g2&gt;</ept>에 대해 이 정의는 <bpt i="4" x="4">&lt;g4&gt;</bpt>x : α<ept i="4">&lt;/g4&gt;</ept>으로 색인된 <bpt i="3" x="3">&lt;g3&gt;</bpt>Eq a x<ept i="3">&lt;/g3&gt;</ept>형의 군을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For every <bpt i="4" x="4">&lt;g4&gt;</bpt>p q : Prop<ept i="4">&lt;/g4&gt;</ept>,
<bpt i="5" x="5">&lt;g5&gt;</bpt>p ∧ q<ept i="5">&lt;/g5&gt;</ept> is an example: the canonical way to construct an element is
to apply <bpt i="6" x="6">&lt;g6&gt;</bpt>And.intro<ept i="6">&lt;/g6&gt;</ept> to suitable arguments <bpt i="7" x="7">&lt;g7&gt;</bpt>hp : p<ept i="7">&lt;/g7&gt;</ept> and
<bpt i="8" x="8">&lt;g8&gt;</bpt>hq : q<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163129Z" creationid="tlqk35" creationdate="20220321T163129Z">
        <seg>모든 <bpt i="4" x="4">&lt;g4&gt;</bpt>p q : Prop<ept i="4">&lt;/g4&gt;</ept>에 대해 <bpt i="5" x="5">&lt;g5&gt;</bpt>p ∧ q<ept i="5">&lt;/g5&gt;</ept>가 예제입니다. 원소를 생성하는 정식 방법은 <bpt i="6" x="6">&lt;g6&gt;</bpt>And.intro<ept i="6">&lt;/g6&gt;</ept>를 적절한 인수 <bpt i="7" x="7">&lt;g7&gt;</bpt>hp : p<ept i="7">&lt;/g7&gt;</ept>과 <bpt i="8" x="8">&lt;g8&gt;</bpt>hq : q<ept i="8">&lt;/g8&gt;</ept>에 대해 적용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example,
<bpt i="1" x="1">&lt;g1&gt;</bpt>all_goals t<ept i="1">&lt;/g1&gt;</ept> applies <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept> to all open goals:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T152303Z" creationid="tlqk35" creationdate="20220524T152303Z">
        <seg>예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>all_goals t<ept i="1">&lt;/g1&gt;</ept>는 모든 끝나지 않은 목표에 <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept>를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example,
suppose we declare a structure in Lean to hold implementations of addition</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153142Z" creationid="tlqk3" creationdate="20220604T153142Z">
        <seg>예를 들어 덧셈의 구현을 유지하기 위해 린에 구조체를 선언한다고 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example,
using the hypothesis <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>, it rewrites <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q<ept i="2">&lt;/g2&gt;</ept> to <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>p ∨
q<ept i="4">&lt;/g4&gt;</ept> to <bpt i="5" x="5">&lt;g5&gt;</bpt>true<ept i="5">&lt;/g5&gt;</ept>, which it then proves trivially.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171702Z" creationid="tlqk35" creationdate="20220524T163946Z">
        <seg>예를 들어 가정 <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>를 사용하여 이것은 <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q<ept i="2">&lt;/g2&gt;</ept>을 <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept>으로 그리고 <bpt i="4" x="4">&lt;g4&gt;</bpt>p ∨
q<ept i="4">&lt;/g4&gt;</ept>을 <bpt i="5" x="5">&lt;g5&gt;</bpt>true<ept i="5">&lt;/g5&gt;</ept>으로 다시 쓴다.  그럼 이를 명백하게 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example,
you can declare an (anonymous) instance stating that if <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept> has addition, then <bpt i="6" x="6">&lt;g6&gt;</bpt>Array a<ept i="6">&lt;/g6&gt;</ept>
has addition:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154932Z" creationid="tlqk3" creationdate="20220604T154932Z">
        <seg>예를 들어 여러분이 (익명) 개체를 <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept>가 덧셈을 갖는다면 <bpt i="6" x="6">&lt;g6&gt;</bpt>Array a<ept i="6">&lt;/g6&gt;</ept>도 덧셈을 갖는다고 서술해 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="1" x="1">&lt;g1&gt;</bpt>(+1)<ept i="1">&lt;/g1&gt;</ept> is sugar for <bpt i="2" x="2">&lt;g2&gt;</bpt>fun x, x + 1<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140049Z" creationid="tlqk3" creationdate="20220526T140049Z">
        <seg>예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>(+1)<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>fun x, x + 1<ept i="2">&lt;/g2&gt;</ept>에 대한 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept> should make sense for any type
<bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>, no matter which type universe <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept> lives in.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141914Z" creationid="tlqk35" creationdate="20220321T141914Z">
        <seg>예를 들어 <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>가 어떤 유형 세계에 있던간에 <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept>는 임의의 유형 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>에 대해 의미가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept> can be a hypothesis <bpt i="5" x="5">&lt;g5&gt;</bpt>h : x = y<ept i="5">&lt;/g5&gt;</ept> in the
context; it can be a general lemma, like
<bpt i="6" x="6">&lt;g6&gt;</bpt>add_comm : ∀ x y, x + y = y + x<ept i="6">&lt;/g6&gt;</ept>, in which the rewrite tactic tries to find suitable
instantiations of <bpt i="7" x="7">&lt;g7&gt;</bpt>x<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>y<ept i="8">&lt;/g8&gt;</ept>; or it can be any compound term
asserting a concrete or general equation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172113Z" creationid="tlqk35" creationdate="20220524T153958Z">
        <seg>예를 들어 <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept>는 맥락 속에서 가정 <bpt i="5" x="5">&lt;g5&gt;</bpt>h : x = y<ept i="5">&lt;/g5&gt;</ept>이 될 수 있습니다. 
그것은 <bpt i="6" x="6">&lt;g6&gt;</bpt>add_comm : ∀ x y, x + y = y + x<ept i="6">&lt;/g6&gt;</ept>같은 일반적인 보조정리일 수 있고, 
여기서 다시쓰기 전략은 <bpt i="7" x="7">&lt;g7&gt;</bpt>x<ept i="7">&lt;/g7&gt;</ept>와 <bpt i="8" x="8">&lt;g8&gt;</bpt>y<ept i="8">&lt;/g8&gt;</ept> 적절한 개체화를 발견하려고 노력합니다.
아니면 이것은 일반적인 방정식 혹은 구체적인 방정식을 주장하는 임의의 복합적인 항이 될 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, Lean cannot
find an instance of <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited (Set α)<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180140Z" creationid="tlqk3" creationdate="20220604T180140Z">
        <seg>예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited (Set α)<ept i="1">&lt;/g1&gt;</ept>의 개체를 찾을 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, Lean groups definitions and theorems involving lists into
a namespace <bpt i="1" x="1">&lt;g1&gt;</bpt>List<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150513Z" creationid="tlqk35" creationdate="20220321T150513Z">
        <seg>예를 들어 Lean은 이름공간 <bpt i="1" x="1">&lt;g1&gt;</bpt>List<ept i="1">&lt;/g1&gt;</ept> 속에 리스트를 포함한 정의와 정리를 묶습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept> are types, <bpt i="3" x="3">&lt;g3&gt;</bpt>a -&gt; b<ept i="3">&lt;/g3&gt;</ept>
denotes the type of functions from <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept> to <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept>, and <bpt i="6" x="6">&lt;g6&gt;</bpt>a × b<ept i="6">&lt;/g6&gt;</ept>
denotes the type of pairs consisting of an element of <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept> paired
with an element of <bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>, also known as the <bpt i="9" x="9">&lt;g9&gt;</bpt>Cartesian product<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140041Z" creationid="tlqk35" creationdate="20220321T140041Z">
        <seg>예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept>가 유형이라면 <bpt i="3" x="3">&lt;g3&gt;</bpt>a -&gt; b<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept> 에서 <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept>로 가는 함수 유형을 나타냅니다. 그리고 <bpt i="6" x="6">&lt;g6&gt;</bpt>a × b<ept i="6">&lt;/g6&gt;</ept> 는 <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept>의 원소와 <bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>의 원소로 이뤄진 쌍을 원소로 갖는 유형을 나타냅니다. 이것을 <bpt i="9" x="9">&lt;g9&gt;</bpt>카테시안 곱<ept i="9">&lt;/g9&gt;</ept>이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept> is a type, <bpt i="6" x="6">&lt;g6&gt;</bpt>exists x : a, x = x<ept i="6">&lt;/g6&gt;</ept> is true only if <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept> is not empty.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155621Z" creationid="tlqk3" creationdate="20220604T155621Z">
        <seg>예를 들어 <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept>가 유형이면 <bpt i="6" x="6">&lt;g6&gt;</bpt>exists x : a, x = x<ept i="6">&lt;/g6&gt;</ept>은 <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept>가 비어있지 않을 때에만 참입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, if we have have
<bpt i="4" x="4">&lt;g4&gt;</bpt>hg : g 0 0 = 0<ept i="4">&lt;/g4&gt;</ept> and write <bpt i="5" x="5">&lt;g5&gt;</bpt>Exists.intro 0 hg<ept i="5">&lt;/g5&gt;</ept>, there are many possible values
for the predicate <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept>, corresponding to the theorems <bpt i="7" x="7">&lt;g7&gt;</bpt>∃ x, g x x = x<ept i="7">&lt;/g7&gt;</ept>,
<bpt i="8" x="8">&lt;g8&gt;</bpt>∃ x, g x x = 0<ept i="8">&lt;/g8&gt;</ept>, <bpt i="9" x="9">&lt;g9&gt;</bpt>∃ x, g x 0 = x<ept i="9">&lt;/g9&gt;</ept>, etc.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185510Z" creationid="tlqk35" creationdate="20220321T181101Z">
        <seg>예를 들어 우리가 have <bpt i="4" x="4">&lt;g4&gt;</bpt>hg : g 0 0 = 0<ept i="4">&lt;/g4&gt;</ept>를 갖고 있고 <bpt i="5" x="5">&lt;g5&gt;</bpt>Exists.intro 0 hg<ept i="5">&lt;/g5&gt;</ept>을 썼다면 정리  <bpt i="7" x="7">&lt;g7&gt;</bpt>∃ x, g x x = x<ept i="7">&lt;/g7&gt;</ept>, <bpt i="8" x="8">&lt;g8&gt;</bpt>∃ x, g x x = 0<ept i="8">&lt;/g8&gt;</ept>, <bpt i="9" x="9">&lt;g9&gt;</bpt>∃ x, g x 0 = x<ept i="9">&lt;/g9&gt;</ept> 등에 대응하는 술어 <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept>에 대해 수없이 많은 가능한 값이 존재합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in a given context, <bpt i="2" x="2">&lt;g2&gt;</bpt>x + 0<ept i="2">&lt;/g2&gt;</ept> may
denote a natural number and <bpt i="3" x="3">&lt;g3&gt;</bpt>f<ept i="3">&lt;/g3&gt;</ept> may denote a function on the natural
numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135242Z" creationid="tlqk35" creationdate="20220321T135242Z">
        <seg>예를들어 어떤 맥락에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>x + 0<ept i="2">&lt;/g2&gt;</ept>은 자연수를 가리키고  <bpt i="3" x="3">&lt;g3&gt;</bpt>f<ept i="3">&lt;/g3&gt;</ept>은 자연수에 대한 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, in many proof systems for
propositional logic, we have the rule of modus ponens:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154940Z" creationid="tlqk35" creationdate="20220321T154940Z">
        <seg>예를 들어 명제논리에 대한 많은 증명보조기들은 전건긍정(modus ponens)에 대한 규칙을 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, it allows
you to "partially apply" the function <bpt i="11" x="11">&lt;g11&gt;</bpt>Nat.add<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140858Z" creationid="tlqk35" creationdate="20220321T140858Z">
        <seg>예를 들어 이는 여러분에게 함수 <bpt i="11" x="11">&lt;g11&gt;</bpt>Nat.add<ept i="11">&lt;/g11&gt;</ept>의 "부분 적용"을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, one can
carry out a proof by cases:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165920Z" creationid="tlqk35" creationdate="20220321T165920Z">
        <seg>예를 들어 누군가는 경우를 나눠 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, reverting <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> in the example
above brings <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept> along with it:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064343Z" creationid="tlqk35" creationdate="20220522T064343Z">
        <seg>예를 들어 위의 예제에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>를 되돌려 놓는 것은 그것과 붙은 <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept>를 가져옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, suppose <bpt i="1" x="1">&lt;g1&gt;</bpt>xs<ept i="1">&lt;/g1&gt;</ept> has type <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>, when elaboration <bpt i="3" x="3">&lt;g3&gt;</bpt>xs.map (fun x =&gt; 2 * x)<ept i="3">&lt;/g3&gt;</ept>, we want the homogeneous instance for multiplication
to have higher priority than the default instance for <bpt i="4" x="4">&lt;g4&gt;</bpt>OfNat<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165937Z" creationid="tlqk3" creationdate="20220604T165937Z">
        <seg>예를 들어 <bpt i="3" x="3">&lt;g3&gt;</bpt>xs.map (fun x =&gt; 2 * x)<ept i="3">&lt;/g3&gt;</ept>으로 해석될 때 <bpt i="1" x="1">&lt;g1&gt;</bpt>xs<ept i="1">&lt;/g1&gt;</ept>가 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>형이라고 가정합시다. 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>OfNat<ept i="4">&lt;/g4&gt;</ept>에 대한 기본 개체보다 더 높은 우선 순위를 갖는 곱셈에 대한 동형 개체를 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, suppose we
define a list operation that symmetrizes its input by appending its
reversal:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171633Z" creationid="tlqk35" creationdate="20220524T164342Z">
        <seg>예를 들어 우리가 그것의 입력을 그것의 거꾸로 추가하여 
대칭시키는 리스트 연산을 정의한다고 합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, term rewriting, and Lean's automated methods for simplifying terms and
expressions automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132252Z" creationid="tlqk35" creationdate="20220321T132252Z">
        <seg>예를 들어, 항을 다시 쓰기(rewriting)와 Lean의 자동화된 항과 식의 단순화(simplifying) 기법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the definition of addition may also be written
as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173532Z" creationid="tlqk3" creationdate="20220529T173532Z">
        <seg>예를 들어 덧셈의 정의는 다음과 같이 작성될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following creates the goal of
constructing a term of type <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q ∧ p<ept i="2">&lt;/g2&gt;</ept>, in a context with constants
<bpt i="3" x="3">&lt;g3&gt;</bpt>p q : Prop<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>hp : p<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>hq : q<ept i="5">&lt;/g5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184434Z" creationid="tlqk35" creationdate="20220321T184434Z">
        <seg>예를 들어 , 다음은 <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q ∧ p<ept i="2">&lt;/g2&gt;</ept>형의 항을 상수 <bpt i="3" x="3">&lt;g3&gt;</bpt>p q : Prop<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>hp : p<ept i="4">&lt;/g4&gt;</ept>,<bpt i="5" x="5">&lt;g5&gt;</bpt>hq : q<ept i="5">&lt;/g5&gt;</ept>가 있는 현재 상황에 대해 생성하는 목표를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following definition shows that if two types <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept> are inhabited, then so is their product:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161309Z" creationid="tlqk3" creationdate="20220604T161309Z">
        <seg>예를 들어 다음 정의는 만약 두 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept>가 내재되었다면 그들의 곱도 그렇다는 것을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following implication requires classical
reasoning because, from a constructive standpoint, knowing that it is
not the case that every <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept> satisfies <bpt i="2" x="2">&lt;g2&gt;</bpt>¬ p<ept i="2">&lt;/g2&gt;</ept> is not the same as
having a particular <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept> that satisfies <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183059Z" creationid="tlqk35" creationdate="20220321T183059Z">
        <seg>예를 들어, 직관주의적 관점에서 모든 <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>가 <bpt i="2" x="2">&lt;g2&gt;</bpt>¬p<ept i="2">&lt;/g2&gt;</ept>을 만족하는 경우가 아니라는 것을 아는 것은 <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>를 만족하는 특정 <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept>를 갖는 것과 같지 않기 때문에 다음의 함의는 고전적인 추론을 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the following two expressions mean the same
thing:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163416Z" creationid="tlqk35" creationdate="20220321T163416Z">
        <seg>예를 들어 다음 두 표현식은 같은 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the local variable <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept> occurs
at <bpt i="7" x="7">&lt;g7&gt;</bpt>let rec loop<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182235Z" creationid="tlqk3" creationdate="20220603T182235Z">
        <seg>예를 들어 지역변수 <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept>는 <bpt i="7" x="7">&lt;g7&gt;</bpt>let rec loop<ept i="7">&lt;/g7&gt;</ept>에 나타납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the tactics <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept>
expect arbitrary terms, which you can write using <bpt i="3" x="3">&lt;g3&gt;</bpt>have<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>show<ept i="4">&lt;/g4&gt;</ept>,
and so on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143008Z" creationid="tlqk35" creationdate="20220524T143008Z">
        <seg>예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> 와<bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept> 전략은 
<bpt i="3" x="3">&lt;g3&gt;</bpt>have<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>show<ept i="4">&lt;/g4&gt;</ept> 등등을 사용해 만든 임의의 항을 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, the theorem named <bpt i="1" x="1">&lt;g1&gt;</bpt>le_of_succ_le_succ<ept i="1">&lt;/g1&gt;</ept> in the
namespace <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept> has full name <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.le_of_succ_le_succ<ept i="3">&lt;/g3&gt;</ept>, but the shorter
name is made available by the command <bpt i="4" x="4">&lt;g4&gt;</bpt>open Nat<ept i="4">&lt;/g4&gt;</ept> (for names not marked as
<bpt i="5" x="5">&lt;g5&gt;</bpt>protected<ept i="5">&lt;/g5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132444Z" creationid="tlqk3" creationdate="20220526T132444Z">
        <seg>예를 들어, 정리는 이름공간 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept> 에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>le_of_succ_le_succ<ept i="1">&lt;/g1&gt;</ept>으로 이름지어진 정리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.le_of_succ_le_succ<ept i="3">&lt;/g3&gt;</ept>을 긴 이름으로 갖습니다. 그러나 더 짧은 이름은 <bpt i="4" x="4">&lt;g4&gt;</bpt>open Nat<ept i="4">&lt;/g4&gt;</ept> 명령으로 사용할 수 있게 됩니다.(<bpt i="5" x="5">&lt;g5&gt;</bpt>protected<ept i="5">&lt;/g5&gt;</ept>로 표시된 이름을 제외하고)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, using
the abbreviation <bpt i="3" x="3">&lt;g3&gt;</bpt>rw<ept i="3">&lt;/g3&gt;</ept> for rewrite, the proof above could be written
as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180400Z" creationid="tlqk35" creationdate="20220321T180400Z">
        <seg>예를 들어, 다시쓰기에 대해서 간략히 <bpt i="3" x="3">&lt;g3&gt;</bpt>rw<ept i="3">&lt;/g3&gt;</ept>를 쓰는 것으로 위의 증명은 다음과 같이 다시 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we
use this notation to define "points." The order that the fields are
specified does not matter, so all the expressions below define the
same point.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182304Z" creationid="tlqk35" creationdate="20220528T182304Z">
        <seg>예를 들어 우리는 "점"을 정의하기 위해 이 기호를 사용합니다. 필드가 나타난 순서는 중요하지 않습니다. 그래서 아래의 모든 표현식들은 같은 점을 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we can fill the goals above in the opposite order:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165616Z" creationid="tlqk3" creationdate="20220527T165616Z">
        <seg>예를 들어 우리는 위의 목표를 반대 순서로 채울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we can prove the decidability of basic
operations like equality and comparisons on the natural numbers and
the integers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173008Z" creationid="tlqk3" creationdate="20220604T173008Z">
        <seg>예를 들어 우리는 자연수와 정수에 대한 등식과 부등식 같은 기본 연산의 결정 가능성을 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we can put
the <bpt i="1" x="1">&lt;g1&gt;</bpt>numberOfDay<ept i="1">&lt;/g1&gt;</ept> function in the <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept> namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151057Z" creationid="tlqk3" creationdate="20220526T151057Z">
        <seg>예를 들어, 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept> 이름공간에 <bpt i="1" x="1">&lt;g1&gt;</bpt>numberOfDay<ept i="1">&lt;/g1&gt;</ept>함수를 넣을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, we could introduce a new type, <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>, to represent
propositions, and introduce constructors to build new propositions
from others.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154846Z" creationid="tlqk35" creationdate="20220321T154843Z">
        <seg>예를 들어, 우리는 새로운 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>을 명제를 나타내기 위해 도입할 수 있습니다. 그리고 다른 유형으로부터 새로운 명제를 만드는 생성자를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, when applied to a goal of the form
<bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ q<ept i="1">&lt;/g1&gt;</ept>, you use tactics such as <bpt i="2" x="2">&lt;g2&gt;</bpt>apply Or.inl<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>apply
Or.inr<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070256Z" creationid="tlqk35" creationdate="20220522T070256Z">
        <seg>예를 들어, <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ q<ept i="1">&lt;/g1&gt;</ept>꼴의 목표에 적용했을 때, 여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>apply Or.inl<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>apply
Or.inr<ept i="3">&lt;/g3&gt;</ept> 같은 전략들을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, with the definition of scalar multiplication
below, <bpt i="6" x="6">&lt;g6&gt;</bpt>p.smul 3<ept i="6">&lt;/g6&gt;</ept> is interpreted as <bpt i="7" x="7">&lt;g7&gt;</bpt>Point.smul 3 p<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181659Z" creationid="tlqk35" creationdate="20220528T180528Z">
        <seg>예를 들어 아래의 스칼라 곱의 정의에서 <bpt i="6" x="6">&lt;g6&gt;</bpt>p.smul 3<ept i="6">&lt;/g6&gt;</ept>은 <bpt i="7" x="7">&lt;g7&gt;</bpt>Point.smul 3 p<ept i="7">&lt;/g7&gt;</ept>으로 해석됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can say that there are infinitely many
primes by asserting that for every natural number <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>, there is a
prime number greater than <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183935Z" creationid="tlqk35" creationdate="20220321T183935Z">
        <seg>예를 들어, 여러분은 모든 자연수 <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>에 대해 <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept>보다 큰 소수가 있다고 주장하여 무한히 많은 소수가 있다고 말할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example, you can use <bpt i="4" x="4">&lt;g4&gt;</bpt>cases<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>constructor<ept i="5">&lt;/g5&gt;</ept> with an existential quantifier:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071910Z" creationid="tlqk35" creationdate="20220522T071910Z">
        <seg>예를 들어, 여러분은<bpt i="4" x="4">&lt;g4&gt;</bpt>cases<ept i="4">&lt;/g4&gt;</ept>와 <bpt i="5" x="5">&lt;g5&gt;</bpt>constructor<ept i="5">&lt;/g5&gt;</ept>을 존재 정량자와 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144651Z" creationid="tlqk35" creationdate="20220321T144651Z">
        <seg>예를 들어</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For now, notice that
this is an important feature of dependent type theory: every term has
a computational behavior, and supports a notion of <bpt i="1" x="1">&lt;g1&gt;</bpt>normalization<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143711Z" creationid="tlqk35" creationdate="20220321T143711Z">
        <seg>현재로써는 이게 의존 유형론의 중요한 특징인 것만 알아 두세요. 모든 항은 전산적 거동을 하고 <bpt i="1" x="1">&lt;g1&gt;</bpt>정규화(normalization)<ept i="1">&lt;/g1&gt;</ept>의 개념을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For one thing, <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> allows
you to choose the names for each alternative using a
<bpt i="2" x="2">&lt;g2&gt;</bpt>with<ept i="2">&lt;/g2&gt;</ept> clause.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164330Z" creationid="tlqk3" creationdate="20220527T164330Z">
        <seg>한 가지에 대해, <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept>는 여러분이 <bpt i="2" x="2">&lt;g2&gt;</bpt>with<ept i="2">&lt;/g2&gt;</ept> 절을 사용하여 각 대안에 대한 이름을 선택할 수 있도록 허용합니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For operations that are commutative and associative, like
multiplication on the natural numbers, the simplifier uses these two
facts to rewrite an expression, as well as <bpt i="1" x="1">&lt;g1&gt;</bpt>left commutativity<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171801Z" creationid="tlqk35" creationdate="20220524T161932Z">
        <seg>자연수 곱셈 같은 교환성과 결합성 연산자와 왼쪽 교환성과 
마찬가지로 단순화기는 표현식을 다시 쓰는데 이 두 사실을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For reference, here are two sample proofs of validities taken from the
list above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170519Z" creationid="tlqk35" creationdate="20220321T170519Z">
        <seg>참고로 여기 위쪽의 리스트에서 가져온 유효성의 증명 예시가 두 개 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For simple sugoals, it may not be worth selecting a subgoal using its
tag, but you may still want to structure the proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061653Z" creationid="tlqk35" creationdate="20220522T061653Z">
        <seg>간단한 하위목표에 대해 그것의 표식을 이용해 하위목표를 선택하는 것은 불필요할 수 있지만
그래도 여러분은 여전히 증명을 구조화하길 원할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For structures containing many fields, this is often
inconvenient, because we have to remember the order in which the
fields were defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182011Z" creationid="tlqk35" creationdate="20220528T182011Z">
        <seg>많은 필드를 포함한 구조체에 대해 우리는 필드가 정의된 순서를 기억해야만 하기 때문에 이것은 종종 불편합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that purpose, Lean provides the notion of
a <bpt i="1" x="1">&lt;g1&gt;</bpt>section<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150040Z" creationid="tlqk35" creationdate="20220321T150040Z">
        <seg>이를 위해 Lean은  <bpt i="1" x="1">&lt;g1&gt;</bpt>section<ept i="1">&lt;/g1&gt;</ept>의 개념을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that reason, it
is common to make these arguments implicit:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174219Z" creationid="tlqk35" creationdate="20220321T174219Z">
        <seg>이런 이유로 이런 인자를 암시적으로 만드는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For that to be the case, each of them also has to have a
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141327Z" creationid="tlqk35" creationdate="20220321T141327Z">
        <seg>이렇게 하는 경우에 대해 그들 각각은 유형을 가져야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For theorem names,
we rely on descriptive names where the different components are separated
by <bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept>s.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132029Z" creationid="tlqk3" creationdate="20220526T132029Z">
        <seg>정리 이름에 대해, 우리는 다른 부분은 <bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept>들로 나뉜 설명하는 이름에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>For those who like precise definitions, a Lean natural number
is an arbitrary-precision unsigned integer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135255Z" creationid="tlqk35" creationdate="20220321T135255Z">
        <seg>엄밀한 정의를 좋아하는 이들에게 린의 자연수는 부호없는 임의 정밀도의 정수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Formally, expressions that are the same up to a renaming of bound
variables are called <bpt i="1" x="1">&lt;g1&gt;</bpt>alpha equivalent<ept i="1">&lt;/g1&gt;</ept>, and are considered "the
same." Lean recognizes this equivalence.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143446Z" creationid="tlqk35" creationdate="20220321T143446Z">
        <seg>공식적으로 구속 변수의 이름이 바뀌기까지 같은 표현식은 <bpt i="1" x="1">&lt;g1&gt;</bpt>알파 등가(alpha equivalent)<ept i="1">&lt;/g1&gt;</ept>라 하고 "같은" 것으로 생각합니다. 린도 이를 등가로 인식합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From a proof of <bpt i="1" x="1">&lt;g1&gt;</bpt>Implies p q<ept i="1">&lt;/g1&gt;</ept> and a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>, we obtain a proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155000Z" creationid="tlqk35" creationdate="20220321T155000Z">
        <seg>증명 <bpt i="1" x="1">&lt;g1&gt;</bpt>Implies p q<ept i="1">&lt;/g1&gt;</ept>과 증명<bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>으로부터 우리는 증명 <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept>을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>From the
constructive point of view, proofs are abstract mathematical objects
that are <bpt i="1" x="1">&lt;g1&gt;</bpt>denoted<ept i="1">&lt;/g1&gt;</ept> by suitable expressions in dependent type
theory.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160343Z" creationid="tlqk35" creationdate="20220321T160343Z">
        <seg>직관주의자의 관점에서 증명은 의존 유형론의 적절한 표현식으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>표기된<ept i="1">&lt;/g1&gt;</ept>추상적인 수학적 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Function Abstraction and Evaluation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142123Z" creationid="tlqk35" creationdate="20220321T142123Z">
        <seg>함수 추상화와 함수값의 평가</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generally speaking, for an inductive type in <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>, the
motive of the elimination rule is required to be in <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152305Z" creationid="tlqk35" creationdate="20220528T162615Z">
        <seg>쉽게 말하자면 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>에 대한 귀납형에 대해 제거 규칙의 동기는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>에 있어야 함을 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Generally speaking, the equation compiler processes input of the following form:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170517Z" creationid="tlqk3" creationdate="20220529T170517Z">
        <seg>폭넓게 말하자면, 방정식 컴파일러는 다음 형태의 입력을 처리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Point Nat<ept i="1">&lt;/g1&gt;</ept>, the dot notation <bpt i="2" x="2">&lt;g2&gt;</bpt>p.x<ept i="2">&lt;/g2&gt;</ept> is shorthand for
<bpt i="3" x="3">&lt;g3&gt;</bpt>Point.x p<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174355Z" creationid="tlqk35" creationdate="20220528T174355Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>p : Point Nat<ept i="1">&lt;/g1&gt;</ept>에 대해서 점 기호 <bpt i="2" x="2">&lt;g2&gt;</bpt>p.x<ept i="2">&lt;/g2&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>Point.x p<ept i="3">&lt;/g3&gt;</ept>에 대한 축약 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given <bpt i="3" x="3">&lt;g3&gt;</bpt>α : Type<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>β : α → Type<ept i="4">&lt;/g4&gt;</ept>, think of <bpt i="5" x="5">&lt;g5&gt;</bpt>β<ept i="5">&lt;/g5&gt;</ept>
as a family of types over <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>, that is, a type <bpt i="7" x="7">&lt;g7&gt;</bpt>β a<ept i="7">&lt;/g7&gt;</ept> for each
<bpt i="8" x="8">&lt;g8&gt;</bpt>a : α<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151703Z" creationid="tlqk35" creationdate="20220321T151703Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>α : Type<ept i="3">&lt;/g3&gt;</ept>과<bpt i="4" x="4">&lt;g4&gt;</bpt>β : α → Type<ept i="4">&lt;/g4&gt;</ept>이라면, <bpt i="5" x="5">&lt;g5&gt;</bpt>β<ept i="5">&lt;/g5&gt;</ept>를 <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>에 대한 유형 족(family)으로 생각할 수 있습니다. 즉, 각각의 <bpt i="8" x="8">&lt;g8&gt;</bpt>a : α<ept i="8">&lt;/g8&gt;</ept>에 대해 <bpt i="7" x="7">&lt;g7&gt;</bpt>β a<ept i="7">&lt;/g7&gt;</ept>유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a proof <bpt i="1" x="1">&lt;g1&gt;</bpt>∀ x : α, p x<ept i="1">&lt;/g1&gt;</ept> and any term <bpt i="2" x="2">&lt;g2&gt;</bpt>t : α<ept i="2">&lt;/g2&gt;</ept>, we obtain a proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>p t<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173000Z" creationid="tlqk35" creationdate="20220321T173000Z">
        <seg>증명 <bpt i="1" x="1">&lt;g1&gt;</bpt>∀ x : α, p x<ept i="1">&lt;/g1&gt;</ept>과 임의의 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>t : α<ept i="2">&lt;/g2&gt;</ept>이 있다고 하자, 그러면 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>p t<ept i="3">&lt;/g3&gt;</ept>의 증명을 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a proof of <bpt i="1" x="1">&lt;g1&gt;</bpt>p x<ept i="1">&lt;/g1&gt;</ept>, in a context where <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept> is arbitrary, we obtain a proof <bpt i="3" x="3">&lt;g3&gt;</bpt>∀ x : α, p x<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172917Z" creationid="tlqk35" creationdate="20220321T172917Z">
        <seg>임의의 <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept>의 상황에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>p x<ept i="1">&lt;/g1&gt;</ept>의 증명이 주여졌다고 하자, 그러면 우리는 증명 <bpt i="3" x="3">&lt;g3&gt;</bpt>∀ x : α, p x<ept i="3">&lt;/g3&gt;</ept>을 얻는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a term <bpt i="1" x="1">&lt;g1&gt;</bpt>s : (x : α) → β x<ept i="1">&lt;/g1&gt;</ept> and any term <bpt i="2" x="2">&lt;g2&gt;</bpt>t : α<ept i="2">&lt;/g2&gt;</ept>, we have <bpt i="3" x="3">&lt;g3&gt;</bpt>s t : β t<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173120Z" creationid="tlqk35" creationdate="20220321T173120Z">
        <seg>항 <bpt i="1" x="1">&lt;g1&gt;</bpt>s : (x : α) → β x<ept i="1">&lt;/g1&gt;</ept>과 임의의 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>t : α<ept i="2">&lt;/g2&gt;</ept>이 주어졌다고 해봅시다. 그러면 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>s t : β t<ept i="3">&lt;/g3&gt;</ept>을 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given a term <bpt i="1" x="1">&lt;g1&gt;</bpt>t<ept i="1">&lt;/g1&gt;</ept> of type <bpt i="2" x="2">&lt;g2&gt;</bpt>β x<ept i="2">&lt;/g2&gt;</ept>, in a context where <bpt i="3" x="3">&lt;g3&gt;</bpt>x : α<ept i="3">&lt;/g3&gt;</ept> is arbitrary, we have <bpt i="4" x="4">&lt;g4&gt;</bpt>(fun x : α =&gt; t) : (x : α) → β x<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173049Z" creationid="tlqk35" creationdate="20220321T173049Z">
        <seg> <bpt i="2" x="2">&lt;g2&gt;</bpt>β x<ept i="2">&lt;/g2&gt;</ept>형의 항 <bpt i="1" x="1">&lt;g1&gt;</bpt>t<ept i="1">&lt;/g1&gt;</ept> 임의의 <bpt i="3" x="3">&lt;g3&gt;</bpt>x : α<ept i="3">&lt;/g3&gt;</ept>에 대해서 주어졌다고 해봅시다. 그러면 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>(fun x : α =&gt; t) : (x : α) → β x<ept i="4">&lt;/g4&gt;</ept>을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given an application <bpt i="4" x="4">&lt;g4&gt;</bpt>hMul a b<ept i="4">&lt;/g4&gt;</ept>, after types of <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>b<ept i="6">&lt;/g6&gt;</ept> are known, the type class
synthesizer is invoked, and the resulting type is obtained from the output parameter <bpt i="7" x="7">&lt;g7&gt;</bpt>γ<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164147Z" creationid="tlqk3" creationdate="20220604T164104Z">
        <seg>활용 <bpt i="4" x="4">&lt;g4&gt;</bpt>hMul a b<ept i="4">&lt;/g4&gt;</ept>에 대해서 <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept>와 <bpt i="6" x="6">&lt;g6&gt;</bpt>b<ept i="6">&lt;/g6&gt;</ept>의 유형이 알려진 뒤에 유형 클래스 합성기가 호출됩니다. 그리고 결과 유형은 출력 매개변수 <bpt i="7" x="7">&lt;g7&gt;</bpt>γ<ept i="7">&lt;/g7&gt;</ept>로부터 얻어집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given an expression
<bpt i="1" x="1">&lt;g1&gt;</bpt>e<ept i="1">&lt;/g1&gt;</ept> of an inductive type <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept> (possibly applied to some
arguments), the notation <bpt i="3" x="3">&lt;g3&gt;</bpt>e.bar<ept i="3">&lt;/g3&gt;</ept> is shorthand for <bpt i="4" x="4">&lt;g4&gt;</bpt>Foo.bar e<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151723Z" creationid="tlqk35" creationdate="20220321T163400Z">
        <seg>(아마 몇 가지 인수를 적용한) 귀납형이 <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept>인 표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>e<ept i="1">&lt;/g1&gt;</ept>에 대해 <bpt i="3" x="3">&lt;g3&gt;</bpt>e.bar<ept i="3">&lt;/g3&gt;</ept>과 같은 표기는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Foo.bar e<ept i="4">&lt;/g4&gt;</ept>의 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given any type <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept>,
we should be able to assign a value to each accessible element of
<bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>, recursively, by assigning values to all its predecessors first.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T174522Z" creationid="tlqk3" creationdate="20220529T174522Z">
        <seg>임의의 유형 <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept>에 대해서 우리는 그것의 모든 전임자들을 우선으로 값을 할당하여 <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>의 각 접근 가능한 원소에 값을 재귀적으로 할당할 수 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given that every expression in Lean has a type, it is natural to ask:
what type does <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept> itself have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141547Z" creationid="tlqk35" creationdate="20220321T141547Z">
        <seg>린의 모든 표현식이 유형을 가진다면 <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept> 그 자체는 어떤 유형을 가져야 하는지 궁금한게 당연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Given the fundamental importance of inductive types in Lean, it should
not be surprising that there are a number of tactics designed to work
with them effectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163649Z" creationid="tlqk3" creationdate="20220527T163649Z">
        <seg>린의 귀납형의 근본적인 중요성이 제시되었을 때 이들과 효과적으로 동작하도록 설계된 다수의 전략이 있는 것은 놀라운 일이 아닙니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Go back to the exercises in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Propositions and
Proofs<ept i="1">&lt;/g1&gt;</ept> and
<bpt i="2" x="2">&lt;g2&gt;</bpt>Chapter Quantifiers and Equality<ept i="2">&lt;/g2&gt;</ept> and
redo as many as you can now with tactic proofs, using also <bpt i="3" x="3">&lt;g3&gt;</bpt>rw<ept i="3">&lt;/g3&gt;</ept>
and <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept> as appropriate.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171356Z" creationid="tlqk35" creationdate="20220524T171356Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>명제와 증명<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt> 한정기호와 동등성<ept i="2">&lt;/g2&gt;</ept>의 연습문제로 돌아가서 
전략 증명으로 여러분이 할 수 있는 만큼 많이 다시 해보세요. 
<bpt i="3" x="3">&lt;g3&gt;</bpt>rw<ept i="3">&lt;/g3&gt;</ept>와 <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept>도 적절히 사용하세요..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Going beyond basic notations, Lean's
ability to factor out common boilerplate code into (well-behaved)
macros and to embed entire custom domain specific languages (DSLs) to
textually encode subproblems efficiently and readably can be of great
benefit to both programmers and proof engineers alike.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T121256Z" creationid="tlqk3" creationdate="20220526T121256Z">
        <seg>기본 기호를 넘어서 흔한 상용구 코드(잘 동작하는)를 매크로로 묶고 전체 사용자 정의 도메인 특정 언어(domain specific languages, DSLs)를 포함해 하위 문제를 효율적이고 가독성있게 텍스트로 인코딩하는 린의 능력은 프로그래머와 증명 엔지니어 같은 모든 이에게 큰 이득이 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Goldbach's weak conjecture states
that every odd number greater than 5 is the sum of three
primes.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183948Z" creationid="tlqk35" creationdate="20220321T183948Z">
        <seg>골드바흐의 약한 추측은 5보다 큰 모든 홀수 세 소수의 합으로 표현될 수 있다고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here
are a few examples:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140141Z" creationid="tlqk3" creationdate="20220526T140141Z">
        <seg>여기 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here
is an example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181420Z" creationid="tlqk35" creationdate="20220321T181420Z">
        <seg>여기 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here <bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α)<ept i="1">&lt;/g1&gt;</ept> is a sequence of parameters, <bpt i="2" x="2">&lt;g2&gt;</bpt>(b : β)<ept i="2">&lt;/g2&gt;</ept> is the
sequence of arguments on which pattern matching takes place, and <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept>
is any type, which can depend on <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170647Z" creationid="tlqk3" creationdate="20220529T170647Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α)<ept i="1">&lt;/g1&gt;</ept>는 매개변수의 나열입니다. 패턴 매칭이 일어나는 <bpt i="2" x="2">&lt;g2&gt;</bpt>(b : β)<ept i="2">&lt;/g2&gt;</ept>은 인수의 나열입니다. 그리고 <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept>와 <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept>에 의존할 수 있는 임의의 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here <bpt i="1" x="1">&lt;g1&gt;</bpt>sampleExpr<ept i="1">&lt;/g1&gt;</ept> represents <bpt i="2" x="2">&lt;g2&gt;</bpt>(v₀ * 7) + (2 * v₁)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180630Z" creationid="tlqk3" creationdate="20220603T180630Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>sampleExpr<ept i="1">&lt;/g1&gt;</ept>이 <bpt i="2" x="2">&lt;g2&gt;</bpt>(v₀ * 7) + (2 * v₁)<ept i="2">&lt;/g2&gt;</ept>을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here <bpt i="1" x="1">&lt;g1&gt;</bpt>u_1<ept i="1">&lt;/g1&gt;</ept> is a variable ranging over type levels.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141951Z" creationid="tlqk35" creationdate="20220321T141951Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>u_1<ept i="1">&lt;/g1&gt;</ept>는 어떤 유형 세계에 대한 변수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are
few examples</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135638Z" creationid="tlqk3" creationdate="20220526T135638Z">
        <seg>여기 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are a number of similar examples:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183548Z" creationid="tlqk3" creationdate="20220603T183548Z">
        <seg>여기 비슷한 예제가 많이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are solutions to two of the more difficult ones:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183205Z" creationid="tlqk35" creationdate="20220321T183205Z">
        <seg>여기 더 어려운 두 문제에 대한 해답이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some additional examples:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172112Z" creationid="tlqk3" creationdate="20220527T172112Z">
        <seg>여기 추가 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some examples of how you can declare objects in Lean and
check their types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135259Z" creationid="tlqk35" creationdate="20220321T135259Z">
        <seg>린에서 여러분이 객체를 어떻게 선언하고 그들의 유형을 확인할 수 있는지 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some examples of structural
recursion from the last chapter, now defined using the equation
compiler:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172301Z" creationid="tlqk3" creationdate="20220529T172301Z">
        <seg>이제 방정식 컴파일러를 사용해 정의될 마지막 장의 구조적 재귀에 대한 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some examples:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180921Z" creationid="tlqk35" creationdate="20220321T180921Z">
        <seg>여기 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some more examples</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142527Z" creationid="tlqk35" creationdate="20220321T142527Z">
        <seg>여기 추가 예제가 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some more examples
with lists:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161527Z" creationid="tlqk35" creationdate="20220524T161430Z">
        <seg>여기 추가 예제가 리스트와 함께 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some more examples of nested pattern matching:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162836Z" creationid="tlqk3" creationdate="20220529T162836Z">
        <seg>여기 중첩된 패턴 매칭에 대한 몇 가지 추가 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some of the constructions generated for the
declaration above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174003Z" creationid="tlqk35" creationdate="20220528T174003Z">
        <seg>여기 생성자의 몇 가지가 위의 선언에 대해서 생성되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here are some simple theorems and expressions that use the generated
constructions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174230Z" creationid="tlqk35" creationdate="20220528T174230Z">
        <seg>여기 만들어진 생성자를 사용하는 몇 가지 간단한 정리와 표현식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a better way:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T163733Z" creationid="tlqk3" creationdate="20220603T163733Z">
        <seg>여기 더 나은 방식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a more
elaborate example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183650Z" creationid="tlqk35" creationdate="20220321T183650Z">
        <seg>여기 더 협력(elaborate)하는 예제들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a proof
of <bpt i="11" x="11">&lt;g11&gt;</bpt>p ∧ q ↔ q ∧ p<ept i="11">&lt;/g11&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164759Z" creationid="tlqk35" creationdate="20220321T164759Z">
        <seg>여기 <bpt i="11" x="11">&lt;g11&gt;</bpt>p ∧ q ↔ q ∧ p<ept i="11">&lt;/g11&gt;</ept>의 증명이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is a small example,
adapted from the last section:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165107Z" creationid="tlqk35" creationdate="20220321T165107Z">
        <seg>여기 이전 장에서 가져온 작은 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of a calculation in the natural numbers that uses
substitution combined with associativity, commutativity, and
distributivity.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180018Z" creationid="tlqk35" creationdate="20220321T180018Z">
        <seg>여기 자연수에 대한 대체과 결합성, 교환성, 분배성을 혼합한 계산 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of how the propositions-as-types correspondence gets put into practice.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173724Z" creationid="tlqk35" creationdate="20220321T173724Z">
        <seg>여기에 유형으로써 명제 대응이 현장에서 어떻게 놓이는지에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of how we can carry out elementary reasoning with an equivalence relation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174357Z" creationid="tlqk35" creationdate="20220321T174357Z">
        <seg>이곳은 우리가 어떻게 동등 관계로 초등적인 추론을 하는지 예시를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example of rewriting using a compound expression:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T154307Z" creationid="tlqk35" creationdate="20220524T154307Z">
        <seg>여기서 복합 표현식을 사용하는 다시쓰기의 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example with multiple constructors with arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165155Z" creationid="tlqk3" creationdate="20220527T165155Z">
        <seg>인자를 갖는 다수의 생성자 있는 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is an example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180323Z" creationid="tlqk35" creationdate="20220321T180323Z">
        <seg>여기 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another example where we use the recursor <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod.casesOn<ept i="1">&lt;/g1&gt;</ept> instead
of <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153828Z" creationid="tlqk3" creationdate="20220526T153828Z">
        <seg>여기에 <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept> 대신 재귀자 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod.casesOn<ept i="1">&lt;/g1&gt;</ept>을 사용하는 또다른 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another example, where we use the decidability of equality on
the natural numbers to split on the cases <bpt i="1" x="1">&lt;g1&gt;</bpt>m = n<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>m ≠ n<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171354Z" creationid="tlqk3" creationdate="20220527T171354Z">
        <seg>여기 또 다른 예제가 있습니다. 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>m = n<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>m ≠ n<ept i="2">&lt;/g2&gt;</ept>으로 나누도록  자연수에 대한 동등성의 결정가능성을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072437Z" creationid="tlqk35" creationdate="20220522T072437Z">
        <seg>여기 또 다른 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another example: given any type <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, the type <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept>
denotes the type of lists of elements of type <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141520Z" creationid="tlqk35" creationdate="20220321T141520Z">
        <seg>또 다른 예제가 있습니다. <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>라 하는 임의의 타입에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>List α<ept i="2">&lt;/g2&gt;</ept>의 유형은 <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept> 유형을 원소로 하는 리스트 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another useful trick.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170408Z" creationid="tlqk35" creationdate="20220321T170408Z">
        <seg>여기 또 유용한 트릭이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is another: it adds elements of the first list to elements of the second list, until one of the two lists runs out.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165331Z" creationid="tlqk3" creationdate="20220603T165331Z">
        <seg>여기 또 다른 것이 있습니다. 이것은 둘 중의 한 리스트의 원소가 소진될 때까지 첫 리스트의 원소를 두 번째 리스트의 원소와 더합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is essentially the definition of division on the natural numbers that is found in the standard library.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170545Z" creationid="tlqk3" creationdate="20220603T170545Z">
        <seg>여기 있는 것은 본질적으로 표준 라이브러리에서 찾을 수 있는 자연수에 대한 나눗셈 정의입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is the example from the link above using Lean 4 implicit lambdas.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135457Z" creationid="tlqk3" creationdate="20220526T135457Z">
        <seg>링크 위로부터 린 4의 암시적인 람다를 사용하는 에제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here is the same definition using a <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept> instead of a <bpt i="2" x="2">&lt;g2&gt;</bpt>where<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T163823Z" creationid="tlqk3" creationdate="20220603T163817Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>where<ept i="2">&lt;/g2&gt;</ept> 대신 <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept>을 사용한 같은 정의가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here the <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic, abbreviated <bpt i="2" x="2">&lt;g2&gt;</bpt>rw<ept i="2">&lt;/g2&gt;</ept>, uses <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept> to replace
<bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept> by <bpt i="5" x="5">&lt;g5&gt;</bpt>3<ept i="5">&lt;/g5&gt;</ept> again.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070102Z" creationid="tlqk35" creationdate="20220522T070016Z">
        <seg>여기 <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> 전략은 <bpt i="2" x="2">&lt;g2&gt;</bpt>rw<ept i="2">&lt;/g2&gt;</ept>로 축약되었고, <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept>를 써서 <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>가 다시 <bpt i="5" x="5">&lt;g5&gt;</bpt>3<ept i="5">&lt;/g5&gt;</ept>으로 바뀌게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here the left arrow before <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.add_assoc<ept i="1">&lt;/g1&gt;</ept> tells rewrite to use the
identity in the opposite direction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180724Z" creationid="tlqk35" creationdate="20220321T180724Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.add_assoc<ept i="1">&lt;/g1&gt;</ept> 앞의 왼쪽 화살표는 항등식을 반대 방향으로 사용해 다시쓰라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here the recursion is on
<bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>, and <bpt i="2" x="2">&lt;g2&gt;</bpt>div.F x f : Nat → Nat<ept i="2">&lt;/g2&gt;</ept> returns the "divide by <bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept>"
function for that fixed <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171241Z" creationid="tlqk3" creationdate="20220603T171241Z">
        <seg>여기서 재귀는 <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>에 있습니다. 그리고 <bpt i="2" x="2">&lt;g2&gt;</bpt>div.F x f : Nat → Nat<ept i="2">&lt;/g2&gt;</ept>는 고정된 <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>에 대해 "<bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept>로 나눔" 함수를 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here we use it not only to define a function, but also to carry out a
proof by cases:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161634Z" creationid="tlqk3" creationdate="20220529T161634Z">
        <seg>여기서 우리는 이것을 함수를 정의하는 것과 경우에 따른 증명을 수행하는데에도 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here,
<bpt i="3" x="3">&lt;g3&gt;</bpt>generalize<ept i="3">&lt;/g3&gt;</ept> replaces a goal that could be proved using
<bpt i="4" x="4">&lt;g4&gt;</bpt>rfl<ept i="4">&lt;/g4&gt;</ept> with one that is not provable:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065254Z" creationid="tlqk35" creationdate="20220522T065254Z">
        <seg>여기서 <bpt i="3" x="3">&lt;g3&gt;</bpt>generalize<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>rfl<ept i="4">&lt;/g4&gt;</ept>을 사용해 증명할 수 있는 목표를 
증명가능하지 않은 것으로 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, <bpt i="1" x="1">&lt;g1&gt;</bpt>apply Or.inl; assumption<ept i="1">&lt;/g1&gt;</ept> is functionally equivalent to a
single tactic which first applies <bpt i="2" x="2">&lt;g2&gt;</bpt>apply Or.inl<ept i="2">&lt;/g2&gt;</ept> and then applies
<bpt i="3" x="3">&lt;g3&gt;</bpt>assumption<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145831Z" creationid="tlqk35" creationdate="20220524T145831Z">
        <seg>여기  <bpt i="1" x="1">&lt;g1&gt;</bpt>apply Or.inl; assumption<ept i="1">&lt;/g1&gt;</ept>는 기능적으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>apply Or.inl<ept i="2">&lt;/g2&gt;</ept>을 
적용한 뒤 <bpt i="3" x="3">&lt;g3&gt;</bpt>assumption<ept i="3">&lt;/g3&gt;</ept>을 적용한 한 개의 전략과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, <bpt i="1" x="1">&lt;g1&gt;</bpt>h hq<ept i="1">&lt;/g1&gt;</ept> establishes the equation <bpt i="2" x="2">&lt;g2&gt;</bpt>x = y<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172051Z" creationid="tlqk35" creationdate="20220524T154343Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>h hq<ept i="1">&lt;/g1&gt;</ept>가 방정식 <bpt i="2" x="2">&lt;g2&gt;</bpt>x = y<ept i="2">&lt;/g2&gt;</ept>을 세웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, <bpt i="1" x="1">&lt;g1&gt;</bpt>twice_double x<ept i="1">&lt;/g1&gt;</ept> is definitionally equal to the term <bpt i="2" x="2">&lt;g2&gt;</bpt>(x + x) * (x + x)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144822Z" creationid="tlqk35" creationdate="20220321T144822Z">
        <seg>여기서<bpt i="1" x="1">&lt;g1&gt;</bpt>twice_double x<ept i="1">&lt;/g1&gt;</ept>도 항  <bpt i="2" x="2">&lt;g2&gt;</bpt>(x + x) * (x + x)<ept i="2">&lt;/g2&gt;</ept>과 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, for example, is a proof of <bpt i="1" x="1">&lt;g1&gt;</bpt>¬p → q → (q → p) → r<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164515Z" creationid="tlqk35" creationdate="20220321T164515Z">
        <seg>여기 <bpt i="1" x="1">&lt;g1&gt;</bpt>¬p → q → (q → p) → r<ept i="1">&lt;/g1&gt;</ept>의 증명에 대한 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, for example, is the definition of a
semigroup:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145853Z" creationid="tlqk3" creationdate="20220527T145800Z">
        <seg>예를 들어 여기 반군(半群, semigroup)의 정의가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, the <bpt i="1" x="1">&lt;g1&gt;</bpt>axiom<ept i="1">&lt;/g1&gt;</ept> declaration postulates the existence of an
element of the given type and may compromise logical consistency.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161204Z" creationid="tlqk35" creationdate="20220321T161204Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>axiom<ept i="1">&lt;/g1&gt;</ept> 선언은 주어진 유형의 원소의 존재성을 가정하고 논리적 일관성을 타협할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, the <bpt i="1" x="1">&lt;g1&gt;</bpt>constructor<ept i="1">&lt;/g1&gt;</ept> tactic leaves the first component of the
existential assertion, the value of <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>, implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072049Z" creationid="tlqk35" creationdate="20220522T072049Z">
        <seg>여기서  <bpt i="1" x="1">&lt;g1&gt;</bpt>constructor<ept i="1">&lt;/g1&gt;</ept> 전략은 존재 가정의 첫 요소 암시적으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>의 값으로 남깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Here, the value of the <bpt i="1" x="1">&lt;g1&gt;</bpt>fib<ept i="1">&lt;/g1&gt;</ept> function at <bpt i="2" x="2">&lt;g2&gt;</bpt>n + 2<ept i="2">&lt;/g2&gt;</ept> (which is
definitionally equal to <bpt i="3" x="3">&lt;g3&gt;</bpt>succ (succ n)<ept i="3">&lt;/g3&gt;</ept>) is defined in terms of the
values at <bpt i="4" x="4">&lt;g4&gt;</bpt>n + 1<ept i="4">&lt;/g4&gt;</ept> (which is definitionally equivalent to <bpt i="5" x="5">&lt;g5&gt;</bpt>succ n<ept i="5">&lt;/g5&gt;</ept>)
and the value at <bpt i="6" x="6">&lt;g6&gt;</bpt>n<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T163613Z" creationid="tlqk3" creationdate="20220603T163613Z">
        <seg>여기서 (정의로 인해 <bpt i="3" x="3">&lt;g3&gt;</bpt>succ (succ n)<ept i="3">&lt;/g3&gt;</ept>과 같은)<bpt i="2" x="2">&lt;g2&gt;</bpt>n + 2<ept i="2">&lt;/g2&gt;</ept>에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>fib<ept i="1">&lt;/g1&gt;</ept>의 함수값은 (<bpt i="5" x="5">&lt;g5&gt;</bpt>succ n<ept i="5">&lt;/g5&gt;</ept>와 정의로 인해 동등한)<bpt i="4" x="4">&lt;g4&gt;</bpt>n + 1<ept i="4">&lt;/g4&gt;</ept> 에서의 값과 <bpt i="6" x="6">&lt;g6&gt;</bpt>n<ept i="6">&lt;/g6&gt;</ept>에서 값에 대하여 정의되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>How can we prove the general theorem that <bpt i="1" x="1">&lt;g1&gt;</bpt>next (previous d) = d<ept i="1">&lt;/g1&gt;</ept>
for any Weekday <bpt i="2" x="2">&lt;g2&gt;</bpt>d<ept i="2">&lt;/g2&gt;</ept>?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151321Z" creationid="tlqk3" creationdate="20220526T151321Z">
        <seg>임의의 Weekday <bpt i="2" x="2">&lt;g2&gt;</bpt>d<ept i="2">&lt;/g2&gt;</ept>에 대해 <bpt i="1" x="1">&lt;g1&gt;</bpt>next (previous d) = d<ept i="1">&lt;/g1&gt;</ept>이라는 일반적인 일반적인 정리를 어떻게 증명할 수 있을까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>How to deploy</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172355Z" creationid="tlqk35" creationdate="20220321T172355Z">
        <seg>작동시키는 법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, functions such as <bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept> are still quite verbose to define.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134237Z" creationid="tlqk3" creationdate="20220526T134237Z">
        <seg>그러나 <bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept>같은 함수들은 여전히 정의하기에 꽤 장황합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, in <bpt i="3" x="3">&lt;g3&gt;</bpt>Section Setting Options<ept i="3">&lt;/g3&gt;</ept>, we will
discuss Lean's mechanisms for setting options, which does <bpt i="4" x="4">&lt;g4&gt;</bpt>not<ept i="4">&lt;/g4&gt;</ept> follow
this pattern: options can <bpt i="5" x="5">&lt;g5&gt;</bpt>only<ept i="5">&lt;/g5&gt;</ept> be set locally, which is to say,
their scope is always restricted to the current section or current
file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184117Z" creationid="tlqk3" creationdate="20220525T184117Z">
        <seg>하지만 <bpt i="3" x="3">&lt;g3&gt;</bpt>Section Setting Options<ept i="3">&lt;/g3&gt;</ept>에서 우리는 린의 이 패턴을 따르지 <bpt i="4" x="4">&lt;g4&gt;</bpt>않는<ept i="4">&lt;/g4&gt;</ept> 옵션 설정에 대한 메커니즘에 대해서 얘기할 것입니다. 옵션은 지역적으로<bpt i="5" x="5">&lt;g5&gt;</bpt>만<ept i="5">&lt;/g5&gt;</ept> 설정될 수 있습니다. 그 말은 즉, 그들의 범위는 항상 현재 섹션이나 현재 파일로 제한됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, it is natural to assume that the type of <bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept> should be the same in
this kind of situation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164934Z" creationid="tlqk3" creationdate="20220604T164934Z">
        <seg>그러나 이 같은 상황에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept>형과 <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>형은 동일하다고 가정하는 것이 자연스럽습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, such commands often support the <bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> modifier,
which indicates that they only have effect until
the current <bpt i="3" x="3">&lt;g3&gt;</bpt>section<ept i="3">&lt;/g3&gt;</ept> or <bpt i="4" x="4">&lt;g4&gt;</bpt>namespace<ept i="4">&lt;/g4&gt;</ept> is closed, or until the end
of the current file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T182533Z" creationid="tlqk3" creationdate="20220525T182533Z">
        <seg>하지만 이런 명령은 종종 이들이 현재 <bpt i="3" x="3">&lt;g3&gt;</bpt>section<ept i="3">&lt;/g3&gt;</ept>이나 <bpt i="4" x="4">&lt;g4&gt;</bpt>namespace<ept i="4">&lt;/g4&gt;</ept>이 닫힐 때까지 혹은 현재 파일의 끝까지만 유효하다는 것을 가리키는 <bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> 수정자를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, this is often not the case with indexed
inductive families such as <bpt i="4" x="4">&lt;g4&gt;</bpt>vector α n<ept i="4">&lt;/g4&gt;</ept>, since case splits impose
constraints on the values of the indices.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175450Z" creationid="tlqk3" creationdate="20220603T175450Z">
        <seg>하지만 이것은 <bpt i="4" x="4">&lt;g4&gt;</bpt>vector α n<ept i="4">&lt;/g4&gt;</ept> 같이 인덱스된 귀납형 군의 경우에는 적용이 안됩니다. 왜냐하면 경우를 나누기는 인덱스의 값에 제약을 부과하기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>However, you can use the combinator <bpt i="1" x="1">&lt;g1&gt;</bpt>unhygienic<ept i="1">&lt;/g1&gt;</ept> to disable this restriction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063341Z" creationid="tlqk35" creationdate="20220522T063253Z">
        <seg>하지만 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>unhygienic<ept i="1">&lt;/g1&gt;</ept> 조합자를 사용해서 이 제한을 해제할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identifiers are generally
<bpt i="1" x="1">&lt;g1&gt;</bpt>camelCase<ept i="1">&lt;/g1&gt;</ept>, and types are <bpt i="2" x="2">&lt;g2&gt;</bpt>CamelCase<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131922Z" creationid="tlqk3" creationdate="20220526T131922Z">
        <seg>식별자들은 보통 <bpt i="1" x="1">&lt;g1&gt;</bpt>camelCase<ept i="1">&lt;/g1&gt;</ept>이고 유형은 <bpt i="2" x="2">&lt;g2&gt;</bpt>CamelCase<ept i="2">&lt;/g2&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Identifiers in Lean can include any alphanumeric characters, including
Greek characters (other than ∀ , Σ , and λ , which, as we have seen,
have a special meaning in the dependent type theory).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T191054Z" creationid="tlqk3" creationdate="20220525T191054Z">
        <seg>린의 식별자들은 임의의 그리스 문자를 포함해 (우리가 본 ∀ , Σ , λ 외에도  종속 유형론에서 특별한 의미를 갖습니다.) 알파벳과 수치 문자를 포함할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If
Lean tries to do so and fails, it returns with an error message "don't
know how to synthesize placeholder," followed by the type of
the term it is expecting, and all the objects and hypothesis available
in the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170450Z" creationid="tlqk35" creationdate="20220321T170450Z">
        <seg>만약 린이 그렇게 하려고 했는데 실패한다면 다음에 오는 항의 유형을 기대했다면서 "어떻게 자리 차지자를 동기화 해야할 지 모르겠다"는 오류 메시지를 반환합니다. 그리고 모든 객체와 가정들은 맥락에서 이용가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If
the unspecified fields cannot be inferred, Lean flags an error
indicating the corresponding placeholder could not be synthesized.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182458Z" creationid="tlqk35" creationdate="20220528T182458Z">
        <seg>만약 명시되지 않은 필드가 추론될 수 없다면 린은 대응하는 자리차지자를 합성할 수 없다고(the corresponding placeholder could not be synthesized) 나타내는 오류를 띄울 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="11" x="11">&lt;g11&gt;</bpt>q<ept i="11">&lt;/g11&gt;</ept> does not mention
<bpt i="12" x="12">&lt;g12&gt;</bpt>w<ept i="12">&lt;/g12&gt;</ept>, then showing that <bpt i="13" x="13">&lt;g13&gt;</bpt>q<ept i="13">&lt;/g13&gt;</ept> follows from <bpt i="14" x="14">&lt;g14&gt;</bpt>p w<ept i="14">&lt;/g14&gt;</ept> is tantamount to
showing the <bpt i="15" x="15">&lt;g15&gt;</bpt>q<ept i="15">&lt;/g15&gt;</ept> follows from the existence of any such <bpt i="16" x="16">&lt;g16&gt;</bpt>x<ept i="16">&lt;/g16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181413Z" creationid="tlqk35" creationdate="20220321T181413Z">
        <seg><bpt i="11" x="11">&lt;g11&gt;</bpt>q<ept i="11">&lt;/g11&gt;</ept>가  <bpt i="12" x="12">&lt;g12&gt;</bpt>w<ept i="12">&lt;/g12&gt;</ept>를 언급하지 않았다면 <bpt i="14" x="14">&lt;g14&gt;</bpt>p w<ept i="14">&lt;/g14&gt;</ept>로부터 <bpt i="13" x="13">&lt;g13&gt;</bpt>q<ept i="13">&lt;/g13&gt;</ept>가 따름을 보이는 것으로 임의의 <bpt i="16" x="16">&lt;g16&gt;</bpt>x<ept i="16">&lt;/g16&gt;</ept>의 존재함으로부터  <bpt i="15" x="15">&lt;g15&gt;</bpt>q<ept i="15">&lt;/g15&gt;</ept>를 보이기에 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept> is such a function, the
notation <bpt i="2" x="2">&lt;g2&gt;</bpt>@foo<ept i="2">&lt;/g2&gt;</ept> denotes the same function with all the arguments
made explicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153735Z" creationid="tlqk35" creationdate="20220321T153735Z">
        <seg>만약 <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept>가 그런 함수라면 <bpt i="2" x="2">&lt;g2&gt;</bpt>@foo<ept i="2">&lt;/g2&gt;</ept> 표기는 모든 인수가 명시적으로 된 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;g1&gt;</bpt>j<ept i="1">&lt;/g1&gt;</ept> is not <bpt i="2" x="2">&lt;g2&gt;</bpt>0<ept i="2">&lt;/g2&gt;</ept>, then <bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → β<ept i="3">&lt;/g3&gt;</ept> is
an element of <bpt i="4" x="4">&lt;g4&gt;</bpt>Sort (max i j)<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174654Z" creationid="tlqk35" creationdate="20220321T174654Z">
        <seg>만약 <bpt i="1" x="1">&lt;g1&gt;</bpt>j<ept i="1">&lt;/g1&gt;</ept>가 <bpt i="2" x="2">&lt;g2&gt;</bpt>0<ept i="2">&lt;/g2&gt;</ept>이 아니라면 <bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → β<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Sort (max i j)<ept i="4">&lt;/g4&gt;</ept>의 원소이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept> have been declared as variables, Lean will
generalize them for us automatically:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161522Z" creationid="tlqk35" creationdate="20220321T161522Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept>가 변수로 선언되었다면 린은 우리를 위해 자동적으로 일반화시킬 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> is any expression,
<bpt i="2" x="2">&lt;g2&gt;</bpt>∀ x : α, p<ept i="2">&lt;/g2&gt;</ept> is nothing more than alternative notation for
<bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → p<ept i="3">&lt;/g3&gt;</ept>, with the idea that the former is more natural than the latter
in cases where <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept> is a proposition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173317Z" creationid="tlqk35" creationdate="20220321T173317Z">
        <seg>만약 <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>가 임의의 표현식이면, <bpt i="2" x="2">&lt;g2&gt;</bpt>∀ x : α, p<ept i="2">&lt;/g2&gt;</ept>은 그저 <bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → p<ept i="3">&lt;/g3&gt;</ept>에 대한 대체 표현일 뿐입니다. 전자의 생각은  <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>가 명제인 후자의 경우보다 자연스럽습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If <bpt i="2" x="2">&lt;g2&gt;</bpt>RH<ept i="2">&lt;/g2&gt;</ept> represents the Riemann
hypothesis, a classical mathematician is willing to assert
<bpt i="3" x="3">&lt;g3&gt;</bpt>RH ∨ ¬RH<ept i="3">&lt;/g3&gt;</ept>, even though we cannot yet assert either disjunct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165749Z" creationid="tlqk35" creationdate="20220321T165749Z">
        <seg>만약 <bpt i="2" x="2">&lt;g2&gt;</bpt>RH<ept i="2">&lt;/g2&gt;</ept>가 리만 가설을 나타낸다면 우리가 아직 어느쪽에 분리자를 주장하지 않았더라도 고전 수학자는 <bpt i="3" x="3">&lt;g3&gt;</bpt>RH ∨ ¬RH<ept i="3">&lt;/g3&gt;</ept>라고 기꺼이 주장할 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If doing so reduces the goal to an identity <bpt i="2" x="2">&lt;g2&gt;</bpt>t = t<ept i="2">&lt;/g2&gt;</ept>, the
tactic applies reflexivity to prove it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180439Z" creationid="tlqk35" creationdate="20220321T180439Z">
        <seg>그렇게 하면 항등식 <bpt i="2" x="2">&lt;g2&gt;</bpt>t = t<ept i="2">&lt;/g2&gt;</ept>로 목표를 축소합니다. 전략은 그것을 증명하는데 대칭성을 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If it is a constant
or an axiom, Lean indicates that fact, and shows the type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125515Z" creationid="tlqk3" creationdate="20220526T125515Z">
        <seg>만약 그것이 상수나 공리라면 린은 그 사실을 가리키고 유형을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If more than one record object is provided, then they are
visited in order until Lean finds one that contains the unspecified
field.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181508Z" creationid="tlqk35" creationdate="20220528T181508Z">
        <seg>하나 이상의 레코드 개체가 제공되었다면 그럼 그들은 린이 명시되지 않은 필드를 포함하는 곳을 찾을 때까지 순서대로 방문될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If such a
term appears in a hypothesis and you want to generalize over that as
well, you need to <bpt i="8" x="8">&lt;g8&gt;</bpt>revert<ept i="8">&lt;/g8&gt;</ept> it explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170643Z" creationid="tlqk3" creationdate="20220527T170643Z">
        <seg>만약 그런 항이 가정에 나타나고 여러분이 그것에 대해서도 일반화하기 원한다다면 여러분은 그것을 명시적으로 <bpt i="8" x="8">&lt;g8&gt;</bpt>revert<ept i="8">&lt;/g8&gt;</ept> 할 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If that is not the one
you want, you can use additional arguments to specify the appropriate
subterm.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172003Z" creationid="tlqk35" creationdate="20220524T155415Z">
        <seg>만약 이게 여러분이 원한 것이 아니라면 여러분은 추가 인수를 사용해 적절한 부분항을 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If that were the extent of type class inference, it would not be all that impressive;
it would be simply a mechanism of storing a list of instances for the elaborator to find in a lookup table.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160856Z" creationid="tlqk3" creationdate="20220604T160856Z">
        <seg>그것이 유형 클래스 추론의 확장이라면 그리 인상적이지 않을 것 입니다. 이것은 협력기가 룩업 테이블에서 찾는 데 쓰는 단순히 개체의 리스트를 저장하는 메커니즘일 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the constructor name is not provided, then a constructor is named
<bpt i="1" x="1">&lt;g1&gt;</bpt>mk<ept i="1">&lt;/g1&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174033Z" creationid="tlqk35" creationdate="20220528T174033Z">
        <seg>만약 생성자 이름이 없다면 생성자는 기본적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>mk<ept i="1">&lt;/g1&gt;</ept>로 이름 붙습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the expression you case on does not appear in the goal, the
<bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic uses <bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept> to put the type of the expression into
the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170754Z" creationid="tlqk3" creationdate="20220527T170754Z">
        <seg>여러분이 경우를 나누려는 표현식이 목표에 나타나지 않는다면 <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략은 맥락에 표현식의 유형을 넣도록<bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept> 를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the identifier denotes a definition or theorem, Lean
prints the type of the symbol, and its definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125436Z" creationid="tlqk3" creationdate="20220526T125436Z">
        <seg>만약 식별자가 정의나 정리를 의미한다면 린은 기호의 유형과 그것의 정의를 출력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the inaccessible pattern can be inferred, you can also write
<bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143925Z" creationid="tlqk3" creationdate="20220604T143925Z">
        <seg>만약 접근불가능한 패턴이 추론될 수 있다면 <bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the proof is incomplete, the token <bpt i="3" x="3">&lt;g3&gt;</bpt>by<ept i="3">&lt;/g3&gt;</ept> is
decorated with a red squiggly line, and the error message contains the
remaining goals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060519Z" creationid="tlqk35" creationdate="20220522T060519Z">
        <seg>만일 증명이 불완전하다면, 토큰 <bpt i="3" x="3">&lt;g3&gt;</bpt>by<ept i="3">&lt;/g3&gt;</ept>은 빨간색 구불구불한 선으로 장식됩니다.
그리고 오류 메시지가 남은 목표에 포함됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If the value of a field is not specified, Lean tries to infer it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182330Z" creationid="tlqk35" creationdate="20220528T182330Z">
        <seg>만약 필드의 값이 명시되지 않았다면, 린은 그것을 추론하려고 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If there are
multiple notations accepting the same longest parse, the choice will
be delayed until elaboration, which will fail unless exactly one
overload is type correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124232Z" creationid="tlqk3" creationdate="20220526T124232Z">
        <seg>동일한 가장 긴 구문분석을 받아들이는 다수의 기호가 있다면 협력할 때까지 선택은 미뤄집니다. 그리고 이것은 정확히 한 오버로드가 유형이 옳바르지 않는 한 실패할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If this command is used outside a namespace, the aliases
are exported to the top level.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181612Z" creationid="tlqk3" creationdate="20220525T181612Z">
        <seg>이 명령이 이름공간 밖에서 사용된다면 별명은 최상위 단계로 내보내지게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If two notations overlap, we again apply the longest parse rule:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123934Z" creationid="tlqk3" creationdate="20220526T123934Z">
        <seg>만약 두 기호가 겹치면, 우리는 다시 가장 긴 구문분석 규칙을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If we check the type of the recursor,</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155246Z" creationid="tlqk3" creationdate="20220527T155246Z">
        <seg>우리가 재귀자의 유형을 확인해보면</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you
don't want that to happen, you have to write <bpt i="10" x="10">&lt;g10&gt;</bpt>@t<ept i="10">&lt;/g10&gt;</ept> instead.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184653Z" creationid="tlqk3" creationdate="20220525T184653Z">
        <seg>여러분이 이것이 일어나기 원하지 않는다면 대신 <bpt i="10" x="10">&lt;g10&gt;</bpt>@t<ept i="10">&lt;/g10&gt;</ept>를 써줘야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are ever in a situation where you need to supply an expression
that Lean can infer by type class inference, you can ask Lean to carry
out the inference using <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstance<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T175851Z" creationid="tlqk3" creationdate="20220604T175851Z">
        <seg>린이 유형 클래스 추론으로 유추할 수 있는 표현식을 여러분이 제공해야 하는 상황에 있어 봤다면 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstance<ept i="1">&lt;/g1&gt;</ept>를 사용해 린에게 추론을 이끌어내도록 요청할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are not used to thinking constructively, it may take some time
for you to get a sense of where classical reasoning is used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170002Z" creationid="tlqk35" creationdate="20220321T170002Z">
        <seg>여러분이 직관적으로 생각하는데 익숙치 않다면 고전 추론이 사용되는 곳을 이해하는데 약간의 시간이 소요될지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are reading the book online, you will see a button that reads "try it!" Pressing the button opens up a tab with a
Lean editor, and copies the example with enough surrounding context to make the code compile correctly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134929Z" creationid="tlqk35" creationdate="20220321T134929Z">
        <seg>여러분이 온라인으로 책을 읽는다면 "실행해보기"라 적힌 버튼을 볼 것입니다. 버튼을 누르면 린 편집기 탭이 열리면서 코드가 올바르게 컴파일되도록 주변 맥락을 포함해 예제를 복사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you are using VS Code, you can read the results by hovering over
the relevant theorem or definition, or opening the messages window
with <bpt i="1" x="1">&lt;g1&gt;</bpt>Ctrl-Shift-Enter<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180458Z" creationid="tlqk3" creationdate="20220604T180458Z">
        <seg>VS Code를 사용하는 경우 관련 정리 또는 정의 위로 마우스를 이동하거나 <bpt i="1" x="1">&lt;g1&gt;</bpt>Ctrl-Shift-Enter<ept i="1">&lt;/g1&gt;</ept>로 메시지 창을 열어 결과를 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you do name a section, however, you
have to close it using the same name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150146Z" creationid="tlqk35" creationdate="20220321T150146Z">
        <seg>그러나 여러분이 섹션에 이름을 붙이고자 한다면 같은 이름을 사용해 이를 닫아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you do not name the constructor, Lean uses <bpt i="1" x="1">&lt;g1&gt;</bpt>mk<ept i="1">&lt;/g1&gt;</ept> as a default.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T162227Z" creationid="tlqk3" creationdate="20220526T162227Z">
        <seg>여러분이 생성자의 이름을 지어주지 않는다면, 린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>mk<ept i="1">&lt;/g1&gt;</ept>를 기본 이름으로 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you don't remember the order of the parameters
but know their names, you can send the arguments in any order.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140808Z" creationid="tlqk3" creationdate="20220526T140808Z">
        <seg>여러분이 매개변수의 순서를 기억하지 못해도 그들의 이름을 알면 여러분은 임의의 순서로든 인자를 보낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you have installed Lean on your own computer,
you can find the library in the <bpt i="1" x="1">&lt;g1&gt;</bpt>lean<ept i="1">&lt;/g1&gt;</ept> folder, and explore it with
your file manager.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131447Z" creationid="tlqk3" creationdate="20220526T131447Z">
        <seg>여러분이 여러분 컴퓨터에 린을 설치했다면 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>lean<ept i="1">&lt;/g1&gt;</ept> 폴더에서 라이브러리를 찾을 수 있습니다. 그리고 파일관리자로 그것을 탐색할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you leave out any of the cases in
the following definition, the error message will let you know what has
not been covered.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170200Z" creationid="tlqk3" creationdate="20220529T170200Z">
        <seg>여러분이 다음 정의에서 어떤 경우라도 빠트리면, 오류 메시지가 어떤 것이 다뤄지지 못했는지 알릴 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you think of <bpt i="4" x="4">&lt;g4&gt;</bpt>r y x<ept i="4">&lt;/g4&gt;</ept> as denoting a kind of order relation
<bpt i="5" x="5">&lt;g5&gt;</bpt>y ≺ x<ept i="5">&lt;/g5&gt;</ept>, then <bpt i="6" x="6">&lt;g6&gt;</bpt>Acc r x<ept i="6">&lt;/g6&gt;</ept> says that <bpt i="7" x="7">&lt;g7&gt;</bpt>x<ept i="7">&lt;/g7&gt;</ept> is accessible from below,
in the sense that all its predecessors are accessible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T174213Z" creationid="tlqk3" creationdate="20220529T174213Z">
        <seg>여러분이 <bpt i="4" x="4">&lt;g4&gt;</bpt>r y x<ept i="4">&lt;/g4&gt;</ept>을 순서 관계 <bpt i="5" x="5">&lt;g5&gt;</bpt>y ≺ x<ept i="5">&lt;/g5&gt;</ept>의 일종으로 나타났다고 생각한다면 <bpt i="6" x="6">&lt;g6&gt;</bpt>Acc r x<ept i="6">&lt;/g6&gt;</ept>는 <bpt i="7" x="7">&lt;g7&gt;</bpt>x<ept i="7">&lt;/g7&gt;</ept>가 아래로부터 접근가능하다고 말합니다. 이 관점으로부터 그것의 모든 전임자들은 접근가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want
to specify a witness to the existential quantifier explicitly, you can
use the <bpt i="6" x="6">&lt;g6&gt;</bpt>exists<ept i="6">&lt;/g6&gt;</ept> tactic instead:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072410Z" creationid="tlqk35" creationdate="20220522T072410Z">
        <seg>여러분이 명시적으로 존재정량자를 나타내 보도록하길 원한다면,
대신<bpt i="6" x="6">&lt;g6&gt;</bpt>exists<ept i="6">&lt;/g6&gt;</ept> 전략을 사용하면 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>If you want to use additional files, however, they need to be imported
manually, via an <bpt i="1" x="1">&lt;g1&gt;</bpt>import<ept i="1">&lt;/g1&gt;</ept> statement at the beginning of a file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174028Z" creationid="tlqk35" creationdate="20220524T174028Z">
        <seg>그러나 여러분이 추가 파일을 사용하길 원한다면 파일의 시작에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>import<ept i="1">&lt;/g1&gt;</ept> 구문을 통해 수동으로 불러와야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implement "constant fusion," a procedure that simplifies subterms like
<bpt i="1" x="1">&lt;g1&gt;</bpt>5 + 7<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>12<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180528Z" creationid="tlqk3" creationdate="20220603T180528Z">
        <seg>"상수 융합,"의 구현은 <bpt i="1" x="1">&lt;g1&gt;</bpt>5 + 7<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>12<ept i="2">&lt;/g2&gt;</ept>같은 부분항을 단순화하는 절차이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implicit Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152413Z" creationid="tlqk35" creationdate="20220321T152413Z">
        <seg>암시적 인자(Implicit Arguments)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Implicit Lambdas</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134957Z" creationid="tlqk3" creationdate="20220526T134957Z">
        <seg>암시적인 람다</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Importing Files</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173340Z" creationid="tlqk35" creationdate="20220524T173340Z">
        <seg>파일 불러오기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
Lean 4, we generalize this notation using <bpt i="3" x="3">&lt;g3&gt;</bpt>·<ept i="3">&lt;/g3&gt;</ept> As a placeholder.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140130Z" creationid="tlqk3" creationdate="20220526T140130Z">
        <seg>린 4에서 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>·<ept i="3">&lt;/g3&gt;</ept>를 자리차지자로 사용하여  이 표기를 일반화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
either case, the defining equations hold definitionally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162526Z" creationid="tlqk3" creationdate="20220529T162516Z">
        <seg>각 경우에서 정의한 방정식들은 정의로 인해 성립합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
general, instances may depend on other instances in complicated ways.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154832Z" creationid="tlqk3" creationdate="20220604T154832Z">
        <seg>일반적으로 개체는 다른 개체에 복잡한 방식으로 종속될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
principle, two terms that reduce to the same value are called
<bpt i="2" x="2">&lt;g2&gt;</bpt>definitionally equal<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143728Z" creationid="tlqk35" creationdate="20220321T143723Z">
        <seg>원리적으로 같은 값으로 축약되는 두 항은 <bpt i="2" x="2">&lt;g2&gt;</bpt>정의상으로 동등(definitionally equal)<ept i="2">&lt;/g2&gt;</ept>하다고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
the case of multiplication the latter is expressed as follows:
<bpt i="2" x="2">&lt;g2&gt;</bpt>x * (y * z) = y * (x * z)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171754Z" creationid="tlqk35" creationdate="20220524T162041Z">
        <seg>곱셈의 경우 후자는 다음과 같이 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In
this case, however, <bpt i="5" x="5">&lt;g5&gt;</bpt>apply<ept i="5">&lt;/g5&gt;</ept> would work just as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055358Z" creationid="tlqk35" creationdate="20220522T055358Z">
        <seg>하지만 이 경우 <bpt i="5" x="5">&lt;g5&gt;</bpt>apply<ept i="5">&lt;/g5&gt;</ept>도 마찬가지로 잘 작동할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Inductive Types<ept i="1">&lt;/g1&gt;</ept>,
we will explain <bpt i="2" x="2">&lt;g2&gt;</bpt>how<ept i="2">&lt;/g2&gt;</ept> equality is defined from the primitives of Lean's logical framework.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151729Z" creationid="tlqk35" creationdate="20220321T175415Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>귀납형 장<ept i="1">&lt;/g1&gt;</ept>에서 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>어떻게<ept i="2">&lt;/g2&gt;</ept> 동등이 린의 기초적인 논리 프레임워크로부터 정의되는지 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="1" x="1">&lt;g1&gt;</bpt>Section Implicit Arguments<ept i="1">&lt;/g1&gt;</ept>,
we saw that if Lean displays the type
of a term <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept> as <bpt i="3" x="3">&lt;g3&gt;</bpt>{x : α} → β x<ept i="3">&lt;/g3&gt;</ept>, then the curly brackets
indicate that <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept> has been marked as an <bpt i="5" x="5">&lt;g5&gt;</bpt>implicit argument<ept i="5">&lt;/g5&gt;</ept> to
<bpt i="6" x="6">&lt;g6&gt;</bpt>t<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184454Z" creationid="tlqk3" creationdate="20220525T184454Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Section Implicit Arguments<ept i="1">&lt;/g1&gt;</ept>에서 우리는 린은 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept>의 유형을 <bpt i="3" x="3">&lt;g3&gt;</bpt>{x : α} → β x<ept i="3">&lt;/g3&gt;</ept>으로 표시하고 나서 중괄호는 <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>가  <bpt i="5" x="5">&lt;g5&gt;</bpt>암시적인 인수<ept i="5">&lt;/g5&gt;</ept>로써 <bpt i="6" x="6">&lt;g6&gt;</bpt>t<ept i="6">&lt;/g6&gt;</ept>로 표시되었음을 나타냄을 봤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="1" x="1">&lt;g1&gt;</bpt>Section Notation<ept i="1">&lt;/g1&gt;</ept> below, we will discuss Lean's
mechanisms for defining notation, and see that they also support the
<bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> modifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183843Z" creationid="tlqk3" creationdate="20220525T183843Z">
        <seg>아래 <bpt i="1" x="1">&lt;g1&gt;</bpt>Section Notation<ept i="1">&lt;/g1&gt;</ept>에서 우리는 린의 기호를 정의하는 메커니즘에 대해 얘기하고 또 이들이 <bpt i="2" x="2">&lt;g2&gt;</bpt>local<ept i="2">&lt;/g2&gt;</ept> 수정자를 지원함을 볼 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="1" x="1">&lt;g1&gt;</bpt>Section Using the Simplifier<ept i="1">&lt;/g1&gt;</ept>,
we saw that theorems can be annotated with the <bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept> attribute,
which makes them available for use by the simplifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T182721Z" creationid="tlqk3" creationdate="20220525T182721Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Section Using the Simplifier<ept i="1">&lt;/g1&gt;</ept>에서 우리는 정리들이 단순화기에 의한 사용이 가능하도록 만드는 <bpt i="2" x="2">&lt;g2&gt;</bpt>[simp]<ept i="2">&lt;/g2&gt;</ept> 특성이 붙는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="1" x="1">&lt;g1&gt;</bpt>t₁ &lt;;&gt; t₂<ept i="1">&lt;/g1&gt;</ept>, the <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;;&gt;<ept i="2">&lt;/g2&gt;</ept> operator provides a <bpt i="3" x="3">&lt;g3&gt;</bpt>parallel<ept i="3">&lt;/g3&gt;</ept> version of the sequencing operation:
<bpt i="4" x="4">&lt;g4&gt;</bpt>t₁<ept i="4">&lt;/g4&gt;</ept> is applied to the current goal, and then <bpt i="5" x="5">&lt;g5&gt;</bpt>t₂<ept i="5">&lt;/g5&gt;</ept> is applied to <bpt i="6" x="6">&lt;g6&gt;</bpt>all<ept i="6">&lt;/g6&gt;</ept> the resulting subgoals:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150229Z" creationid="tlqk35" creationdate="20220524T150229Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>t₁ &lt;;&gt; t₂<ept i="1">&lt;/g1&gt;</ept>에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;;&gt;<ept i="2">&lt;/g2&gt;</ept> 연산자는 순차 연산의 버전에 대해 <bpt i="3" x="3">&lt;g3&gt;</bpt>parallel<ept i="3">&lt;/g3&gt;</ept>을 제공합니다.
<bpt i="4" x="4">&lt;g4&gt;</bpt>t₁<ept i="4">&lt;/g4&gt;</ept>는 현재 목표에 적용되고 그 후  <bpt i="5" x="5">&lt;g5&gt;</bpt>t₂<ept i="5">&lt;/g5&gt;</ept>은 출력되는 하위목표 <bpt i="6" x="6">&lt;g6&gt;</bpt>all<ept i="6">&lt;/g6&gt;</ept>에 적용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="3" x="3">&lt;g3&gt;</bpt>Chapter Axioms and Computation<ept i="3">&lt;/g3&gt;</ept>,
we will see that using the law of the
excluded middle to define functions can prevent them from being used
computationally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174024Z" creationid="tlqk3" creationdate="20220604T174024Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>공리와 계산 장<ept i="3">&lt;/g3&gt;</ept>에서 우리는 배중률을 사용해 함수를 정의하는 것은 그들이 계산적으로 사용되는 것을 막을 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In <bpt i="8" x="8">&lt;g8&gt;</bpt>Section Dependent Pattern Matching<ept i="8">&lt;/g8&gt;</ept>,
we will see that it is sometimes necessary to include explicit terms in patterns that
are needed to make an expression type check, though they do not play a
role in pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171529Z" creationid="tlqk3" creationdate="20220529T171529Z">
        <seg>이들이 패턴 매칭에 핵심 역할을 하지 않더라도 <bpt i="8" x="8">&lt;g8&gt;</bpt>의존적인 패턴 매칭 섹션<ept i="8">&lt;/g8&gt;</ept>에서 우리는 이것이 때때로 표현식 유형 확인을 만드는데 필요한 패턴에 대해 명시적으로 포함될 필요가 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Emacs, you can see the goal at the end of any
line by pressing <bpt i="2" x="2">&lt;g2&gt;</bpt>C-c C-g<ept i="2">&lt;/g2&gt;</ept>, or see the remaining goal in an
incomplete proof by putting the cursor after the first character of
the last tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055948Z" creationid="tlqk35" creationdate="20220522T055823Z">
        <seg>Emacs에서 여러분은 임의의 줄의 끝에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>C-c C-g<ept i="2">&lt;/g2&gt;</ept>을 눌러 목표를 볼 수 있습니다. 
아니면 마지막 전략의 첫 문자 뒤에 커서를 놓으면 불완전한 증명에 대한 나머지 목표를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Emacs, you can use <bpt i="2" x="2">&lt;g2&gt;</bpt>C-c C-x<ept i="2">&lt;/g2&gt;</ept> to run an
independent Lean process on your file, and the output buffer will show
a trace every time the type class resolution procedure is subsequently
triggered.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180620Z" creationid="tlqk3" creationdate="20220604T180620Z">
        <seg>Emacs에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>C-c C-x<ept i="2">&lt;/g2&gt;</ept>를 사용하여 파일에서 독립적인 린 프로세스를 실행할 수 있으며 출력 버퍼는 유형 클래스 해결 절차가 이후에 사용될 때마다 추적을 표시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean 3 stdlib, we find many
<bpt i="1" x="1">&lt;g1&gt;</bpt>instances<ept i="1">&lt;/g1&gt;</ept> of the dreadful <bpt i="2" x="2">&lt;g2&gt;</bpt>@<ept i="2">&lt;/g2&gt;</ept>+<bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept> idiom.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135058Z" creationid="tlqk3" creationdate="20220526T135058Z">
        <seg>린 3의 표준라이브러리에서 우리는 치명적인 <bpt i="2" x="2">&lt;g2&gt;</bpt>@<ept i="2">&lt;/g2&gt;</ept>+<bpt i="3" x="3">&lt;g3&gt;</bpt>_<ept i="3">&lt;/g3&gt;</ept> 구문의 수 많은 <bpt i="1" x="1">&lt;g1&gt;</bpt>instances<ept i="1">&lt;/g1&gt;</ept>를 발견했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean 3, we can create simple functions from infix operators by
using parentheses.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135959Z" creationid="tlqk3" creationdate="20220526T135959Z">
        <seg>린 3에서는 괄호를 사용해 전위 연산자로부터 간단한 함수를 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean 4, the elaborator automatically introduces lambdas
for consuming implicit arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135331Z" creationid="tlqk3" creationdate="20220526T135331Z">
        <seg>린 4에서 협력기는 자동적으로 암시적인 인자를 소모하기 위해 람다를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, a calculation proof starts with the keyword
<bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept>, and has the following syntax:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180258Z" creationid="tlqk35" creationdate="20220321T180258Z">
        <seg>린에서 계산 증명은 키워드 <bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept>로 시작합니다. 그리고 다음 문법을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, by changing
<bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept> to <bpt i="3" x="3">&lt;g3&gt;</bpt>class<ept i="3">&lt;/g3&gt;</ept> in the example above, the type of <bpt i="4" x="4">&lt;g4&gt;</bpt>Add.add<ept i="4">&lt;/g4&gt;</ept> becomes</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154117Z" creationid="tlqk3" creationdate="20220604T154117Z">
        <seg>린에서 위 예제에서<bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>class<ept i="3">&lt;/g3&gt;</ept>로 바꿈으로 <bpt i="4" x="4">&lt;g4&gt;</bpt>Add.add<ept i="4">&lt;/g4&gt;</ept>형이 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, identifiers are given by hierarchical <bpt i="1" x="1">&lt;g1&gt;</bpt>names<ept i="1">&lt;/g1&gt;</ept> like
<bpt i="2" x="2">&lt;g2&gt;</bpt>Foo.Bar.baz<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175657Z" creationid="tlqk35" creationdate="20220524T175609Z">
        <seg>린에서 식별자는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo.Bar.baz<ept i="2">&lt;/g2&gt;</ept>처럼 계층적인 <bpt i="1" x="1">&lt;g1&gt;</bpt>names<ept i="1">&lt;/g1&gt;</ept>으로 제시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, one uses an underscore, <bpt i="1" x="1">&lt;g1&gt;</bpt>_<ept i="1">&lt;/g1&gt;</ept>, to specify
that the system should fill in the information automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152757Z" creationid="tlqk35" creationdate="20220321T152757Z">
        <seg>Lean에서 누군가는 시스템이 자동적으로 정보를 채워넣도록 명시하기 위해 밑줄문자(<bpt i="1" x="1">&lt;g1&gt;</bpt>_<ept i="1">&lt;/g1&gt;</ept>)를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, the
<bpt i="2" x="2">&lt;g2&gt;</bpt>theorem<ept i="2">&lt;/g2&gt;</ept> command introduces a new theorem:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160647Z" creationid="tlqk35" creationdate="20220321T160647Z">
        <seg>린에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>theorem<ept i="2">&lt;/g2&gt;</ept> 명령은 새로운 정리를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, the
keyword <bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept> can be used to define such an inductive type as
well as its projections, at the same time.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152034Z" creationid="tlqk3" creationdate="20220526T161714Z">
        <seg>린에에서 키워드 <bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept>는 그것의 투영 뿐만 아니라 귀납형 같은 것을 동시에 정의하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, the syntax for specifying such a type is as
follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T142245Z" creationid="tlqk3" creationdate="20220526T142245Z">
        <seg>린에서 그런 유형을 나타내는 문법은 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In Lean, the type of natural numbers, <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>, is different from the
type of integers, <bpt i="2" x="2">&lt;g2&gt;</bpt>Int<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124407Z" creationid="tlqk3" creationdate="20220526T124407Z">
        <seg>린에서 자연수 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>은 정수의 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>Int<ept i="2">&lt;/g2&gt;</ept>과는 다릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In VS Code, you can open
a window to display messages by pressing <bpt i="1" x="1">&lt;g1&gt;</bpt>Ctrl-Shift-Enter<ept i="1">&lt;/g1&gt;</ept>, and
that window will then show you the current goal whenever the cursor is
in a tactic block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055738Z" creationid="tlqk35" creationdate="20220522T055738Z">
        <seg>VS Code에서 여러분은  <bpt i="1" x="1">&lt;g1&gt;</bpt>Ctrl-Shift-Enter<ept i="1">&lt;/g1&gt;</ept>을 눌러 메시지을 보고자 창을 열 수 있습니다. 
그러면 이 창은 전략 블록 속의 커서가 어디에 있든지 간에 현재 목표를 여러분에게 보여줄 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a nested block,
Lean focuses on the first goal, and generates an error if it has not
been fully solved at the end of the block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144844Z" creationid="tlqk35" creationdate="20220524T144844Z">
        <seg>중첩된 블럭 속에 Lean은 첫번째 목표에 집중하고 블록 끝에서도 완전히 풀리지 않는다면 오류를 발생시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a proof, there are often multiple goals outstanding.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T152042Z" creationid="tlqk35" creationdate="20220524T152042Z">
        <seg>증명에서 종종 두드러진 다수의 목표들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In a similar way, <bpt i="12" x="12">&lt;g12&gt;</bpt>∃ x : α, p<ept i="12">&lt;/g12&gt;</ept> is a <bpt i="13" x="13">&lt;g13&gt;</bpt>Prop<ept i="13">&lt;/g13&gt;</ept>-valued
variant of <bpt i="14" x="14">&lt;g14&gt;</bpt>Σ x : α, p<ept i="14">&lt;/g14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153154Z" creationid="tlqk3" creationdate="20220527T153154Z">
        <seg>마찬가지로 <bpt i="12" x="12">&lt;g12&gt;</bpt>∃ x : α, p<ept i="12">&lt;/g12&gt;</ept>은 <bpt i="14" x="14">&lt;g14&gt;</bpt>Σ x : α, p<ept i="14">&lt;/g14&gt;</ept>의 <bpt i="13" x="13">&lt;g13&gt;</bpt>Prop<ept i="13">&lt;/g13&gt;</ept> 값이 매겨진 변형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept>, another useful tactic is
<bpt i="3" x="3">&lt;g3&gt;</bpt>intro<ept i="3">&lt;/g3&gt;</ept>, which introduces a hypothesis.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062004Z" creationid="tlqk35" creationdate="20220522T062004Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept>에 더해 또 다른 유용한 전략은 가정을 도입하는 <bpt i="3" x="3">&lt;g3&gt;</bpt>intro<ept i="3">&lt;/g3&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition to axioms, however, we would also need rules to build new
proofs from old ones.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154932Z" creationid="tlqk35" creationdate="20220321T154932Z">
        <seg>하지만 공리에 더해 우리는 이전 증명으로부터 새로운 증명을 만드는데 사용할 규칙도 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In addition, you
can use the <bpt i="5" x="5">&lt;g5&gt;</bpt>#print<ept i="5">&lt;/g5&gt;</ept> command to get information about any
identifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125358Z" creationid="tlqk3" creationdate="20220526T125358Z">
        <seg>게다가 여러분은 <bpt i="5" x="5">&lt;g5&gt;</bpt>#print<ept i="5">&lt;/g5&gt;</ept> 명령을 사용해서 임의의 식별자에 대한 정보를 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In all cases, the command <bpt i="3" x="3">&lt;g3&gt;</bpt>#print t1<ept i="3">&lt;/g3&gt;</ept> still yields
<bpt i="4" x="4">&lt;g4&gt;</bpt>∀ p q : Prop, p → q → p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161633Z" creationid="tlqk35" creationdate="20220321T161633Z">
        <seg>모든 경우에 명령 <bpt i="3" x="3">&lt;g3&gt;</bpt>#print t1<ept i="3">&lt;/g3&gt;</ept>은 여전히 <bpt i="4" x="4">&lt;g4&gt;</bpt>∀ p q : Prop, p → q → p<ept i="4">&lt;/g4&gt;</ept>을 출력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In all these cases, the attribute remains in effect in any file that
imports the one in which the declaration occurs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183219Z" creationid="tlqk3" creationdate="20220525T183219Z">
        <seg>모든 경우에 대해서, 특성은 선언이 있는 파일을 불러온 임의의 파일에 대해 영향을 미칩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In all these examples, pattern matching was used to carry out a single
case distinction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161820Z" creationid="tlqk3" creationdate="20220529T161820Z">
        <seg>이 모든 에제에서 패턴 매칭은 한 경우의 구별을 수행하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In any case, all that really matters is the bottom line.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160455Z" creationid="tlqk35" creationdate="20220321T160455Z">
        <seg>어떤 경우에는 가장 중요한 것은 아래의 문장입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In any case, the additional rules are
added to the collection of identities that are used to simplify a
term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171713Z" creationid="tlqk35" creationdate="20220524T163318Z">
        <seg>어떤 경우에 항을 간단히 하는데 사용되는 항등식의 모임에 추가 규칙이 더해질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In both cases, Lean generates the auxiliary function <bpt i="1" x="1">&lt;g1&gt;</bpt>fibFast.loop<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T163904Z" creationid="tlqk3" creationdate="20220603T163904Z">
        <seg>두 경우 모두에 대해 린은 부가 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>fibFast.loop<ept i="1">&lt;/g1&gt;</ept>를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast
to usage outside the equation compiler, here the underscore does <bpt i="3" x="3">&lt;g3&gt;</bpt>not<ept i="3">&lt;/g3&gt;</ept>
indicate an implicit argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163315Z" creationid="tlqk3" creationdate="20220529T163315Z">
        <seg>방정식 컴파일러 밖에서의 사용과 대조적으로 여기서 밑줄 문자는 암시적인 인수를 지칭하지 <bpt i="3" x="3">&lt;g3&gt;</bpt>않습니다.<ept i="3">&lt;/g3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast to ordinary inductive definition, which constructs an
element of some <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort u<ept i="1">&lt;/g1&gt;</ept>, the more general version constructs a
function <bpt i="2" x="2">&lt;g2&gt;</bpt>... → Sort u<ept i="2">&lt;/g2&gt;</ept>, where "<bpt i="3" x="3">&lt;g3&gt;</bpt>...<ept i="3">&lt;/g3&gt;</ept>" denotes a sequence of
argument types, also known as <bpt i="4" x="4">&lt;g4&gt;</bpt>indices<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153033Z" creationid="tlqk35" creationdate="20220528T153033Z">
        <seg>어떤 <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort u<ept i="1">&lt;/g1&gt;</ept>의 원소를 생성하는 평범한 재귀적 정의와는 반대로 더 일반적인 형태는 함수 <bpt i="2" x="2">&lt;g2&gt;</bpt>... → Sort u<ept i="2">&lt;/g2&gt;</ept>을 생성합니다. 한편, "<bpt i="3" x="3">&lt;g3&gt;</bpt>...<ept i="3">&lt;/g3&gt;</ept>"은 <bpt i="4" x="4">&lt;g4&gt;</bpt>indices<ept i="4">&lt;/g4&gt;</ept>로도 알려진 인수 유형의 나열을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast,
<bpt i="10" x="10">&lt;g10&gt;</bpt>infixr<ept i="10">&lt;/g10&gt;</ept> reuses the notation's precedence for the right-hand side
operand, so <bpt i="11" x="11">&lt;g11&gt;</bpt>a ^ b ^ c<ept i="11">&lt;/g11&gt;</ept> <bpt i="12" x="12">&lt;g12&gt;</bpt>can<ept i="12">&lt;/g12&gt;</ept> be parsed as <bpt i="13" x="13">&lt;g13&gt;</bpt>a ^ (b ^ c)<ept i="13">&lt;/g13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123058Z" creationid="tlqk3" creationdate="20220526T123058Z">
        <seg>반대로, <bpt i="10" x="10">&lt;g10&gt;</bpt>infixr<ept i="10">&lt;/g10&gt;</ept>은 우변의 피연산자 표기의 우선순위를 재사용합니다. 그래서 <bpt i="11" x="11">&lt;g11&gt;</bpt>a ^ b ^ c<ept i="11">&lt;/g11&gt;</ept>은 <bpt i="13" x="13">&lt;g13&gt;</bpt>a ^ (b ^ c)<ept i="13">&lt;/g13&gt;</ept>으로 구문분석 <bpt i="12" x="12">&lt;g12&gt;</bpt>될<ept i="12">&lt;/g12&gt;</ept> 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, <bpt i="1" x="1">&lt;g1&gt;</bpt>interactive
theorem proving<ept i="1">&lt;/g1&gt;</ept> focuses on the "verification" aspect of theorem proving, requiring that every claim is supported by a
proof in a suitable axiomatic foundation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131435Z" creationid="tlqk35" creationdate="20220321T131435Z">
        <seg>반대로 <bpt i="1" x="1">&lt;g1&gt;</bpt>상호작용 증명기<ept i="1">&lt;/g1&gt;</ept>는 모든 진술은 적절한 공리적 기초에 의한 증명으로 지지될 것을 요구하면서 정리 증명의 "식별" 측면에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, if we think in terms of the coding trick
described above, then the expressions themselves do not denote
anything interesting.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160400Z" creationid="tlqk35" creationdate="20220321T160400Z">
        <seg>반대로 위에서 설명한 코딩 트릭으로 생각한다면 표현식 그 자체는 어떤 흥미로운 것도 나타내지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, the
constructor <bpt i="2" x="2">&lt;g2&gt;</bpt>succ<ept i="2">&lt;/g2&gt;</ept> can only be applied to a previously constructed
<bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154209Z" creationid="tlqk3" creationdate="20220527T154209Z">
        <seg>반대로 생성자 <bpt i="2" x="2">&lt;g2&gt;</bpt>succ<ept i="2">&lt;/g2&gt;</ept>은 이전에 생성된 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept>에만 적용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In contrast, the sum type has <bpt i="1" x="1">&lt;g1&gt;</bpt>two<ept i="1">&lt;/g1&gt;</ept> constructors, <bpt i="2" x="2">&lt;g2&gt;</bpt>inl<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>inr<ept i="3">&lt;/g3&gt;</ept>
(for "insert left" and "insert right"), each of which takes <bpt i="4" x="4">&lt;g4&gt;</bpt>one<ept i="4">&lt;/g4&gt;</ept>
(explicit) argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T154827Z" creationid="tlqk3" creationdate="20220526T154827Z">
        <seg>대조적으로 합 유형은 <bpt i="1" x="1">&lt;g1&gt;</bpt>두<ept i="1">&lt;/g1&gt;</ept> 생성자 <bpt i="2" x="2">&lt;g2&gt;</bpt>inl<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>inr<ept i="3">&lt;/g3&gt;</ept>이 있습니다. ("왼쪽 삽입"과 "오른쪽 삽입" 의미) 각각은 <bpt i="4" x="4">&lt;g4&gt;</bpt>한<ept i="4">&lt;/g4&gt;</ept>개의 (명시적인) 인수를 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In each
file, you need to open the namespaces you wish to use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130944Z" creationid="tlqk3" creationdate="20220526T130944Z">
        <seg>각 파일에서 여러분은 여러분이 사용하려는 이름공간을 열어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In each of the following examples, splitting occurs on only the first
argument, even though the others are included among the list of
patterns.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163048Z" creationid="tlqk3" creationdate="20220529T163048Z">
        <seg>다른 인수들도 패턴의 리스트 사이에 포함되어 있음에도 다음의 각 예제에서 분할은 첫 번째 인수에만 일어납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact,
all builtin syntax is parsed and processed using the same mechanisms
and APIs open to users.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T120027Z" creationid="tlqk3" creationdate="20220526T120027Z">
        <seg>사실 모든 내장 문법은 같은 메커니즘과 사용자에게 개방된 API를 사용하여 구문분석되고 처리됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact,
the expression denotes the same function as <bpt i="7" x="7">&lt;g7&gt;</bpt>fun (u : β) (z : α) =&gt; u<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143430Z" creationid="tlqk35" creationdate="20220321T143430Z">
        <seg>사실 표현식은  <bpt i="7" x="7">&lt;g7&gt;</bpt>fun (u : β) (z : α) =&gt; u<ept i="7">&lt;/g7&gt;</ept>처럼 같은 함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, Lean allows us to define the inductive type we really want:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152400Z" creationid="tlqk35" creationdate="20220528T170256Z">
        <seg>사실 린은 우리가 원하는 귀납형을 정의하도록 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, Lean is generally
able to process and check proofs in parallel, since assessing the
correctness of one proof does not require knowing the details of
another.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161001Z" creationid="tlqk35" creationdate="20220321T161001Z">
        <seg>사실, 어떤 증명의 옳음에 접근하는 것은 다른 것의 상세를 알 필요가 없기 때문에 린은 일반적으로 증명의 검증과 처리를 병렬적으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, a single inductive definition can introduce an
indexed <bpt i="1" x="1">&lt;g1&gt;</bpt>family<ept i="1">&lt;/g1&gt;</ept> of inductive types, in a manner we now describe.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152140Z" creationid="tlqk35" creationdate="20220528T152510Z">
        <seg>사실 단일 재귀적 정의는 이제 우리가 설명할 방식으로 귀납형의 색인된 <bpt i="1" x="1">&lt;g1&gt;</bpt>family<ept i="1">&lt;/g1&gt;</ept>를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, by the propositions-as-types correspondence, we can declare
the assumption <bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept> that <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> holds, as another variable:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161547Z" creationid="tlqk35" creationdate="20220321T161547Z">
        <seg>사실 유형으로써 명제 대응에 의해 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>를 가진 가정 <bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept>를을 또다른 변수로 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, in
Lean's library, every concrete type other than the universes and every
type constructor other than dependent arrows is an instance of a general family of
type constructions known as <bpt i="8" x="8">&lt;g8&gt;</bpt>inductive types<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T142146Z" creationid="tlqk3" creationdate="20220526T142146Z">
        <seg>사실 린의 라이브러리에서 세계보다는 모든 구체적인 유형과 의존 화살표 외에 모든 형 생성자는 <bpt i="8" x="8">&lt;g8&gt;</bpt>inductive types<ept i="8">&lt;/g8&gt;</ept>으로 알려진 일반적인 유형 생성의 일종의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, in Lean, <bpt i="1" x="1">&lt;g1&gt;</bpt>Subtype<ept i="1">&lt;/g1&gt;</ept> is defined using the structure command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153512Z" creationid="tlqk3" creationdate="20220527T153512Z">
        <seg>사실 린에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>Subtype<ept i="1">&lt;/g1&gt;</ept>은 구조체 명령을 사용해 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, more should be true: applying the expression <bpt i="3" x="3">&lt;g3&gt;</bpt>(fun x : Nat
=&gt; x)<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>1<ept i="4">&lt;/g4&gt;</ept> should "return" the value <bpt i="5" x="5">&lt;g5&gt;</bpt>1<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143634Z" creationid="tlqk35" creationdate="20220321T143634Z">
        <seg>사실, 더 중요한건 표현식<bpt i="3" x="3">&lt;g3&gt;</bpt>(fun x : Nat =&gt; x)<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="5" x="5">&lt;g5&gt;</bpt>1<ept i="5">&lt;/g5&gt;</ept>에 적용하는 것은 값 <bpt i="4" x="4">&lt;g4&gt;</bpt>1<ept i="4">&lt;/g4&gt;</ept>을 "반환"하는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, most such systems provide fully elaborated "proof objects" that can be communicated to other systems and
checked independently.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131457Z" creationid="tlqk35" creationdate="20220321T131457Z">
        <seg>사실, 그런 시스템의 대부분은 증명 대상과의 완전한 협력을 제공합니다. 이 대상은 다른 시스템과 상호작용될 수 있고 독립적으로 검증될 수 있습니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the
notation is defined in Lean as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183515Z" creationid="tlqk35" creationdate="20220321T183515Z">
        <seg>사실 린에서 정의된 기호는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the function
<bpt i="3" x="3">&lt;g3&gt;</bpt>id<ept i="3">&lt;/g3&gt;</ept> is defined in the standard library in exactly this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153328Z" creationid="tlqk35" creationdate="20220321T153328Z">
        <seg>사실 함수 <bpt i="3" x="3">&lt;g3&gt;</bpt>id<ept i="3">&lt;/g3&gt;</ept>는 표준 라이브러리에서도 이와 정확히 동일한 방식으로 정의되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, the type <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept> is
syntactic sugar for <bpt i="4" x="4">&lt;g4&gt;</bpt>Sort 0<ept i="4">&lt;/g4&gt;</ept>, the very bottom of the type hierarchy
described in the last chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155739Z" creationid="tlqk35" creationdate="20220321T155739Z">
        <seg>사실 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>형은 <bpt i="4" x="4">&lt;g4&gt;</bpt>Sort 0<ept i="4">&lt;/g4&gt;</ept>에 대한 문법적 설탕입니다. 유형 계층의 최하층은 마지막 장에서 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, there is a <bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> tactic, which is similar to the
<bpt i="2" x="2">&lt;g2&gt;</bpt>show<ept i="2">&lt;/g2&gt;</ept> expression in a proof term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143254Z" creationid="tlqk35" creationdate="20220524T143254Z">
        <seg>사실 증명항에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>show<ept i="2">&lt;/g2&gt;</ept> 표현식과 비슷한 <bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> 전략이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, this is exactly how the logical
connectives are defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151608Z" creationid="tlqk3" creationdate="20220527T151608Z">
        <seg>사실 이것은 논리 결합자가 어떻게 정의되는가에 대한 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, we can compress the full tactic down to one line:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172122Z" creationid="tlqk35" creationdate="20220524T152820Z">
        <seg>사실, 우리는 완전한 전략을 한 줄로 압축시킬 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, with this
notation, you can even omit both the type and the label, in which case
the new fact is introduced with the label <bpt i="4" x="4">&lt;g4&gt;</bpt>this<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144138Z" creationid="tlqk35" creationdate="20220524T144138Z">
        <seg>사실 이 기호와 관련해서 여러분은 심지어 유형과 레이블 모두 생략할 수 있습니다. 
그 경우 새로운 사실은 <bpt i="4" x="4">&lt;g4&gt;</bpt>this<ept i="4">&lt;/g4&gt;</ept> 레이블로 도입됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In fact, you can use Lean's <bpt i="1" x="1">&lt;g1&gt;</bpt>(t : T)<ept i="1">&lt;/g1&gt;</ept> notation to specify the class whose instance you are looking for,
in a concise manner:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180028Z" creationid="tlqk3" creationdate="20220604T180028Z">
        <seg>사실 여러분은 린의 <bpt i="1" x="1">&lt;g1&gt;</bpt>(t : T)<ept i="1">&lt;/g1&gt;</ept> 기호로 여러분이 찾는 개체의 클래스를 엄밀하게 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In full generality, the problem of
determining whether a higher-order unifier exists is undecidable, and
Lean can at best provide imperfect and approximate solutions to the
problem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180110Z" creationid="tlqk35" creationdate="20220321T180110Z">
        <seg>완전 일반적으로 고차 통합자가 존재하는지 정하는 문제는 결정 불가능합니다. 그리고 린은 최선을 다해 이 문제에 부정확하지만 근사적인 해를 제공할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In general, a
"construction" can depend on data, which is then represented in the
constructed argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152816Z" creationid="tlqk3" creationdate="20220526T152816Z">
        <seg>일반적으로 "생성"은 데이터에 의존할 수 있습니다. 그러면 그것은 생성된 인자에서 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In general, it is important for you to be familiar with the library
and its contents, so you know what theorems, definitions, notations,
and resources are available to you.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131112Z" creationid="tlqk3" creationdate="20220526T131112Z">
        <seg>일반적으로 여러분이 라이브러리와 그것의 내용물에 친숙해지는 것이 중요합니다. 그래야 여러분이 어떤 정리, 정의, 기호, 자원을 쓸 수 있는지 압니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In general, whenever we define a structure <bpt i="3" x="3">&lt;g3&gt;</bpt>S<ept i="3">&lt;/g3&gt;</ept>, we usually
define <bpt i="4" x="4">&lt;g4&gt;</bpt>projection<ept i="4">&lt;/g4&gt;</ept> functions that allow us to "destruct" each
instance of <bpt i="5" x="5">&lt;g5&gt;</bpt>S<ept i="5">&lt;/g5&gt;</ept> and retrieve the values that are stored in its
fields.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173030Z" creationid="tlqk35" creationdate="20220528T172918Z">
        <seg>일반적으로 언제든 우리가 구조체 <bpt i="3" x="3">&lt;g3&gt;</bpt>S<ept i="3">&lt;/g3&gt;</ept>를 정의하면 우리는 보통 <bpt i="5" x="5">&lt;g5&gt;</bpt>S<ept i="5">&lt;/g5&gt;</ept>의 각 개체를 "파괴"할 수 있게 해주고 그 필드에 저장된 값을 인출할 수 있게 해주는 <bpt i="4" x="4">&lt;g4&gt;</bpt>투영<ept i="4">&lt;/g4&gt;</ept>함수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In its most basic form, it is
applied to an element <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> in the local context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164005Z" creationid="tlqk3" creationdate="20220527T164005Z">
        <seg>그것의 가장 기본 형태에서 이것은 지역 맥락에서 원소 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>에 적용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In light of that fact,
Lean tags proofs as <bpt i="1" x="1">&lt;g1&gt;</bpt>irreducible<ept i="1">&lt;/g1&gt;</ept>, which serves as a hint to the
parser (more precisely, the <bpt i="2" x="2">&lt;g2&gt;</bpt>elaborator<ept i="2">&lt;/g2&gt;</ept>) that there is generally no
need to unfold it when processing a file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160948Z" creationid="tlqk35" creationdate="20220321T160948Z">
        <seg>그 사실에 비춰보면 린의 증명을 <bpt i="1" x="1">&lt;g1&gt;</bpt>줄일 수 없는<ept i="1">&lt;/g1&gt;</ept> 것으로 태그한다. 그리고 그것은 파서(더 정확히는  <bpt i="2" x="2">&lt;g2&gt;</bpt>협력기<ept i="2">&lt;/g2&gt;</ept>)에게 파일을 처리할 때 증명을 펼칠 필요가 없다는 힌트를 주는 역할을 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In many respects, however, a <bpt i="1" x="1">&lt;g1&gt;</bpt>namespace ... end<ept i="1">&lt;/g1&gt;</ept> block behaves the
same as a <bpt i="2" x="2">&lt;g2&gt;</bpt>section ... end<ept i="2">&lt;/g2&gt;</ept> block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150718Z" creationid="tlqk35" creationdate="20220321T150718Z">
        <seg>하지만 여러 관점에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>namespace ... end<ept i="1">&lt;/g1&gt;</ept>블록은 <bpt i="2" x="2">&lt;g2&gt;</bpt>section ... end<ept i="2">&lt;/g2&gt;</ept>블록과 동일하게 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In most cases, the first argument of <bpt i="1" x="1">&lt;g1&gt;</bpt>Or.intro_right<ept i="1">&lt;/g1&gt;</ept> and
<bpt i="2" x="2">&lt;g2&gt;</bpt>Or.intro_left<ept i="2">&lt;/g2&gt;</ept> can be inferred automatically by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163946Z" creationid="tlqk35" creationdate="20220321T163946Z">
        <seg>대게의 경우  <bpt i="1" x="1">&lt;g1&gt;</bpt>Or.intro_right<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>Or.intro_left<ept i="2">&lt;/g2&gt;</ept>의 첫번째 인수는 린에 의해 자동적으로 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In normal circumstances, it is never necessary to
unfold the "definition" of a theorem; by proof irrelevance, any two
proofs of that theorem are definitionally equal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160904Z" creationid="tlqk35" creationdate="20220321T160904Z">
        <seg>평범한 상황에서 증명 무연관에 의해 정리의 "정의"를 펼칠 필요는 절대 없습니다. 그리고 그 정리의 임의의 두 증명도 정의상으로 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other
words, <bpt i="7" x="7">&lt;g7&gt;</bpt>assuming<ept i="7">&lt;/g7&gt;</ept> <bpt i="8" x="8">&lt;g8&gt;</bpt>α : Type<ept i="8">&lt;/g8&gt;</ept> is the first argument to the function,
the type of the next two elements are <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept> and <bpt i="10" x="10">&lt;g10&gt;</bpt>List α<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151425Z" creationid="tlqk35" creationdate="20220321T151425Z">
        <seg>다시 말하면 함수의 첫 번째 인수로  <bpt i="8" x="8">&lt;g8&gt;</bpt>α : Type<ept i="8">&lt;/g8&gt;</ept>으로  <bpt i="7" x="7">&lt;g7&gt;</bpt>가정<ept i="7">&lt;/g7&gt;</ept>하면 다음 두 원소의 유형은  <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept>와 <bpt i="10" x="10">&lt;g10&gt;</bpt>List α<ept i="10">&lt;/g10&gt;</ept>가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other
words, under the propositions-as-types correspondence, the proof by
cases is a kind of definition by cases, where what is being "defined"
is a proof instead of a piece of data.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151834Z" creationid="tlqk3" creationdate="20220526T151834Z">
        <seg>다시 말하자면 유형으로써 명제 대응하에서 경우에 따른 증명은 경우에 따른 정의의 일종이고, 여기서 "정의되는" 것은 데이터의 조각 대신 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other situations, however,
reductions hold only <bpt i="3" x="3">&lt;g3&gt;</bpt>propositionally<ept i="3">&lt;/g3&gt;</ept>, which is to say, they are
equational theorems that must be applied explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173048Z" creationid="tlqk3" creationdate="20220529T173048Z">
        <seg>하지만 다른 상황에서 축약은 <bpt i="3" x="3">&lt;g3&gt;</bpt>명제적으로<ept i="3">&lt;/g3&gt;</ept>만 성립합니다. 즉, 명시적으로 적용해야 하는 등식 정리입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words,
<bpt i="4" x="4">&lt;g4&gt;</bpt>True<ept i="4">&lt;/g4&gt;</ept> is simply true, and has a canonical proof, <bpt i="5" x="5">&lt;g5&gt;</bpt>True.intro<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164603Z" creationid="tlqk35" creationdate="20220321T164603Z">
        <seg>다시 말하자면 <bpt i="4" x="4">&lt;g4&gt;</bpt>True<ept i="4">&lt;/g4&gt;</ept>는 단순히 참이고, 정식 증명 <bpt i="5" x="5">&lt;g5&gt;</bpt>True.intro<ept i="5">&lt;/g5&gt;</ept>를 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words,
Lean parses the more general definitions, defines auxiliary inductive
types based on them, and then uses the auxiliary types to define the
ones we really want.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152331Z" creationid="tlqk35" creationdate="20220528T164744Z">
        <seg>다시 말하면, 린은 더 일반적인 정의를 구문분석해 이들이 기반하는 부가적인 귀납형을 정의하고, 그 뒤 부가적인 유형을 우리가 원하는 것을 정의하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, <bpt i="3" x="3">&lt;g3&gt;</bpt>s<ept i="3">&lt;/g3&gt;</ept> is a proof of <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>,
<bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept> is a proof of the desired conclusion assuming <bpt i="6" x="6">&lt;g6&gt;</bpt>h : p<ept i="6">&lt;/g6&gt;</ept>, and the
two are combined by a lambda abstraction and application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165203Z" creationid="tlqk35" creationdate="20220321T165203Z">
        <seg>다시 말하자면 <bpt i="3" x="3">&lt;g3&gt;</bpt>s<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>의 증명입니다. <bpt i="6" x="6">&lt;g6&gt;</bpt>h : p<ept i="6">&lt;/g6&gt;</ept>를 가정한 <bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept>는 원하는 결론의 증명입니다. 그리고 이 둘은 람다 추상화와 적용으로 결합되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, double-negation elimination allows
one to carry out a proof by contradiction, something which is not
generally possible in constructive logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165833Z" creationid="tlqk35" creationdate="20220321T165833Z">
        <seg>다시 말하자면 이중 부정 제거는 직관주의적 논리에서 일반적으로 불가능한 귀류법을 사용한 증명을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for each unresolved placeholder, Lean
reports the subgoal that needs to be filled at that point.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170458Z" creationid="tlqk35" creationdate="20220321T170458Z">
        <seg>다시 말하자면 각 해결되지 않은 자리 차지자에 대해 린은 그 지점에서 채워져야 할 작은 목표를 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, for every <bpt i="12" x="12">&lt;g12&gt;</bpt>α<ept i="12">&lt;/g12&gt;</ept>,
<bpt i="13" x="13">&lt;g13&gt;</bpt>cons α<ept i="13">&lt;/g13&gt;</ept> is the function that takes an element <bpt i="14" x="14">&lt;g14&gt;</bpt>a : α<ept i="14">&lt;/g14&gt;</ept> and a list
<bpt i="15" x="15">&lt;g15&gt;</bpt>as : List α<ept i="15">&lt;/g15&gt;</ept>, and returns a new list, so you have <bpt i="16" x="16">&lt;g16&gt;</bpt>cons α a as : List α<ept i="16">&lt;/g16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151242Z" creationid="tlqk35" creationdate="20220321T151242Z">
        <seg>다시 말하면 모든 <bpt i="12" x="12">&lt;g12&gt;</bpt>α<ept i="12">&lt;/g12&gt;</ept>에 대해  <bpt i="13" x="13">&lt;g13&gt;</bpt>cons α<ept i="13">&lt;/g13&gt;</ept>는 원소 <bpt i="14" x="14">&lt;g14&gt;</bpt>a : α<ept i="14">&lt;/g14&gt;</ept>와 리스트 <bpt i="15" x="15">&lt;g15&gt;</bpt>as : List α<ept i="15">&lt;/g15&gt;</ept>를 받는 함수입니다.  그리고 새로운 리스트를 반환합니다. 그래서 여러분은  <bpt i="16" x="16">&lt;g16&gt;</bpt>cons α a as : List α<ept i="16">&lt;/g16&gt;</ept>를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, if <bpt i="15" x="15">&lt;g15&gt;</bpt>β<ept i="15">&lt;/g15&gt;</ept> is a
proposition depending on <bpt i="16" x="16">&lt;g16&gt;</bpt>α<ept i="16">&lt;/g16&gt;</ept>, then <bpt i="17" x="17">&lt;g17&gt;</bpt>∀ x : α, β<ept i="17">&lt;/g17&gt;</ept> is again a
proposition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175033Z" creationid="tlqk35" creationdate="20220321T175033Z">
        <seg>다시 말해서, 만약 <bpt i="15" x="15">&lt;g15&gt;</bpt>β<ept i="15">&lt;/g15&gt;</ept>가 <bpt i="16" x="16">&lt;g16&gt;</bpt>α<ept i="16">&lt;/g16&gt;</ept>에 의존하는 명제라면 <bpt i="17" x="17">&lt;g17&gt;</bpt>∀ x : α, β<ept i="17">&lt;/g17&gt;</ept>도 다시 명제인 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, if you import <bpt i="4" x="4">&lt;g4&gt;</bpt>Foo<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>Foo<ept i="5">&lt;/g5&gt;</ept> imports <bpt i="6" x="6">&lt;g6&gt;</bpt>Bar<ept i="6">&lt;/g6&gt;</ept>,
then you also have access to the contents of <bpt i="7" x="7">&lt;g7&gt;</bpt>Bar<ept i="7">&lt;/g7&gt;</ept>, and do not need to import it explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174626Z" creationid="tlqk35" creationdate="20220524T174626Z">
        <seg>다시 말하면, 여러분이 <bpt i="4" x="4">&lt;g4&gt;</bpt>Foo<ept i="4">&lt;/g4&gt;</ept>를 부르고 <bpt i="5" x="5">&lt;g5&gt;</bpt>Foo<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>Bar<ept i="6">&lt;/g6&gt;</ept>를 불러온다면
여러분은 <bpt i="7" x="7">&lt;g7&gt;</bpt>Bar<ept i="7">&lt;/g7&gt;</ept>의 내용에도 접근할 수 있습니다. 그리고 명시적으로 불러올 필요가 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, implication between propositions <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>q<ept i="4">&lt;/g4&gt;</ept>
corresponds to having a function that takes any element of <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> to an
element of <bpt i="6" x="6">&lt;g6&gt;</bpt>q<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155625Z" creationid="tlqk35" creationdate="20220321T155625Z">
        <seg>다시 말하면, 명제  <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>q<ept i="4">&lt;/g4&gt;</ept>사이의 함의는  <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>의 원소에서 <bpt i="6" x="6">&lt;g6&gt;</bpt>q<ept i="6">&lt;/g6&gt;</ept>의 원소로 가는 함수를 갖는 것에 대응된니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, it is a
proof by cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163805Z" creationid="tlqk35" creationdate="20220321T163805Z">
        <seg>다시 말하자면 경우에 따라 증명한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the expressions
<bpt i="2" x="2">&lt;g2&gt;</bpt>themselves<ept i="2">&lt;/g2&gt;</ept> are the proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160431Z" creationid="tlqk35" creationdate="20220321T160431Z">
        <seg>다시 말하자면 표현식 <bpt i="2" x="2">&lt;g2&gt;</bpt>그들 자체는<ept i="2">&lt;/g2&gt;</ept> 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the type of
dependent functions from <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept> to <bpt i="6" x="6">&lt;g6&gt;</bpt>β<ept i="6">&lt;/g6&gt;</ept> "lives" in the universe whose
index is the maximum of <bpt i="7" x="7">&lt;g7&gt;</bpt>i<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>j<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174838Z" creationid="tlqk35" creationdate="20220321T174838Z">
        <seg>다시 말하면, <bpt i="5" x="5">&lt;g5&gt;</bpt>α<ept i="5">&lt;/g5&gt;</ept>에서 <bpt i="6" x="6">&lt;g6&gt;</bpt>β<ept i="6">&lt;/g6&gt;</ept>로의 의존 함수 유형이 그것의 첨자가 <bpt i="7" x="7">&lt;g7&gt;</bpt>i<ept i="7">&lt;/g7&gt;</ept>와 <bpt i="8" x="8">&lt;g8&gt;</bpt>j<ept i="8">&lt;/g8&gt;</ept> 중 최대값인 유형세계에 "성립한다"입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the type of the value
returned by <bpt i="14" x="14">&lt;g14&gt;</bpt>f<ept i="14">&lt;/g14&gt;</ept> depends on its input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151837Z" creationid="tlqk35" creationdate="20220321T151837Z">
        <seg>다시 말하자면 <bpt i="14" x="14">&lt;g14&gt;</bpt>f<ept i="14">&lt;/g14&gt;</ept>에 의해 반환되는 값의 유형은 그것의 입력에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, the universe level <bpt i="1" x="1">&lt;g1&gt;</bpt>u<ept i="1">&lt;/g1&gt;</ept> is required to be at least as
large as the universe level of each type that represents an argument
to a constructor.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T162439Z" creationid="tlqk35" creationdate="20220528T162249Z">
        <seg>다시 말하면,  세계 수준 <bpt i="1" x="1">&lt;g1&gt;</bpt>u<ept i="1">&lt;/g1&gt;</ept>는 적어도 생성자에 대한 인자로 나타난 각 유형의 세계 수준 만큼이나 클 필요가 있음을 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In other words, whenever we have <bpt i="4" x="4">&lt;g4&gt;</bpt>p : Prop<ept i="4">&lt;/g4&gt;</ept>, we
can interpret <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> as a type, namely, the type of its proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155450Z" creationid="tlqk35" creationdate="20220321T155450Z">
        <seg>다시 말하자면, <bpt i="4" x="4">&lt;g4&gt;</bpt>p : Prop<ept i="4">&lt;/g4&gt;</ept>를 갖는한 우리는<bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>를 유형으로써 대게 그것의 증명형으로  해석할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular,
if <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept> has no predecessors, it is accessible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T174242Z" creationid="tlqk3" creationdate="20220529T174242Z">
        <seg>특히 <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>의 전임자가 없다면 그것은 접근가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular,
we can define predicates on <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept> by quantifying over all predicates
on <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept>, which is exactly the type of circularity that was once
considered problematic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175253Z" creationid="tlqk35" creationdate="20220321T175253Z">
        <seg>특히, 우리는 <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>에 대한 술어를 <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept>에 대한 모든 술어를 한정함으로써 정의할 수 있습니다. 그리고 이게 한때 문제라고 여겼던 순환 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, if <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> is a true closed
expression, <bpt i="6" x="6">&lt;g6&gt;</bpt>decide p<ept i="6">&lt;/g6&gt;</ept> will reduce definitionally to the Boolean <bpt i="7" x="7">&lt;g7&gt;</bpt>true<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174914Z" creationid="tlqk3" creationdate="20220604T174914Z">
        <seg>특히, <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>가 정말로 닫힌 표현식이라면 <bpt i="6" x="6">&lt;g6&gt;</bpt>decide p<ept i="6">&lt;/g6&gt;</ept>는 정의로부터 불리언 <bpt i="7" x="7">&lt;g7&gt;</bpt>true<ept i="7">&lt;/g7&gt;</ept>로 축소됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, if you use the
<bpt i="3" x="3">&lt;g3&gt;</bpt>variable<ept i="3">&lt;/g3&gt;</ept> command within a namespace, its scope is limited to the
namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150731Z" creationid="tlqk35" creationdate="20220321T150731Z">
        <seg>특히, 이름공간 안에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>variable<ept i="3">&lt;/g3&gt;</ept> 명령을 사용한다면 그것의 범위는 이름공간으로 제한될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, the following equations hold
definitionally:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164916Z" creationid="tlqk3" creationdate="20220529T164916Z">
        <seg>특히 다음 방정식은 정의로부터 성립합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In particular, we
can often write <bpt i="11" x="11">&lt;g11&gt;</bpt>⟨hp, hq⟩<ept i="11">&lt;/g11&gt;</ept> instead of <bpt i="12" x="12">&lt;g12&gt;</bpt>And.intro hp hq<ept i="12">&lt;/g12&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163302Z" creationid="tlqk35" creationdate="20220321T163302Z">
        <seg>특히 <bpt i="12" x="12">&lt;g12&gt;</bpt>And.intro hp hq<ept i="12">&lt;/g12&gt;</ept>대신  <bpt i="11" x="11">&lt;g11&gt;</bpt>⟨hp, hq⟩<ept i="11">&lt;/g11&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In practice, there is not a
sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal
verification requires describing hardware and software systems in mathematical terms, at which point establishing claims
as to their correctness becomes a form of theorem proving.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131208Z" creationid="tlqk35" creationdate="20220321T131208Z">
        <seg>실제로 수학의 일부를 식별하는 것과 시스템의 명확성을 식별하는 것 사이에 명확한 구분이 없습니다. 형식 증명은 하드웨어와 소프트웨어 시스템을 수학적 항으로 묘사하기를 요구합니다. 그리고 그때 그들의 올바름에 대한 주장을 세우는 것은 정리 증명의 형태가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In previous Lean versions, users often found it cumbersome
to have to include these extra discriminants.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151059Z" creationid="tlqk3" creationdate="20220604T151059Z">
        <seg>린의 이전 버전에서 사용자는 이 별도의 구별자를 포함시켜야 하는 것이 종종 성가신 일임을 알았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In situations like this, it can be tedious to supply the arguments
<bpt i="1" x="1">&lt;g1&gt;</bpt>a b c<ept i="1">&lt;/g1&gt;</ept>, when they can be inferred from <bpt i="2" x="2">&lt;g2&gt;</bpt>hab hbc<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174212Z" creationid="tlqk35" creationdate="20220321T174212Z">
        <seg>그들이 <bpt i="2" x="2">&lt;g2&gt;</bpt>hab hbc<ept i="2">&lt;/g2&gt;</ept>으로부터 추론될 수 있을 때, 인자 <bpt i="1" x="1">&lt;g1&gt;</bpt>a b c<ept i="1">&lt;/g1&gt;</ept>를 제공하는 것은 번거로울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case,
<bpt i="12" x="12">&lt;g12&gt;</bpt>(x : α) → β<ept i="12">&lt;/g12&gt;</ept> is an element of <bpt i="13" x="13">&lt;g13&gt;</bpt>Sort 0<ept i="13">&lt;/g13&gt;</ept> as well, no matter which
type universe <bpt i="14" x="14">&lt;g14&gt;</bpt>α<ept i="14">&lt;/g14&gt;</ept> lives in.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175001Z" creationid="tlqk35" creationdate="20220321T174900Z">
        <seg>그 경우 <bpt i="14" x="14">&lt;g14&gt;</bpt>α<ept i="14">&lt;/g14&gt;</ept>가 어느 유형세계에 속하였든 상관없이 <bpt i="12" x="12">&lt;g12&gt;</bpt>(x : α) → β<ept i="12">&lt;/g12&gt;</ept>도 <bpt i="13" x="13">&lt;g13&gt;</bpt>Sort 0<ept i="13">&lt;/g13&gt;</ept>의 원소입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, given
<bpt i="5" x="5">&lt;g5&gt;</bpt>x : α<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>p x<ept i="6">&lt;/g6&gt;</ept> denotes the assertion that <bpt i="7" x="7">&lt;g7&gt;</bpt>p<ept i="7">&lt;/g7&gt;</ept> holds of
<bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172714Z" creationid="tlqk35" creationdate="20220321T172714Z">
        <seg>이 경우 <bpt i="5" x="5">&lt;g5&gt;</bpt>x : α<ept i="5">&lt;/g5&gt;</ept>가 주어진다면, <bpt i="6" x="6">&lt;g6&gt;</bpt>p x<ept i="6">&lt;/g6&gt;</ept>는  <bpt i="7" x="7">&lt;g7&gt;</bpt>p<ept i="7">&lt;/g7&gt;</ept>가  <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>가 성립한다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In that case, the type <bpt i="9" x="9">&lt;g9&gt;</bpt>(a : α) → β a<ept i="9">&lt;/g9&gt;</ept> denotes the type
of functions <bpt i="10" x="10">&lt;g10&gt;</bpt>f<ept i="10">&lt;/g10&gt;</ept> with the property that, for each <bpt i="11" x="11">&lt;g11&gt;</bpt>a : α<ept i="11">&lt;/g11&gt;</ept>, <bpt i="12" x="12">&lt;g12&gt;</bpt>f a<ept i="12">&lt;/g12&gt;</ept>
is an element of <bpt i="13" x="13">&lt;g13&gt;</bpt>β a<ept i="13">&lt;/g13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151821Z" creationid="tlqk35" creationdate="20220321T151821Z">
        <seg>이 경우 유형 <bpt i="9" x="9">&lt;g9&gt;</bpt>(a : α) → β a<ept i="9">&lt;/g9&gt;</ept>는 모든  <bpt i="11" x="11">&lt;g11&gt;</bpt>a : α<ept i="11">&lt;/g11&gt;</ept>에 대해,  <bpt i="12" x="12">&lt;g12&gt;</bpt>f a<ept i="12">&lt;/g12&gt;</ept>가 <bpt i="13" x="13">&lt;g13&gt;</bpt>β a<ept i="13">&lt;/g13&gt;</ept>의 원소라는 성질로 <bpt i="10" x="10">&lt;g10&gt;</bpt>f<ept i="10">&lt;/g10&gt;</ept> 함수의 유형을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the
Lean standard library, you often see Greek letters to denote types,
and the Unicode symbol <bpt i="11" x="11">&lt;g11&gt;</bpt>→<ept i="11">&lt;/g11&gt;</ept> as a more compact version of <bpt i="12" x="12">&lt;g12&gt;</bpt>-&gt;<ept i="12">&lt;/g12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140139Z" creationid="tlqk35" creationdate="20220321T140139Z">
        <seg>린의 표준 라이브러리에서 여러분은 유형을 나타내는데 그리스 문자를 자주 보게 됩니다. 그리고 유니코드 기호 <bpt i="11" x="11">&lt;g11&gt;</bpt>→<ept i="11">&lt;/g11&gt;</ept> 은 <bpt i="12" x="12">&lt;g12&gt;</bpt>-&gt;<ept i="12">&lt;/g12&gt;</ept>보다 더 간결한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the
next two examples, they are used to define functions which swap the
components of the product and sum types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072556Z" creationid="tlqk35" creationdate="20220522T072556Z">
        <seg>다음 두 예제에서, 이들은 곱과 합 유형의 요소를 바꾸는 함수를 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the
previous example, the proper value of the metavariable is determined
by the tactic <bpt i="3" x="3">&lt;g3&gt;</bpt>exact px<ept i="3">&lt;/g3&gt;</ept>, since <bpt i="4" x="4">&lt;g4&gt;</bpt>px<ept i="4">&lt;/g4&gt;</ept> has type <bpt i="5" x="5">&lt;g5&gt;</bpt>p x<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072240Z" creationid="tlqk35" creationdate="20220522T072240Z">
        <seg>이전 예제에서 메타변수의 적절한 값은<bpt i="3" x="3">&lt;g3&gt;</bpt>exact px<ept i="3">&lt;/g3&gt;</ept> 전략에 의해 결정됩니다. 
그 이유는 <bpt i="4" x="4">&lt;g4&gt;</bpt>px<ept i="4">&lt;/g4&gt;</ept>가 <bpt i="5" x="5">&lt;g5&gt;</bpt>p x<ept i="5">&lt;/g5&gt;</ept>형을 갖기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the
second expression, <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept> is a variable, and the expression
<bpt i="7" x="7">&lt;g7&gt;</bpt>fun a =&gt; t2<ept i="7">&lt;/g7&gt;</ept> has to make sense independently of the value of <bpt i="8" x="8">&lt;g8&gt;</bpt>a<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145013Z" creationid="tlqk35" creationdate="20220321T145013Z">
        <seg>두 번째 표현식에서 <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept>는 변수이고 표현식 <bpt i="7" x="7">&lt;g7&gt;</bpt>fun a =&gt; t2<ept i="7">&lt;/g7&gt;</ept>는  <bpt i="8" x="8">&lt;g8&gt;</bpt>a<ept i="8">&lt;/g8&gt;</ept>의 값과 별개로 의미를 가져야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the
successor step, assuming the value <bpt i="6" x="6">&lt;g6&gt;</bpt>add m n<ept i="6">&lt;/g6&gt;</ept> is already determined,
we define <bpt i="7" x="7">&lt;g7&gt;</bpt>add m (succ n)<ept i="7">&lt;/g7&gt;</ept> to be <bpt i="8" x="8">&lt;g8&gt;</bpt>succ (add m n)<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160228Z" creationid="tlqk3" creationdate="20220527T160228Z">
        <seg>계승자 단계에서 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>add m (succ n)<ept i="7">&lt;/g7&gt;</ept>이 <bpt i="7" x="7">&lt;g7&gt;</bpt>add m (succ n)<ept i="7">&lt;/g7&gt;</ept>이 되도록 정의하여 값 <bpt i="6" x="6">&lt;g6&gt;</bpt>add m n<ept i="6">&lt;/g6&gt;</ept>의 추정은 이미 결정되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the <bpt i="1" x="1">&lt;g1&gt;</bpt>nil<ept i="1">&lt;/g1&gt;</ept> case, <bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept> is instantiated to <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept>, and
<bpt i="4" x="4">&lt;g4&gt;</bpt>noConfusion<ept i="4">&lt;/g4&gt;</ept> makes use of the fact that <bpt i="5" x="5">&lt;g5&gt;</bpt>0 = succ n<ept i="5">&lt;/g5&gt;</ept> cannot
occur.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183325Z" creationid="tlqk3" creationdate="20220603T183325Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>nil<ept i="1">&lt;/g1&gt;</ept> 경우에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept>으로 개체화되고 <bpt i="4" x="4">&lt;g4&gt;</bpt>noConfusion<ept i="4">&lt;/g4&gt;</ept>은 <bpt i="5" x="5">&lt;g5&gt;</bpt>0 = succ n<ept i="5">&lt;/g5&gt;</ept>이 일어날 수 없다는 사실을 사용하게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the above Lean code, the field <bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept> has type
<bpt i="2" x="2">&lt;g2&gt;</bpt>Add.add : {α : Type} → Add α → α → α → α<ept i="2">&lt;/g2&gt;</ept>
where the curly braces around the type <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> mean that it is an implicit argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153306Z" creationid="tlqk3" creationdate="20220604T153306Z">
        <seg>위의 린 코드에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Add.add : {α : Type} → Add α → α → α → α<ept i="2">&lt;/g2&gt;</ept>형 입니다. 여기서 유형 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> 주위의 중괄호는 이것이 암시적인 인수임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the base case, we set <bpt i="4" x="4">&lt;g4&gt;</bpt>add m zero<ept i="4">&lt;/g4&gt;</ept> to <bpt i="5" x="5">&lt;g5&gt;</bpt>m<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160058Z" creationid="tlqk3" creationdate="20220527T160058Z">
        <seg>기저의 경우에서 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>add m zero<ept i="4">&lt;/g4&gt;</ept>를 <bpt i="5" x="5">&lt;g5&gt;</bpt>m<ept i="5">&lt;/g5&gt;</ept>으로 설정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the case of the <bpt i="4" x="4">&lt;g4&gt;</bpt>apply<ept i="4">&lt;/g4&gt;</ept>
tactic, the tags are inferred from the parameters names used in the
<bpt i="5" x="5">&lt;g5&gt;</bpt>And.intro<ept i="5">&lt;/g5&gt;</ept> declaration.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061147Z" creationid="tlqk35" creationdate="20220522T061147Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>apply<ept i="4">&lt;/g4&gt;</ept> 전략의 경우 표식은 <bpt i="5" x="5">&lt;g5&gt;</bpt>And.intro<ept i="5">&lt;/g5&gt;</ept>에서 사용된 매개변수의 이름으로부터 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the case where <bpt i="1" x="1">&lt;g1&gt;</bpt>p x<ept i="1">&lt;/g1&gt;</ept> has type <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>, if we replace
<bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → β x<ept i="3">&lt;/g3&gt;</ept> with <bpt i="4" x="4">&lt;g4&gt;</bpt>∀ x : α, p x<ept i="4">&lt;/g4&gt;</ept>, we can read these as the correct rules
for building proofs involving the universal quantifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173157Z" creationid="tlqk35" creationdate="20220321T173157Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>p x<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>형을 갖는 이 경우에 대해, 우리가  <bpt i="3" x="3">&lt;g3&gt;</bpt>(x : α) → β x<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="4" x="4">&lt;g4&gt;</bpt>∀ x : α, p x<ept i="4">&lt;/g4&gt;</ept>으로 대체한다면, 우리는 이것들을 전칭 한정기호를 포함한 증명을 만드는데 옳바른 규칙이라고 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the class <bpt i="1" x="1">&lt;g1&gt;</bpt>HMul<ept i="1">&lt;/g1&gt;</ept>, the parameters <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept> are treated as input values.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164628Z" creationid="tlqk3" creationdate="20220604T164628Z">
        <seg>클래스 <bpt i="1" x="1">&lt;g1&gt;</bpt>HMul<ept i="1">&lt;/g1&gt;</ept>에서 매개변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept>는 입력값으로 취급됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the current setting, it shows
how to "introduce" or establish an implication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162426Z" creationid="tlqk35" creationdate="20220321T162426Z">
        <seg>지금 상황에서 그것은 "도입"을 어떻게 하는지 또는 함의를 어떻게 세우는지 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the editors, you can type the backwards arrow as
<bpt i="4" x="4">&lt;g4&gt;</bpt>\l<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172018Z" creationid="tlqk35" creationdate="20220524T155059Z">
        <seg>편집자에게 여러분은 뒷방향 화상표를 이와 같이 칠 수 있습니다.
<bpt i="4" x="4">&lt;g4&gt;</bpt>\l<ept i="4">&lt;/g4&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example
below, notice that the hypothesis <bpt i="6" x="6">&lt;g6&gt;</bpt>h : n ≠ 0<ept i="6">&lt;/g6&gt;</ept> becomes <bpt i="7" x="7">&lt;g7&gt;</bpt>h : 0 ≠ 0<ept i="7">&lt;/g7&gt;</ept>
in the first branch, and <bpt i="8" x="8">&lt;g8&gt;</bpt>h : succ m ≠ 0<ept i="8">&lt;/g8&gt;</ept> in the second.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164821Z" creationid="tlqk3" creationdate="20220527T164821Z">
        <seg>아래 예제에서 가정 <bpt i="6" x="6">&lt;g6&gt;</bpt>h : n ≠ 0<ept i="6">&lt;/g6&gt;</ept>이  첫 분기에서 <bpt i="7" x="7">&lt;g7&gt;</bpt>h : 0 ≠ 0<ept i="7">&lt;/g7&gt;</ept>이 되고 두 번째 분기에서 <bpt i="8" x="8">&lt;g8&gt;</bpt>h : succ m ≠ 0<ept i="8">&lt;/g8&gt;</ept>이 됨을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above we set the option <bpt i="1" x="1">&lt;g1&gt;</bpt>codegen<ept i="1">&lt;/g1&gt;</ept> to false because the code
generator currently does not support <bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded.fix<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170134Z" creationid="tlqk3" creationdate="20220603T170134Z">
        <seg>위의 예제에서 우리는 옵션 <bpt i="1" x="1">&lt;g1&gt;</bpt>codegen<ept i="1">&lt;/g1&gt;</ept>이 실패하도록 설정했습니다. 왜냐하면 코드 생성기는 현재  <bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded.fix<ept i="2">&lt;/g2&gt;</ept>를 지원하지 않기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above,
it created the declaration <bpt i="2" x="2">&lt;g2&gt;</bpt>replicate.loop<ept i="2">&lt;/g2&gt;</ept> for the <bpt i="3" x="3">&lt;g3&gt;</bpt>let rec loop<ept i="3">&lt;/g3&gt;</ept> occurring at <bpt i="4" x="4">&lt;g4&gt;</bpt>replicate<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182104Z" creationid="tlqk3" creationdate="20220603T182104Z">
        <seg>위 예제에서 <bpt i="4" x="4">&lt;g4&gt;</bpt>replicate<ept i="4">&lt;/g4&gt;</ept>에서 생긴 <bpt i="3" x="3">&lt;g3&gt;</bpt>let rec loop<ept i="3">&lt;/g3&gt;</ept>에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>replicate.loop<ept i="2">&lt;/g2&gt;</ept> 선언을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, <bpt i="2" x="2">&lt;g2&gt;</bpt>def m : Nat := 1<ept i="2">&lt;/g2&gt;</ept>
defines a new constant <bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept> of type <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat<ept i="4">&lt;/g4&gt;</ept> whose value is <bpt i="5" x="5">&lt;g5&gt;</bpt>1<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135810Z" creationid="tlqk35" creationdate="20220321T135810Z">
        <seg>위 예제에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>def m : Nat := 1<ept i="2">&lt;/g2&gt;</ept>는 <bpt i="5" x="5">&lt;g5&gt;</bpt>1<ept i="5">&lt;/g5&gt;</ept>을 값으로 갖는 새로운 상수 <bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat<ept i="4">&lt;/g4&gt;</ept>유형으로 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, the command <bpt i="2" x="2">&lt;g2&gt;</bpt>apply And.intro<ept i="2">&lt;/g2&gt;</ept> yields two
subgoals:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184640Z" creationid="tlqk35" creationdate="20220321T184640Z">
        <seg>위의 예에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>apply And.intro<ept i="2">&lt;/g2&gt;</ept> 명령은 두 하위 목표를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, the first use of <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> replaces <bpt i="2" x="2">&lt;g2&gt;</bpt>k<ept i="2">&lt;/g2&gt;</ept> with
<bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> in the goal <bpt i="4" x="4">&lt;g4&gt;</bpt>f k = 0<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T154134Z" creationid="tlqk35" creationdate="20220524T154134Z">
        <seg>다음 예제에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>의 첫 번째 사용은 목표 <bpt i="4" x="4">&lt;g4&gt;</bpt>f k = 0<ept i="4">&lt;/g4&gt;</ept>에서 
<bpt i="2" x="2">&lt;g2&gt;</bpt>k<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept>으로 대체합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, the inaccessible annotation makes it clear that
<bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept> is <bpt i="2" x="2">&lt;g2&gt;</bpt>not<ept i="2">&lt;/g2&gt;</ept> a pattern matching variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145048Z" creationid="tlqk3" creationdate="20220604T145048Z">
        <seg>위 예제에서 접근불가 주석은 <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>가 패턴 매칭 변수가 <bpt i="2" x="2">&lt;g2&gt;</bpt>아님<ept i="2">&lt;/g2&gt;</ept>을 명확히 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the example above, we defined two instances.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164131Z" creationid="tlqk3" creationdate="20220604T164131Z">
        <seg>위의 예제에서 우리는 두 개체를 정의 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the examples below, the minus sign and
<bpt i="4" x="4">&lt;g4&gt;</bpt>only<ept i="4">&lt;/g4&gt;</ept> are used to block the application of <bpt i="5" x="5">&lt;g5&gt;</bpt>reverse_mk_symm<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170337Z" creationid="tlqk35" creationdate="20220524T170337Z">
        <seg>아래 예제에서 음의 부호와 <bpt i="4" x="4">&lt;g4&gt;</bpt>only<ept i="4">&lt;/g4&gt;</ept>는 <bpt i="5" x="5">&lt;g5&gt;</bpt>reverse_mk_symm<ept i="5">&lt;/g5&gt;</ept>의 
활용을 막는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the examples below, we will henceforth use
Lean's version of the natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160748Z" creationid="tlqk3" creationdate="20220527T160748Z">
        <seg>아래 예제에서 우리는 이후부터 자연수의 린 버전을 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the examples, we have
also made use of additional types like <bpt i="3" x="3">&lt;g3&gt;</bpt>Bool<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat<ept i="4">&lt;/g4&gt;</ept>, and <bpt i="5" x="5">&lt;g5&gt;</bpt>Int<ept i="5">&lt;/g5&gt;</ept>,
and type constructors, like <bpt i="6" x="6">&lt;g6&gt;</bpt>List<ept i="6">&lt;/g6&gt;</ept>, and product, <bpt i="7" x="7">&lt;g7&gt;</bpt>×<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T141922Z" creationid="tlqk3" creationdate="20220526T141922Z">
        <seg>예제에서 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Bool<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat<ept i="4">&lt;/g4&gt;</ept>, and <bpt i="5" x="5">&lt;g5&gt;</bpt>Int<ept i="5">&lt;/g5&gt;</ept> 같은 추가 유형과 유형 생성자 <bpt i="6" x="6">&lt;g6&gt;</bpt>List<ept i="6">&lt;/g6&gt;</ept>과 product, <bpt i="7" x="7">&lt;g7&gt;</bpt>×<ept i="7">&lt;/g7&gt;</ept>의 사용을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the exercises below, we encourage you to prove as many
as you can.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183126Z" creationid="tlqk35" creationdate="20220321T183126Z">
        <seg>아래 연습 문제에서 여러분이 할 수 있는 가능한 많이 증명해보길 권합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the exercises below, you are asked to spell out the details.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T165514Z" creationid="tlqk35" creationdate="20220528T165514Z">
        <seg>아래 연습에서 여러분은 세부 사항을 말하도록 요청받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the exposition below, we will slip back and forth between these two
ways of talking, at times saying that an expression "constructs" or
"produces" or "returns" a proof of a proposition, and at other times
simply saying that it "is" such a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160439Z" creationid="tlqk35" creationdate="20220321T160439Z">
        <seg>아래의 설명에서 우리는 두 말하기 방식 사이를 앞뒤로 다닐 것인데, 어떤 표현은 명제의 증명을 "구성" 또는 "생성", "반환"을 말하고, 어떤 표현은 단순히 "그것"이라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the expression <bpt i="8" x="8">&lt;g8&gt;</bpt>Or.elim hpq hpr hqr<ept i="8">&lt;/g8&gt;</ept>, <bpt i="9" x="9">&lt;g9&gt;</bpt>Or.elim<ept i="9">&lt;/g9&gt;</ept>
takes three arguments, <bpt i="10" x="10">&lt;g10&gt;</bpt>hpq : p ∨ q<ept i="10">&lt;/g10&gt;</ept>, <bpt i="11" x="11">&lt;g11&gt;</bpt>hpr : p → r<ept i="11">&lt;/g11&gt;</ept> and
<bpt i="12" x="12">&lt;g12&gt;</bpt>hqr : q → r<ept i="12">&lt;/g12&gt;</ept>, and produces a proof of <bpt i="13" x="13">&lt;g13&gt;</bpt>r<ept i="13">&lt;/g13&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163854Z" creationid="tlqk35" creationdate="20220321T163854Z">
        <seg>표현식 <bpt i="8" x="8">&lt;g8&gt;</bpt>Or.elim hpq hpr hqr<ept i="8">&lt;/g8&gt;</ept>과 <bpt i="9" x="9">&lt;g9&gt;</bpt>Or.elim<ept i="9">&lt;/g9&gt;</ept>은 세 인수 <bpt i="10" x="10">&lt;g10&gt;</bpt>hpq : p ∨ q<ept i="10">&lt;/g10&gt;</ept>, <bpt i="11" x="11">&lt;g11&gt;</bpt>hpr : p → r<ept i="11">&lt;/g11&gt;</ept> 그리고 <bpt i="12" x="12">&lt;g12&gt;</bpt>hqr : q → r<ept i="12">&lt;/g12&gt;</ept>를 받습니다. 그리고 <bpt i="13" x="13">&lt;g13&gt;</bpt>r<ept i="13">&lt;/g13&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first
case, we simply specify a target value with the appropriate type, as
before.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155051Z" creationid="tlqk3" creationdate="20220527T155051Z">
        <seg>첫 번째 경우에서 우리는 단순히 이전처럼 적절한 유형으로 대상 값을 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first branch, we have the hypothesis <bpt i="3" x="3">&lt;g3&gt;</bpt>h₁ : m &lt; n<ept i="3">&lt;/g3&gt;</ept>, and
in the second we have the hypothesis <bpt i="4" x="4">&lt;g4&gt;</bpt>h₂ : m ≥ n<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171044Z" creationid="tlqk3" creationdate="20220527T171044Z">
        <seg>첫 분기에서 우리는 가정 <bpt i="3" x="3">&lt;g3&gt;</bpt>h₁ : m &lt; n<ept i="3">&lt;/g3&gt;</ept>을 갖고 두 번째에서 우리는 가정 <bpt i="4" x="4">&lt;g4&gt;</bpt>h₂ : m ≥ n<ept i="4">&lt;/g4&gt;</ept>을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first case, the function returns <bpt i="4" x="4">&lt;g4&gt;</bpt>2 * n<ept i="4">&lt;/g4&gt;</ept>, and the second
case, it returns <bpt i="5" x="5">&lt;g5&gt;</bpt>2 * n + 1<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160531Z" creationid="tlqk3" creationdate="20220526T155243Z">
        <seg>첫 번째 경우는 함수는 <bpt i="4" x="4">&lt;g4&gt;</bpt>2 * n<ept i="4">&lt;/g4&gt;</ept>을 반환하고 두 번째 경우는 <bpt i="5" x="5">&lt;g5&gt;</bpt>2 * n + 1<ept i="5">&lt;/g5&gt;</ept>을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first example above, the first step rewrites <bpt i="1" x="1">&lt;g1&gt;</bpt>a + b + c<ept i="1">&lt;/g1&gt;</ept> to
<bpt i="2" x="2">&lt;g2&gt;</bpt>a + (b + c)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171958Z" creationid="tlqk35" creationdate="20220524T155458Z">
        <seg>첫 예제에서 처음 절차는 <bpt i="1" x="1">&lt;g1&gt;</bpt>a + b + c<ept i="1">&lt;/g1&gt;</ept>을 <bpt i="2" x="2">&lt;g2&gt;</bpt>a + (b + c)<ept i="2">&lt;/g2&gt;</ept>으로 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first example, the left branch succeeds, whereas in the second one, it is the right one that succeeds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150808Z" creationid="tlqk35" creationdate="20220524T150808Z">
        <seg>첫 예제에서 왼쪽 분기는 성공했습니다. 반면 두번째에서 성공한 것은 오른쪽의 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first example, the left-hand side of the equality in the goal
is simplified using the usual identities involving 0 and 1, reducing
the goal to <bpt i="1" x="1">&lt;g1&gt;</bpt>x * y = x * y<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161445Z" creationid="tlqk35" creationdate="20220524T161117Z">
        <seg>첫 예제에서 목표 속 등식의 좌변은 0과 1을 포함한 평범한 항등식을 
사용해 단순화해 목표를  <bpt i="1" x="1">&lt;g1&gt;</bpt>x * y = x * y<ept i="1">&lt;/g1&gt;</ept>으로 축소합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the first expression, you should think of every instance
of <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> in <bpt i="4" x="4">&lt;g4&gt;</bpt>t2<ept i="4">&lt;/g4&gt;</ept> as a syntactic abbreviation for <bpt i="5" x="5">&lt;g5&gt;</bpt>t1<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144938Z" creationid="tlqk35" creationdate="20220321T144938Z">
        <seg>첫 번째 표현식에서, 여러분은 <bpt i="4" x="4">&lt;g4&gt;</bpt>t2<ept i="4">&lt;/g4&gt;</ept>속 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>의 모든 개체를 <bpt i="5" x="5">&lt;g5&gt;</bpt>t1<ept i="5">&lt;/g5&gt;</ept>에 대한 문법적 약어로 생각해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, the tactic <bpt i="2" x="2">&lt;g2&gt;</bpt>rename_i h1 _ h2<ept i="2">&lt;/g2&gt;</ept> renames two of the last three hypotheses in
your context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063649Z" creationid="tlqk35" creationdate="20220522T063649Z">
        <seg>다음 예제에서는 <bpt i="2" x="2">&lt;g2&gt;</bpt>rename_i h1 _ h2<ept i="2">&lt;/g2&gt;</ept> 전략이 여러분의 상황 속 세 가정 중 마지막 두 개의 이름을 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, two different lambda expressions are created.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140358Z" creationid="tlqk3" creationdate="20220526T140358Z">
        <seg>다음 예제에서 다른 두 가지 람다 표현식이 만들어집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we
use this basic form to rewrite the goal using a hypothesis.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T154032Z" creationid="tlqk35" creationdate="20220524T154032Z">
        <seg>다음 예제에서 우리는 이 기본 형태를 가정을 사용하여 목표를 다시 쓰는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we define <bpt i="1" x="1">&lt;g1&gt;</bpt>even a<ept i="1">&lt;/g1&gt;</ept> as <bpt i="2" x="2">&lt;g2&gt;</bpt>∃ b, a = 2*b<ept i="2">&lt;/g2&gt;</ept>,
and then we show that the sum of two even numbers is an even number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182926Z" creationid="tlqk35" creationdate="20220321T182926Z">
        <seg>다음 예제에서 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>짝수 a<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="2" x="2">&lt;g2&gt;</bpt>∃ b, a = 2*b<ept i="2">&lt;/g2&gt;</ept>와 같이 정의합니다. 그런 뒤 두 짝수의 합이 짝수임을 보일 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we define the notation <bpt i="1" x="1">&lt;g1&gt;</bpt>triv<ept i="1">&lt;/g1&gt;</ept> using the command <bpt i="2" x="2">&lt;g2&gt;</bpt>syntax<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170454Z" creationid="tlqk35" creationdate="20220524T170454Z">
        <seg>다음 에제에서 우리는<bpt i="1" x="1">&lt;g1&gt;</bpt>triv<ept i="1">&lt;/g1&gt;</ept>기호를 <bpt i="2" x="2">&lt;g2&gt;</bpt>syntax<ept i="2">&lt;/g2&gt;</ept> 명령을 사용해 정의한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we prove <bpt i="2" x="2">&lt;g2&gt;</bpt>symm<ept i="2">&lt;/g2&gt;</ept> and leave as exercise the theorems <bpt i="3" x="3">&lt;g3&gt;</bpt>trans<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>congr<ept i="4">&lt;/g4&gt;</ept> (congruence).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154919Z" creationid="tlqk35" creationdate="20220528T154755Z">
        <seg>다음 예제에서 우리는<bpt i="2" x="2">&lt;g2&gt;</bpt>symm<ept i="2">&lt;/g2&gt;</ept>을 증명합니다. 그리고 정리 <bpt i="3" x="3">&lt;g3&gt;</bpt>trans<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>congr<ept i="4">&lt;/g4&gt;</ept> (적합, congruence)을 연습으로 남겨놓겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we use
<bpt i="14" x="14">&lt;g14&gt;</bpt>Or.elim<ept i="14">&lt;/g14&gt;</ept> to prove <bpt i="15" x="15">&lt;g15&gt;</bpt>p ∨ q → q ∨ p<ept i="15">&lt;/g15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163917Z" creationid="tlqk35" creationdate="20220321T163917Z">
        <seg>다음 예제에서 우리는 <bpt i="14" x="14">&lt;g14&gt;</bpt>Or.elim<ept i="14">&lt;/g14&gt;</ept>을 <bpt i="15" x="15">&lt;g15&gt;</bpt>p ∨ q → q ∨ p<ept i="15">&lt;/g15&gt;</ept>을 증명하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we use <bpt i="2" x="2">&lt;g2&gt;</bpt>rw [h] at t<ept i="2">&lt;/g2&gt;</ept> to rewrite the hypothesis <bpt i="3" x="3">&lt;g3&gt;</bpt>t : Tuple α n<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>t : Tuple α 0<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171820Z" creationid="tlqk35" creationdate="20220524T160542Z">
        <seg>다음 예제에서 우리는 가정 <bpt i="3" x="3">&lt;g3&gt;</bpt>t : Tuple α n<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="4" x="4">&lt;g4&gt;</bpt>t : Tuple α 0<ept i="4">&lt;/g4&gt;</ept>으로 다시쓰도록 <bpt i="2" x="2">&lt;g2&gt;</bpt>rw [h] at t<ept i="2">&lt;/g2&gt;</ept>을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following example, we use output parameters to define a <bpt i="3" x="3">&lt;g3&gt;</bpt>heterogeneous<ept i="3">&lt;/g3&gt;</ept> polymorphic
multiplication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163825Z" creationid="tlqk3" creationdate="20220604T163825Z">
        <seg>다음 예제에서 우리는 출력 매개변수를 <bpt i="3" x="3">&lt;g3&gt;</bpt>이질적인<ept i="3">&lt;/g3&gt;</ept> 다형적 곱셈을 정의하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the following examples, we illustrate the interaction between named
and default arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T141010Z" creationid="tlqk3" creationdate="20220526T141010Z">
        <seg>다음 예제에서 우리는 이름 지어진 것과 기본 인자 사이의 상호작용을 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the last <bpt i="4" x="4">&lt;g4&gt;</bpt>#eval<ept i="4">&lt;/g4&gt;</ept>, note that the instance was used twice on an array of arrays.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164525Z" creationid="tlqk3" creationdate="20220604T164525Z">
        <seg>지난 <bpt i="4" x="4">&lt;g4&gt;</bpt>#eval<ept i="4">&lt;/g4&gt;</ept>에서 배열의 배열에 대해 개체가 두 번 사용되었음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the last chapter we observed that lambda abstraction can be viewed
as an "introduction rule" for <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162419Z" creationid="tlqk35" creationdate="20220321T162419Z">
        <seg>지난 장에서 우리는 람다 추상화가 <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept>에 대한 "도입 규칙"으로 본 적이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the latter case, let us say that (the type associated
with) <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> is <bpt i="6" x="6">&lt;g6&gt;</bpt>inhabited<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160016Z" creationid="tlqk35" creationdate="20220321T160016Z">
        <seg>후자의 경우에서 (연관된 유형)<bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>은 <bpt i="6" x="6">&lt;g6&gt;</bpt>머무른다<ept i="6">&lt;/g6&gt;</ept>고 말합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the meanwhile, here we explain how to use it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175424Z" creationid="tlqk35" creationdate="20220321T175424Z">
        <seg>한편, 여기서는 어떻게 그것을 사용할지 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the meanwhile, think about what is going on in
these examples.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153002Z" creationid="tlqk3" creationdate="20220526T153002Z">
        <seg>한편, 이 예제에서 무슨 일이 일어나는 건지 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next chapter, we will describe Lean's function definition
package, which provides even more convenient ways to define functions
on inductive types and carry out inductive proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151904Z" creationid="tlqk3" creationdate="20220526T144637Z">
        <seg>다음 장에서 우리는 린의 정의 패키지를 설명합니다. 이 패키지는 함수와 귀납형과 귀납 증명을 수행하는 심지어 더 편리한 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next chapter, you will learn how to define a function like
<bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept> so that it works generically for elements of <bpt i="2" x="2">&lt;g2&gt;</bpt>Point α<ept i="2">&lt;/g2&gt;</ept>
rather than just <bpt i="3" x="3">&lt;g3&gt;</bpt>Point Nat<ept i="3">&lt;/g3&gt;</ept>, assuming <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept> has an associated
addition operation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180228Z" creationid="tlqk35" creationdate="20220528T180228Z">
        <seg>다음 장에서 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept>같은 함수를 어떻게 정의하는지 배울 것입니다. 그래서 그저 <bpt i="3" x="3">&lt;g3&gt;</bpt>Point Nat<ept i="3">&lt;/g3&gt;</ept>보다는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Point α<ept i="2">&lt;/g2&gt;</ept>의 원소에 대해 일반적으로 동작하도록 할 것입니다. 여기서 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>는 덧셈 연산과 연관이 있다고 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example we
use <bpt i="7" x="7">&lt;g7&gt;</bpt>And.intro<ept i="7">&lt;/g7&gt;</ept> to create a proof of <bpt i="8" x="8">&lt;g8&gt;</bpt>p → q → p ∧ q<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162642Z" creationid="tlqk35" creationdate="20220321T162642Z">
        <seg>다음 예제에서 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>And.intro<ept i="7">&lt;/g7&gt;</ept>를 <bpt i="8" x="8">&lt;g8&gt;</bpt>p → q → p ∧ q<ept i="8">&lt;/g8&gt;</ept>의 증명을 만들기 위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, for example, we choose the name
<bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept> for the argument to <bpt i="4" x="4">&lt;g4&gt;</bpt>succ<ept i="4">&lt;/g4&gt;</ept>, so that the second case refers to
<bpt i="5" x="5">&lt;g5&gt;</bpt>succ m<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164451Z" creationid="tlqk3" creationdate="20220527T164451Z">
        <seg>다음 예제에서 예를들어 우리는 이름<bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="4" x="4">&lt;g4&gt;</bpt>succ<ept i="4">&lt;/g4&gt;</ept>에 대한 인수로 선택하여 두 번쨰 경우가 <bpt i="5" x="5">&lt;g5&gt;</bpt>succ m<ept i="5">&lt;/g5&gt;</ept>을 참조하도록 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, the second
<bpt i="8" x="8">&lt;g8&gt;</bpt>constructor<ept i="8">&lt;/g8&gt;</ept> succeeds on the right conjunct <bpt i="9" x="9">&lt;g9&gt;</bpt>q ∧ r<ept i="9">&lt;/g9&gt;</ept> (remember that
disjunction and conjunction associate to the right) but fails on the
first.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151729Z" creationid="tlqk35" creationdate="20220524T151729Z">
        <seg>다음 예제에서 두 번째 <bpt i="8" x="8">&lt;g8&gt;</bpt>constructor<ept i="8">&lt;/g8&gt;</ept>는 오른쪽 결합자 <bpt i="9" x="9">&lt;g9&gt;</bpt>q ∧ r<ept i="9">&lt;/g9&gt;</ept>(분리자와 
결합자는 오른쪽 결합성을 가짐을 기억하세요.)에서 성공합니다. 그러나 첫 번째에서는 실패합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next example, we define a structure using multiple inheritance,
and then define an object using objects of the parent structures.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180616Z" creationid="tlqk35" creationdate="20220528T180616Z">
        <seg>다음 예제에서 우리는 다수의 상속을 사용한 구조체를 정의하고 그 후 부모 구조체의 대상을 사용하는 대상을 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next three examples, the same compound tactic succeeds in each case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150833Z" creationid="tlqk35" creationdate="20220524T150833Z">
        <seg>다음 세 예제에서 동일한 복합 전략은 각 경우에서 성공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the next three sections, we will describe,
respectively:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170420Z" creationid="tlqk3" creationdate="20220529T170420Z">
        <seg>다음 세 섹션에서 우리는 개별적으로 설명할 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the previous chapter, we saw that inductive definitions provide a
powerful means of introducing new types in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T155925Z" creationid="tlqk3" creationdate="20220529T155925Z">
        <seg>이전 장에서 우리는 귀납적 정의가 린의 새 유형을 도입하는 강력한 수단을 제공함을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the previous section, we have shown how implicit arguments make functions more convenient to use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134206Z" creationid="tlqk3" creationdate="20220526T134206Z">
        <seg>이전 섹션에서 우리는 어떻게 암시적인 인자가 함수를 쓰기 더 편리하게 만드는지 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the propositions-as-types paradigm, theorems involving only <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept>
can be proved using lambda abstraction and application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160637Z" creationid="tlqk35" creationdate="20220321T160637Z">
        <seg>유형으로써 명제 패러다임에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept>만을 포함하는 정리는 람다 추상화와 적용을 사용해 증명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second case, however, the recursor can assume that a
value of <bpt i="10" x="10">&lt;g10&gt;</bpt>f<ept i="10">&lt;/g10&gt;</ept> at <bpt i="11" x="11">&lt;g11&gt;</bpt>n<ept i="11">&lt;/g11&gt;</ept> has already been computed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155129Z" creationid="tlqk3" creationdate="20220527T155129Z">
        <seg>그러나 두 번째 경우에서 재귀자는 <bpt i="11" x="11">&lt;g11&gt;</bpt>n<ept i="11">&lt;/g11&gt;</ept>에서 <bpt i="10" x="10">&lt;g10&gt;</bpt>f<ept i="10">&lt;/g10&gt;</ept>의 값이 이미 계산되었음을 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second example, <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> reduces
the goal to <bpt i="4" x="4">&lt;g4&gt;</bpt>p (x * y)<ept i="4">&lt;/g4&gt;</ept>, at which point the assumption <bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept>
finishes it off.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161458Z" creationid="tlqk35" creationdate="20220524T161353Z">
        <seg>두 번째 예제에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept>는 목표를 <bpt i="4" x="4">&lt;g4&gt;</bpt>p (x * y)<ept i="4">&lt;/g4&gt;</ept>으로 축약합니다.
이점에서 가정 <bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept>가 이를 끝냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second pair of examples below, this mechanism is
used to specify the desired types of the expressions <bpt i="6" x="6">&lt;g6&gt;</bpt>id<ept i="6">&lt;/g6&gt;</ept> and
<bpt i="7" x="7">&lt;g7&gt;</bpt>List.nil<ept i="7">&lt;/g7&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153603Z" creationid="tlqk35" creationdate="20220321T153603Z">
        <seg>아래 예제의 쌍의 두 번째에서, 이 메커니즘은 식 <bpt i="6" x="6">&lt;g6&gt;</bpt>id<ept i="6">&lt;/g6&gt;</ept>와 <bpt i="7" x="7">&lt;g7&gt;</bpt>List.nil<ept i="7">&lt;/g7&gt;</ept>의 바람직한 유형을 명시하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the second presentation, the patterns overlap; for example, the
pair of arguments <bpt i="1" x="1">&lt;g1&gt;</bpt>0 0<ept i="1">&lt;/g1&gt;</ept> matches all three cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164755Z" creationid="tlqk3" creationdate="20220529T164755Z">
        <seg>두 번째 나타남에서 패턴은 겹칩니다. 예를 들어 인수의 쌍 <bpt i="1" x="1">&lt;g1&gt;</bpt>0 0<ept i="1">&lt;/g1&gt;</ept>은 세 경우 모두 일치합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the section after next we will see what happens when the
constructor of an inductive type takes arguments from the inductive
type itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152021Z" creationid="tlqk3" creationdate="20220526T155651Z">
        <seg>이 섹션 다음에 우리는 귀납형의 생성자가 자기 자신의 귀납형으로부터 인수를 받을 때 무슨 일이 생기는지 알아볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the semantics of dependent type theory, there is no built-in notion
of a partial function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T150031Z" creationid="tlqk3" creationdate="20220527T150031Z">
        <seg>의존 유형론의 의미론에서 부분 함수의 내장 개념은 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the standard library, <bpt i="1" x="1">&lt;g1&gt;</bpt>Decidable<ept i="1">&lt;/g1&gt;</ept> is defined formally as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172138Z" creationid="tlqk3" creationdate="20220604T172103Z">
        <seg>표준 라이브러리에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>Decidable<ept i="1">&lt;/g1&gt;</ept>은 다음과 같이 형식적으로 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In the type theory literature, there are further generalizations of
inductive definitions, for example, the principles of
<bpt i="1" x="1">&lt;g1&gt;</bpt>induction-recursion<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>induction-induction<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T155053Z" creationid="tlqk35" creationdate="20220528T155053Z">
        <seg>유형론 교재에서는 재귀적 정의의 더 일반화 예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>induction-recursion<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>induction-induction<ept i="2">&lt;/g2&gt;</ept>의 원리가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In these languages, the interpreter produces an exception
or returns an arbitrary value for incomplete cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165322Z" creationid="tlqk3" creationdate="20220529T165322Z">
        <seg>이 언어들에서 인터프리터는 예외을 만들거나 불완전한 경우에 대한 임의의 값을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this
section and the next, we discuss them in greater detail.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T153301Z" creationid="tlqk35" creationdate="20220524T153301Z">
        <seg>이 섹션과 다음에서 우리는 이들에 대해 더 자세히 논의할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case you can think of <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept> as a kind of named <bpt i="2" x="2">&lt;g2&gt;</bpt>lambda<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144029Z" creationid="tlqk35" creationdate="20220321T144029Z">
        <seg>이 경우 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="2" x="2">&lt;g2&gt;</bpt>lambda<ept i="2">&lt;/g2&gt;</ept>와 같은 종류로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, detecting the
possibility of well-founded recursion on the natural numbers, it uses
the usual lexicographic ordering on the pair <bpt i="1" x="1">&lt;g1&gt;</bpt>(x, y)<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172039Z" creationid="tlqk3" creationdate="20220603T172039Z">
        <seg>이 경우 자연수에 대한 잘 세워진 재귀의 가능성을 감지하여 순서쌍 <bpt i="1" x="1">&lt;g1&gt;</bpt>(x, y)<ept i="1">&lt;/g1&gt;</ept>에 대해 평범한 사전적 순서를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, each can be used to reduce the proof to:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164208Z" creationid="tlqk3" creationdate="20220527T161300Z">
        <seg>여기서 각각은 증명을 다음과 같이 간단히 하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this case, the <bpt i="1" x="1">&lt;g1&gt;</bpt>any_goals<ept i="1">&lt;/g1&gt;</ept> tactic provides a more robust solution.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172331Z" creationid="tlqk35" creationdate="20220524T152345Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>any_goals<ept i="1">&lt;/g1&gt;</ept> 전략은 더 강건한 답을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this chapter,
we extend the repertoire of logical constructions to include the
universal and existential quantifiers, and the equality relation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172553Z" creationid="tlqk35" creationdate="20220321T172553Z">
        <seg>이번 장에서는 우리는 전칭과 존재 한정기호와 동등 관계를 포함한 논리 구축 레퍼토리를 확장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this chapter, we describe an alternative approach to constructing
proofs, using <bpt i="1" x="1">&lt;g1&gt;</bpt>tactics<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184252Z" creationid="tlqk35" creationdate="20220321T184252Z">
        <seg>이 장에서는 <bpt i="1" x="1">&lt;g1&gt;</bpt>전략<ept i="1">&lt;/g1&gt;</ept>을 사용하여 증명을 생성하는 대체 접근 방식을 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this chapter, we will begin to explain how to write
mathematical assertions and proofs in the language of dependent type
theory as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154806Z" creationid="tlqk35" creationdate="20220321T154806Z">
        <seg>지금까지, 여러분들은 린에서 객체와 함수를 정의하는 몇가지 방법을 배웠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the <bpt i="1" x="1">&lt;g1&gt;</bpt>admit<ept i="1">&lt;/g1&gt;</ept> tactic is the analogue of the <bpt i="2" x="2">&lt;g2&gt;</bpt>sorry<ept i="2">&lt;/g2&gt;</ept>
proof term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065339Z" creationid="tlqk35" creationdate="20220522T065339Z">
        <seg>이 예제에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>admit<ept i="1">&lt;/g1&gt;</ept> 전략은 증명항 <bpt i="2" x="2">&lt;g2&gt;</bpt>sorry<ept i="2">&lt;/g2&gt;</ept>와 유사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, the term <bpt i="1" x="1">&lt;g1&gt;</bpt>←h₁<ept i="1">&lt;/g1&gt;</ept> instructs the rewriter to replace
<bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept> with <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172022Z" creationid="tlqk35" creationdate="20220524T155024Z">
        <seg>이 예제에서 항 <bpt i="1" x="1">&lt;g1&gt;</bpt>←h₁<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>로 대체하도록 다시쓰기에게 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, there is only one goal after the <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic is
applied, with <bpt i="2" x="2">&lt;g2&gt;</bpt>h : p ∧ q<ept i="2">&lt;/g2&gt;</ept> replaced by a pair of assumptions,
<bpt i="3" x="3">&lt;g3&gt;</bpt>hp : p<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>hq : q<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071237Z" creationid="tlqk35" creationdate="20220522T071237Z">
        <seg>이 예제에서,<bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략이 <bpt i="2" x="2">&lt;g2&gt;</bpt>h : p ∧ q<ept i="2">&lt;/g2&gt;</ept>에서 가정 
<bpt i="3" x="3">&lt;g3&gt;</bpt>hp : p<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>hq : q<ept i="4">&lt;/g4&gt;</ept>을 적용한  이후에는 한 목표만 남습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this example, two types are defined simultaneously: a natural
number <bpt i="1" x="1">&lt;g1&gt;</bpt>n<ept i="1">&lt;/g1&gt;</ept> is <bpt i="2" x="2">&lt;g2&gt;</bpt>Even<ept i="2">&lt;/g2&gt;</ept> if it is <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> or one more than an <bpt i="4" x="4">&lt;g4&gt;</bpt>Odd<ept i="4">&lt;/g4&gt;</ept>
number, and <bpt i="5" x="5">&lt;g5&gt;</bpt>Odd<ept i="5">&lt;/g5&gt;</ept> if it is one more than an <bpt i="6" x="6">&lt;g6&gt;</bpt>Even<ept i="6">&lt;/g6&gt;</ept> number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T165452Z" creationid="tlqk35" creationdate="20220528T165452Z">
        <seg>이 예제에서 두 유형은 동시에 정의되었습니다.. 자연수 <bpt i="1" x="1">&lt;g1&gt;</bpt>n<ept i="1">&lt;/g1&gt;</ept>은 만약 이것이 <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> 혹은 <bpt i="4" x="4">&lt;g4&gt;</bpt>홀수(Odd)<ept i="4">&lt;/g4&gt;</ept>보다 하나 크면<bpt i="2" x="2">&lt;g2&gt;</bpt>짝수(Even)<ept i="2">&lt;/g2&gt;</ept>입니다. 그리고 <bpt i="5" x="5">&lt;g5&gt;</bpt>홀수(Odd)<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>짝수(Even)<ept i="6">&lt;/g6&gt;</ept>보다 하나 큰 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this section, we describe some means that help provide
structure to a tactic-style proof, making such proofs more readable
and robust.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142740Z" creationid="tlqk35" creationdate="20220524T142740Z">
        <seg>이 섹션에서 우리는 더욱 가독성있고 강건한 전략 스타일의 증명을 만들 구조를 
제공하도록 돕는 몇몇 수단을 설명할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this section, we discuss some
additional features of the proof language that are often convenient.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183301Z" creationid="tlqk35" creationdate="20220321T183301Z">
        <seg>이 섹션에서는 종종 편리한 증명 언어의 몇 가지 추가적인 기능에 대해 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this section, we will deal with <bpt i="4" x="4">&lt;g4&gt;</bpt>structural recursion<ept i="4">&lt;/g4&gt;</ept>, in
which the arguments to <bpt i="5" x="5">&lt;g5&gt;</bpt>foo<ept i="5">&lt;/g5&gt;</ept> occurring on the right-hand side of the
<bpt i="6" x="6">&lt;g6&gt;</bpt>:=<ept i="6">&lt;/g6&gt;</ept> are subterms of the patterns on the left-hand side.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172050Z" creationid="tlqk3" creationdate="20220529T172050Z">
        <seg>이 섹션에서 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>구조적 재귀<ept i="4">&lt;/g4&gt;</ept>를 다룰 예정입니다. 여기서 <bpt i="5" x="5">&lt;g5&gt;</bpt>foo<ept i="5">&lt;/g5&gt;</ept>에 대한 인수는 좌변에 대한 패턴의 부분항인 <bpt i="6" x="6">&lt;g6&gt;</bpt>:=<ept i="6">&lt;/g6&gt;</ept>의 우변에서 나타납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In this section, we will describe and explain
the various extension points.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T120110Z" creationid="tlqk3" creationdate="20220526T120110Z">
        <seg>이 섹션에서 우리는 다양한 확장성에 대해 보여주고 설명할 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In type theory it is common to say <bpt i="2" x="2">&lt;g2&gt;</bpt>motive<ept i="2">&lt;/g2&gt;</ept> is the <bpt i="3" x="3">&lt;g3&gt;</bpt>motive<ept i="3">&lt;/g3&gt;</ept> for the elimination/recursion,
since it describes the kind of object we wish to construct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155531Z" creationid="tlqk3" creationdate="20220527T155531Z">
        <seg>유형론에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>motive<ept i="2">&lt;/g2&gt;</ept>가 제거/재귀에 대한 <bpt i="3" x="3">&lt;g3&gt;</bpt>motive<ept i="3">&lt;/g3&gt;</ept>다 라고 흔히 말합니다. 왜냐하면 이는 우리가 생성하고자 하는 대산의 종류를 설명하기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>In type theory, this is generally more convenient than
writing <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat.add<ept i="10">&lt;/g10&gt;</ept> as a function that takes a pair of natural numbers as
input and returns a natural number as output.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140842Z" creationid="tlqk35" creationdate="20220321T140842Z">
        <seg>유형론에서 보통 <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat.add<ept i="10">&lt;/g10&gt;</ept>과 같이 쓰는 것이 자연수 쌍을 입력으로 받고 자연수를 출력으로 하는 함수로 쓰는 것보다 더 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inaccessible Patterns</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183215Z" creationid="tlqk3" creationdate="20220603T183215Z">
        <seg>접근할 수 없는 패턴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inaccessible patterns can be used to clarify and control definitions that
make use of dependent pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145319Z" creationid="tlqk3" creationdate="20220604T145319Z">
        <seg>접근불가한 패턴은 명확성과 종속 패턴 매칭을 활용하는 정의 제어를 위해 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Incidentally, just as <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept> has only an elimination rule, <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>
has only an introduction rule, <bpt i="3" x="3">&lt;g3&gt;</bpt>True.intro : true<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164549Z" creationid="tlqk35" creationdate="20220321T164549Z">
        <seg>참고로 <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept>은 제거 규칙만 있듯이 <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>는 도입 규칙 <bpt i="3" x="3">&lt;g3&gt;</bpt>True.intro : true<ept i="3">&lt;/g3&gt;</ept>만 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed,
it is the "failure" state that causes the <bpt i="1" x="1">&lt;g1&gt;</bpt>first<ept i="1">&lt;/g1&gt;</ept> combinator to
backtrack and try the next tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151249Z" creationid="tlqk35" creationdate="20220524T151249Z">
        <seg>당연히 <bpt i="1" x="1">&lt;g1&gt;</bpt>first<ept i="1">&lt;/g1&gt;</ept> 조합자가 원래대로 돌아와 다음 전략을 시도하도록 하는 "실패" 상태입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, if <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept> is any proposition, Lean's kernel treats any
two elements <bpt i="2" x="2">&lt;g2&gt;</bpt>t1 t2 : p<ept i="2">&lt;/g2&gt;</ept> as being definitionally equal, much the
same way as it treats <bpt i="3" x="3">&lt;g3&gt;</bpt>(fun x =&gt; t) s<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>t[s/x]<ept i="4">&lt;/g4&gt;</ept> as
definitionally equal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160239Z" creationid="tlqk35" creationdate="20220321T160239Z">
        <seg>물론 <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept>이 어떤 명제라면, 린의 커널은 임의의 두 원소 <bpt i="2" x="2">&lt;g2&gt;</bpt>t2 : p <ept i="2">&lt;/g2&gt;</ept>을 <bpt i="3" x="3">&lt;g3&gt;</bpt>(fun x = t) s<ept i="3">&lt;/g3&gt;</ept>와 <bpt i="4" x="4">&lt;g4&gt;</bpt>t[/x]<ept i="4">&lt;/g4&gt;</ept>를 정의상으로 동등하다고 같다는 것과 거의 같은 방식으로 정의상 동등하게 취급합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184450Z" creationid="tlqk35" creationdate="20220321T184450Z">
        <seg>실제로 위의 예에서 "sorry"를 밑줄로 바꾸면 린은 바로 이 목표가 해결되지 않은 상태로 남아 있다고 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, in dependent type theory (and in Lean), <bpt i="11" x="11">&lt;g11&gt;</bpt>α → β<ept i="11">&lt;/g11&gt;</ept>
is just notation for <bpt i="12" x="12">&lt;g12&gt;</bpt>(a : α) → β<ept i="12">&lt;/g12&gt;</ept> when <bpt i="13" x="13">&lt;g13&gt;</bpt>β<ept i="13">&lt;/g13&gt;</ept> does not depend on <bpt i="14" x="14">&lt;g14&gt;</bpt>a<ept i="14">&lt;/g14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152055Z" creationid="tlqk35" creationdate="20220321T152055Z">
        <seg>물론, 종속 유형론에서(그리고 Lean에서) <bpt i="11" x="11">&lt;g11&gt;</bpt>α → β<ept i="11">&lt;/g11&gt;</ept>는 <bpt i="13" x="13">&lt;g13&gt;</bpt>β<ept i="13">&lt;/g13&gt;</ept>가 <bpt i="14" x="14">&lt;g14&gt;</bpt>a<ept i="14">&lt;/g14&gt;</ept>에 의존하지 않을 때 <bpt i="12" x="12">&lt;g12&gt;</bpt>(a : α) → β<ept i="12">&lt;/g12&gt;</ept>에 대한 표기일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Indeed, it would defeat most of the potential benefits of ad-hoc
polymorphism.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153655Z" creationid="tlqk3" creationdate="20220604T153655Z">
        <seg>물론 이는 특수 목적 다형성의 잠재적 이점의 대부분을 좌절시킬 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Induction and Recursion</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T155833Z" creationid="tlqk3" creationdate="20220529T155833Z">
        <seg>귀납과 재귀</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inductive Families</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152503Z" creationid="tlqk3" creationdate="20220527T173226Z">
        <seg>귀납군</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inductive Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151746Z" creationid="tlqk3" creationdate="20220526T141517Z">
        <seg>귀납형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inductively Defined Propositions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151402Z" creationid="tlqk3" creationdate="20220527T151402Z">
        <seg>귀납적으로 정의된 명제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inductively defined types can live in any type universe, including the
bottom-most one, <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151511Z" creationid="tlqk3" creationdate="20220527T151511Z">
        <seg>귀납적으로 정의된 유형은 가장 바닥의 것인 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>을 포함하는 임의의 유형 세계에 살 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inferring this predicate therefore requires an instance
of <bpt i="3" x="3">&lt;g3&gt;</bpt>higher-order unification<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180055Z" creationid="tlqk35" creationdate="20220321T180055Z">
        <seg>이 술어를 추론하는 것은 그러므로 <bpt i="3" x="3">&lt;g3&gt;</bpt>고차 통합<ept i="3">&lt;/g3&gt;</ept>의 개체를 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Informally, the
introduction rule states:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172855Z" creationid="tlqk35" creationdate="20220321T172855Z">
        <seg>비공식적으로 도입 규칙은 다음과 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Informally, you might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof
term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184307Z" creationid="tlqk35" creationdate="20220321T184307Z">
        <seg>비공식적으로 "앞방향으로 증명하고, 정의를 펼치고, 이전 보조 정리를 적용하고, 단순화하십시오."라고 말함으로써 수학적 증명을 시작할 수 있습니다. 이것이 독자에게 관련 증명을 찾는 방법을 알려주는 지침인 것처럼 전략은 Lean에게 증명 항를 생성하는 방법을 알려주는 지침입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Information as to how
the search path is determined can be found on the
<bpt i="3" x="3">&lt;g3&gt;</bpt>documentation pages<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174257Z" creationid="tlqk35" creationdate="20220524T174257Z">
        <seg>어떻게 탐색경로가 결정되는지에 대한 정보는 <bpt i="3" x="3">&lt;g3&gt;</bpt>documentation pages<ept i="3">&lt;/g3&gt;</ept>에서 찾아볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inheritance</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180657Z" creationid="tlqk35" creationdate="20220528T180657Z">
        <seg>상속(Inheritance)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Inside a tactic block, one can use the keyword <bpt i="1" x="1">&lt;g1&gt;</bpt>conv<ept i="1">&lt;/g1&gt;</ept> to enter
conversion mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181847Z" creationid="tlqk3" creationdate="20220604T181847Z">
        <seg>전략 블록 안에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>conv<ept i="1">&lt;/g1&gt;</ept> 키워드를 사용하여 전환 모드로 들어갈 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instances
which are declared last are tried first.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181321Z" creationid="tlqk3" creationdate="20220604T181302Z">
        <seg>마지막에 선언된 개체가 가장 먼저 시도됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instances declared in
namespaces which are opened later are tried earlier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181445Z" creationid="tlqk3" creationdate="20220604T181445Z">
        <seg>이름공간에 선언된 개체는 나중에 열린 것이 더 일찍 시도됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of <bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>succ<ept i="2">&lt;/g2&gt;</ept>, we can use more familiar notation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161323Z" creationid="tlqk3" creationdate="20220529T161323Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>succ<ept i="2">&lt;/g2&gt;</ept> 대신 우리는 더 친숙한 기호를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of a single
token, the <bpt i="3" x="3">&lt;g3&gt;</bpt>notation<ept i="3">&lt;/g3&gt;</ept> command accepts a mixed sequence of tokens and
named term placeholders with precedences, which can be referenced on
the right-hand side of <bpt i="4" x="4">&lt;g4&gt;</bpt>=&gt;<ept i="4">&lt;/g4&gt;</ept> and will be replaced by the respective
term parsed at that position.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122730Z" creationid="tlqk3" creationdate="20220526T122730Z">
        <seg>한 토큰 대신 <bpt i="3" x="3">&lt;g3&gt;</bpt>notation<ept i="3">&lt;/g3&gt;</ept> 명령은 토큰의 혼합된 열과 이름이 붙고 우선순위가 있는 항 자리차지자를 받아들입니다. 그리고 이는<bpt i="4" x="4">&lt;g4&gt;</bpt>=&gt;<ept i="4">&lt;/g4&gt;</ept>의 우변을 참조할 수 있고 그 위치에서 구문 분석된 개별적인 항으로 대체될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Instead of using <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept>, you can use
an underscore <bpt i="2" x="2">&lt;g2&gt;</bpt>_<ept i="2">&lt;/g2&gt;</ept> as a placeholder.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170429Z" creationid="tlqk35" creationdate="20220321T170429Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept>를 사용하는 것 대신 밑줄 문자  <bpt i="2" x="2">&lt;g2&gt;</bpt>_<ept i="2">&lt;/g2&gt;</ept>를 자리 차지자로 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Interacting with Lean</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172630Z" creationid="tlqk35" creationdate="20220524T172630Z">
        <seg>린과 상호작용하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Internally, the expression <bpt i="1" x="1">&lt;g1&gt;</bpt>have h : p := s; t<ept i="1">&lt;/g1&gt;</ept> produces the term
<bpt i="2" x="2">&lt;g2&gt;</bpt>(fun (h : p) =&gt; t) s<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165138Z" creationid="tlqk35" creationdate="20220321T165138Z">
        <seg>내부적으로 표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>have h : p := s; t<ept i="1">&lt;/g1&gt;</ept>은 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>(fun (h : p) =&gt; t) s<ept i="2">&lt;/g2&gt;</ept>을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Introducing Auxiliary Subgoals</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165041Z" creationid="tlqk35" creationdate="20220321T165041Z">
        <seg>부가적인 하위 목표를 도입하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131051Z" creationid="tlqk35" creationdate="20220321T131051Z">
        <seg>소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively,
<bpt i="7" x="7">&lt;g7&gt;</bpt>Nat<ept i="7">&lt;/g7&gt;</ept> is the "smallest" type with these constructors, meaning that
it is exhaustively (and freely) generated by starting with <bpt i="8" x="8">&lt;g8&gt;</bpt>zero<ept i="8">&lt;/g8&gt;</ept>
and applying <bpt i="9" x="9">&lt;g9&gt;</bpt>succ<ept i="9">&lt;/g9&gt;</ept> repeatedly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154629Z" creationid="tlqk3" creationdate="20220527T154629Z">
        <seg>직관적으로 <bpt i="7" x="7">&lt;g7&gt;</bpt>Nat<ept i="7">&lt;/g7&gt;</ept>은 이 생성자에서 "가장 작은" 유형입니다. <bpt i="8" x="8">&lt;g8&gt;</bpt>zero<ept i="8">&lt;/g8&gt;</ept>으로 시작하여 <bpt i="9" x="9">&lt;g9&gt;</bpt>succ<ept i="9">&lt;/g9&gt;</ept>를 반복적으로 적용함으로 남김없이 (그리고 자유롭게) 생성됨을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, an inductive type is built up from a specified list of
constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151759Z" creationid="tlqk3" creationdate="20220526T142221Z">
        <seg>당연히 귀납형은 생성자의 명시된 리스트로부터 만들어집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, our proof of
<bpt i="3" x="3">&lt;g3&gt;</bpt>p → q → p<ept i="3">&lt;/g3&gt;</ept> assumes <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept> are true, and uses the first
hypothesis (trivially) to establish that the conclusion, <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept>, is
true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160813Z" creationid="tlqk35" creationdate="20220321T160813Z">
        <seg>직관적으로  <bpt i="3" x="3">&lt;g3&gt;</bpt>p → q → p<ept i="3">&lt;/g3&gt;</ept>에 대한 우리의 증명은 <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>와 <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>가 참이라고 가정한다. 그리고 (명백히) 첫 번 째 가정을 <bpt i="6" x="6">&lt;g6&gt;</bpt>p<ept i="6">&lt;/g6&gt;</ept>가 참이라는 결론을 세우기 위해 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, the constructive "Or" is very strong: asserting <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ q<ept i="1">&lt;/g1&gt;</ept>
amounts to knowing which is the case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165726Z" creationid="tlqk35" creationdate="20220321T165726Z">
        <seg>직관적으로 구성자 "논리합"은 아주 강력합니다.  <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ q<ept i="1">&lt;/g1&gt;</ept>라 주장하는 것은 각 경우를 아는 것과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Intuitively, the only way to construct a proof of <bpt i="8" x="8">&lt;g8&gt;</bpt>Eq a x<ept i="8">&lt;/g8&gt;</ept>
is to use reflexivity, in the case where <bpt i="9" x="9">&lt;g9&gt;</bpt>x<ept i="9">&lt;/g9&gt;</ept> is <bpt i="10" x="10">&lt;g10&gt;</bpt>a<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153855Z" creationid="tlqk35" creationdate="20220528T153855Z">
        <seg>직관적으로 <bpt i="8" x="8">&lt;g8&gt;</bpt>Eq a x<ept i="8">&lt;/g8&gt;</ept>의 증명을 생성하는 유일한 방법은 <bpt i="9" x="9">&lt;g9&gt;</bpt>x<ept i="9">&lt;/g9&gt;</ept>가 <bpt i="10" x="10">&lt;g10&gt;</bpt>a<ept i="10">&lt;/g10&gt;</ept>인 경우 반사성을 사용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It
allows us to prove a proposition <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept> from <bpt i="4" x="4">&lt;g4&gt;</bpt>∃ x : α, p x<ept i="4">&lt;/g4&gt;</ept>, by
showing that <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept> follows from <bpt i="6" x="6">&lt;g6&gt;</bpt>p w<ept i="6">&lt;/g6&gt;</ept> for an arbitrary value
<bpt i="7" x="7">&lt;g7&gt;</bpt>w<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181249Z" creationid="tlqk35" creationdate="20220321T181249Z">
        <seg>임의의 값 <bpt i="7" x="7">&lt;g7&gt;</bpt>w<ept i="7">&lt;/g7&gt;</ept>에 대해 <bpt i="6" x="6">&lt;g6&gt;</bpt>p w<ept i="6">&lt;/g6&gt;</ept>로부터 <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>임을 보임으로써 <bpt i="4" x="4">&lt;g4&gt;</bpt>∃ x : α, p x<ept i="4">&lt;/g4&gt;</ept>으로부터 명제 <bpt i="3" x="3">&lt;g3&gt;</bpt>q<ept i="3">&lt;/g3&gt;</ept>를 증명하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It accepts the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171635Z" creationid="tlqk3" creationdate="20220603T171635Z">
        <seg>이것은 다음을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It allows you to
define a function by specifying equations that it should satisfy, and
it allows you to prove a theorem by specifying how to handle various
cases that can arise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160321Z" creationid="tlqk3" creationdate="20220529T160321Z">
        <seg>이는 여러분이 그것이 만족해야 하는 방정식을 명시함으로써 함수를 정의하도록 해줍니다. 그리고 이것은 일어날 수 있는 다양한 경우를 어떻게 다뤄야 하는지 나타내줌으로써 여러분이 정리를 증명하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It also knows a number of ways of constructing new well
founded orders from others, for example, using lexicographic order.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170430Z" creationid="tlqk3" creationdate="20220603T170430Z">
        <seg>이것도 다른 것으로부터 새로운 잘 세워진 순서를 생성하는 많은 방법을 알고 있습니다. 예를 들어 사전적 순서를 사용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It also makes proofs more readable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183644Z" creationid="tlqk35" creationdate="20220321T183644Z">
        <seg>또 이것은 증명을 더 가독성있게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It also uses other rules that have been previously declared to
the system, and applies commutativity wisely to avoid looping.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180518Z" creationid="tlqk35" creationdate="20220321T180518Z">
        <seg>또 이것은 시스템에서 전에 선언된 적 있는 다른 규칙을 사용합니다.그리고 무한 루프를 현명하게 피하면서 교환성을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It can even combine different relations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180647Z" creationid="tlqk35" creationdate="20220321T180647Z">
        <seg>심지어 이것은 다른 관계와 혼합될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It closes the current goal, producing the usual warning
that <bpt i="3" x="3">&lt;g3&gt;</bpt>sorry<ept i="3">&lt;/g3&gt;</ept> has been used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065446Z" creationid="tlqk35" creationdate="20220522T065446Z">
        <seg>이것은 현재 목표를 마무리 짓고, <bpt i="3" x="3">&lt;g3&gt;</bpt>sorry<ept i="3">&lt;/g3&gt;</ept>를 사용했을 때처럼 경고를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It determines
the necessary case splits from the patterns that are presented to it,
and raises an error if the patterns fail to exhaust the cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162407Z" creationid="tlqk3" creationdate="20220529T162226Z">
        <seg>이것은 그것에 제시된 패턴에 필요한 경우를 나누는 것을 결정하고, 패턴이 경우를 처리하는데 실패하면 오류를 발생시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It does not affect the code generator which compiles recursive
functions as other functional programming language compilers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165033Z" creationid="tlqk3" creationdate="20220603T164937Z">
        <seg>다른 함수형 프로그래밍 언어의 컴파일러와 마찬가지로 이것은 재귀 함수를 컴파일하는 코드 생성기에 영향을 끼치지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It enables us to define the value of a dependent
function of type <bpt i="6" x="6">&lt;g6&gt;</bpt>(n : Nat) → C n<ept i="6">&lt;/g6&gt;</ept> at a particular input <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept> in terms of all the previous values of the function,
presented as an element of <bpt i="8" x="8">&lt;g8&gt;</bpt>@Nat.below C n<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165017Z" creationid="tlqk3" creationdate="20220603T164635Z">
        <seg>이것은 <bpt i="8" x="8">&lt;g8&gt;</bpt>@Nat.below C n<ept i="8">&lt;/g8&gt;</ept>의 원소로 나타났던 함수의 모든 이전의 값들로 특정 입력 <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>에 대해 <bpt i="6" x="6">&lt;g6&gt;</bpt>(n : Nat) → C n<ept i="6">&lt;/g6&gt;</ept>형의 종속함수의 값을 정의할 수 있게 해줍니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It falls outside the
strict specification of an inductive type given in the last section
because <bpt i="2" x="2">&lt;g2&gt;</bpt>Tree<ept i="2">&lt;/g2&gt;</ept> does not occur strictly positively among the
arguments to <bpt i="3" x="3">&lt;g3&gt;</bpt>mk<ept i="3">&lt;/g3&gt;</ept>, but, rather, nested inside the <bpt i="4" x="4">&lt;g4&gt;</bpt>List<ept i="4">&lt;/g4&gt;</ept> type
constructor.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152413Z" creationid="tlqk35" creationdate="20220528T170602Z">
        <seg>이것은 마지막 섹션에서 제시된 귀납형의 엄격한 명세를 바깥으로 빠져나옵니다. 왜냐하면 <bpt i="2" x="2">&lt;g2&gt;</bpt>Tree<ept i="2">&lt;/g2&gt;</ept>는 <bpt i="3" x="3">&lt;g3&gt;</bpt>mk<ept i="3">&lt;/g3&gt;</ept>에 대한 인수 사이에서 엄격하게 긍정적으로 일어나지 않고 대신  <bpt i="4" x="4">&lt;g4&gt;</bpt>List<ept i="4">&lt;/g4&gt;</ept>형 생성자의 중첩된 안쪽에서 일어나기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It has
the important property that every assertion respects the equivalence,
in the sense that we can substitute equal expressions without changing
the truth value.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175710Z" creationid="tlqk35" creationdate="20220321T175710Z">
        <seg>우리가  같은 표현식들을 진리값을 바꾸지 않고 대체할 수 있다는 점에서 등가에 대한 모든 주장은 중요한 성질이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It has a compiler that
generates a binary executable and an interactive interpreter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143751Z" creationid="tlqk35" creationdate="20220321T143751Z">
        <seg>이것은 이진 실행 프로그램을 만드는 컴파일러와 상호작용적인 인터프리터를 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It has to handle two cases: the case where the input is <bpt i="7" x="7">&lt;g7&gt;</bpt>zero<ept i="7">&lt;/g7&gt;</ept>, and the case where
the input is of the form <bpt i="8" x="8">&lt;g8&gt;</bpt>succ n<ept i="8">&lt;/g8&gt;</ept> for some <bpt i="9" x="9">&lt;g9&gt;</bpt>n : Nat<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155021Z" creationid="tlqk3" creationdate="20220527T155021Z">
        <seg>이것은 입력이 <bpt i="7" x="7">&lt;g7&gt;</bpt>zero<ept i="7">&lt;/g7&gt;</ept>인 경우와  입력이 어떤 <bpt i="9" x="9">&lt;g9&gt;</bpt>n : Nat<ept i="9">&lt;/g9&gt;</ept>에 대해 <bpt i="8" x="8">&lt;g8&gt;</bpt>succ n<ept i="8">&lt;/g8&gt;</ept> 꼴인 입력에 대한 경우 두가지를 다뤄야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It has type <bpt i="2" x="2">&lt;g2&gt;</bpt>{α : Sort u} → [i : α] → α<ept i="2">&lt;/g2&gt;</ept>,
and is useful for triggering the type class resolution procedure when the expected type is an instance.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161742Z" creationid="tlqk3" creationdate="20220604T161742Z">
        <seg>이것은 <bpt i="2" x="2">&lt;g2&gt;</bpt>{α : Sort u} → [i : α] → α<ept i="2">&lt;/g2&gt;</ept>형이고 예상 유형이 개체일 때 유형 클래스 해결 절차를 일으키는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is
equivalent to <bpt i="6" x="6">&lt;g6&gt;</bpt>first | t | skip<ept i="6">&lt;/g6&gt;</ept>, where <bpt i="7" x="7">&lt;g7&gt;</bpt>skip<ept i="7">&lt;/g7&gt;</ept> is a tactic that does
nothing (and succeeds in doing so).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151558Z" creationid="tlqk35" creationdate="20220524T151558Z">
        <seg>이는 <bpt i="6" x="6">&lt;g6&gt;</bpt>first | t | skip<ept i="6">&lt;/g6&gt;</ept>과 동일합니다. 여기서 <bpt i="7" x="7">&lt;g7&gt;</bpt>skip<ept i="7">&lt;/g7&gt;</ept>은 
아무것도 하지 않는(그리고 그것의 실행에서 성공하는) 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is
needed in the following example because, from a constructive
standpoint, knowing that <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept> are not both true does not
necessarily tell you which one is false:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170025Z" creationid="tlqk35" creationdate="20220321T170025Z">
        <seg>다음 예제에서 이게 필요한데 왜냐하면 직관주의적 관점에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept> 둘 다 참이 아니라는 것을 아는 것은 여러분에게 반드시 어떤 것이 거짓이라는 것을 말해줄 필요는 없기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is a remarkable fact that all the basic axioms for equality follow
from the constructor, <bpt i="1" x="1">&lt;g1&gt;</bpt>refl<ept i="1">&lt;/g1&gt;</ept>, and the eliminator, <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.rec<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154127Z" creationid="tlqk35" creationdate="20220528T154127Z">
        <seg>동등성에 대한 모든 기본 공리는 생성자 <bpt i="1" x="1">&lt;g1&gt;</bpt>refl<ept i="1">&lt;/g1&gt;</ept>과 제거자 <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.rec<ept i="2">&lt;/g2&gt;</ept>로부터 따라 나온다는 사실은 주목할만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is also known
as a <bpt i="7" x="7">&lt;g7&gt;</bpt>recursor<ept i="7">&lt;/g7&gt;</ept>, and it is what makes the type "inductive": it allows
us to define a function on <bpt i="8" x="8">&lt;g8&gt;</bpt>Weekday<ept i="8">&lt;/g8&gt;</ept> by assigning values
corresponding to each constructor.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T150005Z" creationid="tlqk3" creationdate="20220526T150005Z">
        <seg>이는 <bpt i="7" x="7">&lt;g7&gt;</bpt>recursor<ept i="7">&lt;/g7&gt;</ept>로도 알려져 있고, 이게 유형을 "유도적"으로 만드는 것입니다. 이게 각 생성자에 대응하는 값을 할당함으로 <bpt i="8" x="8">&lt;g8&gt;</bpt>Weekday<ept i="8">&lt;/g8&gt;</ept>에 함수를 정의할 수 있게 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is also known as the <bpt i="6" x="6">&lt;g6&gt;</bpt>major premise<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155811Z" creationid="tlqk3" creationdate="20220527T155811Z">
        <seg>이것은 <bpt i="6" x="6">&lt;g6&gt;</bpt>주요 전제<ept i="6">&lt;/g6&gt;</ept>로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is also more robust than <bpt i="4" x="4">&lt;g4&gt;</bpt>apply<ept i="4">&lt;/g4&gt;</ept>, since the
elaborator takes the expected type, given by the target of the goal,
into account when processing the expression that is being applied.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055322Z" creationid="tlqk35" creationdate="20220522T055322Z">
        <seg>이것은 <bpt i="4" x="4">&lt;g4&gt;</bpt>apply<ept i="4">&lt;/g4&gt;</ept>보다 더 강건합니다. 왜냐하면 
협력기는 적용될 표현식을 처리할 때 목표의 대상에 의해 
제시된 예상 유형을 받기를 기대하기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is an ongoing, long-term
effort, and much of the potential for automation will be realized only gradually over time.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131736Z" creationid="tlqk35" creationdate="20220321T131736Z">
        <seg>이것은 장기적으로 현재진행 중이고 자동화에 대한 대부분의 잠재성은 시간이 지나면서 점차 실현될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is clear that <bpt i="1" x="1">&lt;g1&gt;</bpt>cons α<ept i="1">&lt;/g1&gt;</ept> should have type <bpt i="2" x="2">&lt;g2&gt;</bpt>α → List α → List α<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151301Z" creationid="tlqk35" creationdate="20220321T151301Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cons α<ept i="1">&lt;/g1&gt;</ept>가  <bpt i="2" x="2">&lt;g2&gt;</bpt>α → List α → List α<ept i="2">&lt;/g2&gt;</ept> 유형을 가져야 함은 분명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is common to describe
<bpt i="5" x="5">&lt;g5&gt;</bpt>And.intro<ept i="5">&lt;/g5&gt;</ept> as the <bpt i="6" x="6">&lt;g6&gt;</bpt>and-introduction<ept i="6">&lt;/g6&gt;</ept> rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162615Z" creationid="tlqk35" creationdate="20220321T162615Z">
        <seg><bpt i="5" x="5">&lt;g5&gt;</bpt>And.intro<ept i="5">&lt;/g5&gt;</ept>를 <bpt i="6" x="6">&lt;g6&gt;</bpt>and-도입<ept i="6">&lt;/g6&gt;</ept> 규칙이라고 설명하는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is common to iterate constructions like "And." Lean also allows you
to flatten nested constructors that associate to the right, so that
these two proofs are equivalent:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163527Z" creationid="tlqk35" creationdate="20220321T163527Z">
        <seg>"And"같은 반복적 생성은 흔합니다. 두 증명이 동등함을 보이기 위해 린은 여러분에게 오른쪽에 연관된 중첩된 생성자를 평평하게 만들도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is common to use a similar trick with the <bpt i="1" x="1">&lt;g1&gt;</bpt>List.map<ept i="1">&lt;/g1&gt;</ept> function,
which takes a list as its second non-implicit argument:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181835Z" creationid="tlqk35" creationdate="20220528T181835Z">
        <seg>두 번째 비암시적인 인자로써 리스트를 받는 <bpt i="1" x="1">&lt;g1&gt;</bpt>List.map<ept i="1">&lt;/g1&gt;</ept> 함수로 비슷한 트릭을 쓰는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is convenient for illustration,
and we will use it often.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162714Z" creationid="tlqk35" creationdate="20220321T162714Z">
        <seg>이는 설명에 유용하고 예제 명령을 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is defined as
follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172605Z" creationid="tlqk3" creationdate="20220604T172605Z">
        <seg>이것은 다음과 같이 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is good form to use
it in a tactic proof, since its failure signals that something has
gone wrong.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055131Z" creationid="tlqk35" creationdate="20220522T055131Z">
        <seg>전략 증명모드에서 이것은 사용하기에 좋은 형태입니다. 
왜냐하면 그것의 실패는 무언가 잘못되었음을 알려주기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is just the macro.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184404Z" creationid="tlqk3" creationdate="20220604T184404Z">
        <seg>이것은 그저 매크로입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is modeled after subset notation in set theory: the idea is that <bpt i="3" x="3">&lt;g3&gt;</bpt>{x : α // p x}<ept i="3">&lt;/g3&gt;</ept>
denotes the collection of elements of <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept> that have property <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153639Z" creationid="tlqk3" creationdate="20220527T153639Z">
        <seg>집합론에서 부분집합 표기 이후에 모델되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is not hard to prove that <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq<ept i="1">&lt;/g1&gt;</ept> is symmetric and transitive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154600Z" creationid="tlqk35" creationdate="20220528T154600Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Eq<ept i="1">&lt;/g1&gt;</ept>가 대칭적이고 추이적임을 증명하는 것은 어렵지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is often possible to bring a component of a formula outside a
universal quantifier, when it does not depend on the quantified
variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183811Z" creationid="tlqk35" creationdate="20220321T183811Z">
        <seg>식이 정량화된 변수에 의존하지 않을 때 종종 전칭 한정기호를 식의 바깥 쪽으로 가져올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is often used when we the expected type is a function type with implicit arguments,
and we have a constant (<bpt i="4" x="4">&lt;g4&gt;</bpt>reader_t.pure<ept i="4">&lt;/g4&gt;</ept> in the example) which also takes implicit arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135307Z" creationid="tlqk3" creationdate="20220526T135307Z">
        <seg>이것은 우리가 기대하는 유형이 암시적인 인자를 갖는 함수 유형일 때 종종 사용합니다. 그리고 우리는 암시적인 인수를 받을 수 있는 상수(예제에서 <bpt i="4" x="4">&lt;g4&gt;</bpt>reader_t.pure<ept i="4">&lt;/g4&gt;</ept>)를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is often useful to group definitions and theorems related to a
structure in a namespace with the same name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151021Z" creationid="tlqk3" creationdate="20220526T151021Z">
        <seg>정의들과 정리들을 같은 이름인 이름공간에 구조체와 연관지어 모으는 것이 종종 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is remarkable that
it is possible to construct a substantial edifice of mathematics based
on nothing more than the type universes, dependent arrow types, and inductive
types; everything else follows from those.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151752Z" creationid="tlqk3" creationdate="20220526T142541Z">
        <seg>유형 세계, 의존 화살표 유형과 귀납형과 그들로부터 나라 나온 모든 것 외에는 아무것도 기반으로 하지 않는 수학의 실질적인 구조를 구성하는 것이 가능하다는 것은 주목할 만합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is represented
by a metavariable, which should be instantiated later on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072123Z" creationid="tlqk35" creationdate="20220522T072123Z">
        <seg>이는 메타변수로 표현되며 나중에 반드시 개체화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is similar to <bpt i="2" x="2">&lt;g2&gt;</bpt>all_goals<ept i="2">&lt;/g2&gt;</ept>, except it fails unless its argument
succeeds on at least one goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172129Z" creationid="tlqk35" creationdate="20220524T152643Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>any_goals<ept i="1">&lt;/g1&gt;</ept>은 그것의 인자가 적어도 한 목표에 대해서도 성공하지 않는 
한 실패하는 경우를 제외하고 <bpt i="2" x="2">&lt;g2&gt;</bpt>all_goals<ept i="2">&lt;/g2&gt;</ept>과 유사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is sometimes useful to <bpt i="1" x="1">&lt;g1&gt;</bpt>export<ept i="1">&lt;/g1&gt;</ept> aliases from one namespace to another, or to the top level.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181416Z" creationid="tlqk3" creationdate="20220525T181416Z">
        <seg>별명을 한 이름 공간에서 다른 곳 혹은 최상위 단계로 <bpt i="1" x="1">&lt;g1&gt;</bpt>내보내기<ept i="1">&lt;/g1&gt;</ept>하는 것은 때때로 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is still tedious, however, to type all these underscores.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153139Z" creationid="tlqk35" creationdate="20220321T153139Z">
        <seg>그래도 여전히 이 밑줄문자를 치는 것은 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is the tactic analogue of a <bpt i="3" x="3">&lt;g3&gt;</bpt>let<ept i="3">&lt;/g3&gt;</ept> in a proof
term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144352Z" creationid="tlqk35" creationdate="20220524T144352Z">
        <seg>이것은 증명항에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>let<ept i="3">&lt;/g3&gt;</ept>과 유사한 전략입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is the typing rule for dependent arrow types, and the universal
quantifier in particular, that distinguishes <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept> from other
types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174429Z" creationid="tlqk35" creationdate="20220321T174429Z">
        <seg>이것은 의존 화살표 유형에 대한 타자 규칙입니다. 특히 그리고 전칭 한정기호는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept> 과 다른 유형들을 구분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It is useful to put such definitions into a namespace, <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160314Z" creationid="tlqk3" creationdate="20220527T160314Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> 이름공간에 그런 정의를 넣는 것은 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It just so happens that the rules for
function application and abstraction can conveniently help us keep
track of which elements of <bpt i="7" x="7">&lt;g7&gt;</bpt>Prop<ept i="7">&lt;/g7&gt;</ept> are inhabited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160048Z" creationid="tlqk35" creationdate="20220321T160048Z">
        <seg>함수 적용 및 추상화 규칙이 <bpt i="7" x="7">&lt;g7&gt;</bpt>Prop<ept i="7">&lt;/g7&gt;</ept>의 원소가 머무르는 것을 우리가 추적하는 것을 편리하게 도울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It makes functions such as
<bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept> much more convenient to write.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134542Z" creationid="tlqk3" creationdate="20220526T134542Z">
        <seg>이것은 <bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept> 같은 함수를 쓰기에 훨씬 더 편리하게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It may be helpful to compare the exists-elimination rule to the
or-elimination rule: the assertion <bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p x<ept i="1">&lt;/g1&gt;</ept> can be thought of
as a big disjunction of the propositions <bpt i="2" x="2">&lt;g2&gt;</bpt>p a<ept i="2">&lt;/g2&gt;</ept>, as <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> ranges over
all the elements of <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181604Z" creationid="tlqk35" creationdate="20220321T181604Z">
        <seg>존재-제거 규칙과 논리합-제거 규칙을 비교하는것은 도움이 아마 도움이 될 것입니다. 왜냐하면 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>가 모든 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>의 요소 범위를 갖기 때문에 명제 <bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p x<ept i="1">&lt;/g1&gt;</ept>은 커다란 명제의 분리자  <bpt i="2" x="2">&lt;g2&gt;</bpt>p a<ept i="2">&lt;/g2&gt;</ept>로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It may seem that commutativity and
left-commutativity are problematic, in that repeated application of
either causes looping.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171738Z" creationid="tlqk35" creationdate="20220524T162327Z">
        <seg>둘 중 어떤 것의 반복적인 활용이 무한루프를 유발한다는 점에서 
교환성과 좌교환성은 문제가 있어 보입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It means
that even though we can treat proofs <bpt i="6" x="6">&lt;g6&gt;</bpt>t : p<ept i="6">&lt;/g6&gt;</ept> as ordinary objects in
the language of dependent type theory, they carry no information
beyond the fact that <bpt i="7" x="7">&lt;g7&gt;</bpt>p<ept i="7">&lt;/g7&gt;</ept> is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160316Z" creationid="tlqk35" creationdate="20220321T160316Z">
        <seg>우리가 증명<bpt i="6" x="6">&lt;g6&gt;</bpt>t : p<ept i="6">&lt;/g6&gt;</ept>을 의존 유형론 언어의 평범한 대상으로 다룰 수 있음에도 <bpt i="7" x="7">&lt;g7&gt;</bpt>p<ept i="7">&lt;/g7&gt;</ept>가 참이라는 사실 이상의 정보를 전달하지 않는다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It often happens that we would like a definition to return an arbitrary element in a "corner case."
For example, we may like the expression <bpt i="1" x="1">&lt;g1&gt;</bpt>head xs<ept i="1">&lt;/g1&gt;</ept> to be of type <bpt i="2" x="2">&lt;g2&gt;</bpt>a<ept i="2">&lt;/g2&gt;</ept> when <bpt i="3" x="3">&lt;g3&gt;</bpt>xs<ept i="3">&lt;/g3&gt;</ept> is of type <bpt i="4" x="4">&lt;g4&gt;</bpt>List a<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155459Z" creationid="tlqk3" creationdate="20220604T155459Z">
        <seg>우리는 정의가 "막다른 경우"에 대해 임의의 원소를 반환하게 만들고 싶은 상황이 종종 있습니다. 예를 들어 <bpt i="3" x="3">&lt;g3&gt;</bpt>xs<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>List a<ept i="4">&lt;/g4&gt;</ept>형일 때 표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>head xs<ept i="1">&lt;/g1&gt;</ept>가 <bpt i="2" x="2">&lt;g2&gt;</bpt>a<ept i="2">&lt;/g2&gt;</ept>형이 되길 좋아합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It represents the familiar
pattern of an inductive proof: to prove <bpt i="4" x="4">&lt;g4&gt;</bpt>∀ n, motive n<ept i="4">&lt;/g4&gt;</ept>, first prove <bpt i="5" x="5">&lt;g5&gt;</bpt>motive 0<ept i="5">&lt;/g5&gt;</ept>,
and then, for arbitrary <bpt i="6" x="6">&lt;g6&gt;</bpt>n<ept i="6">&lt;/g6&gt;</ept>, assume <bpt i="7" x="7">&lt;g7&gt;</bpt>ih : motive n<ept i="7">&lt;/g7&gt;</ept> and prove <bpt i="8" x="8">&lt;g8&gt;</bpt>motive (succ n)<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T161050Z" creationid="tlqk3" creationdate="20220527T161050Z">
        <seg>이는 귀납적 적의의 유사한 패턴을 보여줍니다. <bpt i="4" x="4">&lt;g4&gt;</bpt>∀ n, motive n<ept i="4">&lt;/g4&gt;</ept>을 증명하기 위해 우선 <bpt i="5" x="5">&lt;g5&gt;</bpt>motive 0<ept i="5">&lt;/g5&gt;</ept>을 증명하고 그 뒤 임의의 <bpt i="6" x="6">&lt;g6&gt;</bpt>n<ept i="6">&lt;/g6&gt;</ept>에 대해 <bpt i="7" x="7">&lt;g7&gt;</bpt>ih : motive n<ept i="7">&lt;/g7&gt;</ept>을 가정하고 <bpt i="8" x="8">&lt;g8&gt;</bpt>motive (succ n)<ept i="8">&lt;/g8&gt;</ept>를 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It reverts
these elements, does the split, and reintroduces them.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164711Z" creationid="tlqk3" creationdate="20220527T164711Z">
        <seg>이것은 이 원소를 되돌리고, 나누기를 하고, 그들을 다시 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It says that if <bpt i="2" x="2">&lt;g2&gt;</bpt>≺<ept i="2">&lt;/g2&gt;</ept> is well founded and you want to prove
<bpt i="3" x="3">&lt;g3&gt;</bpt>∀ x, C x<ept i="3">&lt;/g3&gt;</ept>, it suffices to show that for an arbitrary <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>, if we
have <bpt i="5" x="5">&lt;g5&gt;</bpt>∀ y ≺ x, C y<ept i="5">&lt;/g5&gt;</ept>, then we have <bpt i="6" x="6">&lt;g6&gt;</bpt>C x<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170038Z" creationid="tlqk3" creationdate="20220603T170038Z">
        <seg>이것은 만약 <bpt i="2" x="2">&lt;g2&gt;</bpt>≺<ept i="2">&lt;/g2&gt;</ept>이 잘 세워졌고 여러분이 <bpt i="3" x="3">&lt;g3&gt;</bpt>∀ x, C x<ept i="3">&lt;/g3&gt;</ept>을 증명하기 원한다고 말하면, 이는 임의의  <bpt i="4" x="4">&lt;g4&gt;</bpt>x<ept i="4">&lt;/g4&gt;</ept>에 대해 우리가 <bpt i="5" x="5">&lt;g5&gt;</bpt>∀ y ≺ x, C y<ept i="5">&lt;/g5&gt;</ept>이면 <bpt i="6" x="6">&lt;g6&gt;</bpt>C x<ept i="6">&lt;/g6&gt;</ept>임을 보이는 것으로 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It simply declares the type of the
goal that is about to be solved, while remaining in tactic
mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143405Z" creationid="tlqk35" creationdate="20220524T143405Z">
        <seg>전략모드에 남아있는 동안 이것는 단순히 막 풀리려고 하는 목표의 유형을 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It supports the same options available in regular tactic mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184243Z" creationid="tlqk3" creationdate="20220604T184243Z">
        <seg>보통의 전략 모드에서 사용할 수 있는 것과 동일한 옵션을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It then does a case split on
whether <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept> is of the form <bpt i="4" x="4">&lt;g4&gt;</bpt>zero<ept i="4">&lt;/g4&gt;</ept> or <bpt i="5" x="5">&lt;g5&gt;</bpt>succ x<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162124Z" creationid="tlqk3" creationdate="20220529T162124Z">
        <seg>그 뒤 <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>zero<ept i="4">&lt;/g4&gt;</ept>인지 <bpt i="5" x="5">&lt;g5&gt;</bpt>succ x<ept i="5">&lt;/g5&gt;</ept>의 꼴인지에 따라 경우를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It then reduces the
goal to cases in which <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept> is replaced by each of the constructions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164131Z" creationid="tlqk3" creationdate="20220527T164131Z">
        <seg>그 뒤 이것은 목표를 <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept>는 생성자의 각각으로 대체되는 경우로 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It then returns an output appropriate to the input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174027Z" creationid="tlqk3" creationdate="20220603T174027Z">
        <seg>그럼 이것은 입력에 대한 적절한 출력을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It turns out that all commands from the first code block are in fact
command <bpt i="1" x="1">&lt;g1&gt;</bpt>macros<ept i="1">&lt;/g1&gt;</ept> translating to the more general <bpt i="2" x="2">&lt;g2&gt;</bpt>notation<ept i="2">&lt;/g2&gt;</ept> command.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122407Z" creationid="tlqk3" creationdate="20220526T122407Z">
        <seg>첫 번째 코드 블럭으로부터 모든 명령은 사실 <bpt i="1" x="1">&lt;g1&gt;</bpt>macros<ept i="1">&lt;/g1&gt;</ept> 명령이 더 일반적인 <bpt i="2" x="2">&lt;g2&gt;</bpt>notation<ept i="2">&lt;/g2&gt;</ept>명령으로 번역된 것임이 드러납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184630Z" creationid="tlqk35" creationdate="20220321T184630Z">
        <seg>결론을 현재 목표의 표현식과 통합하고 이후 인수가 종속되지 않는 한 나머지 인수에 대한 새 목표를 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It useful to use indendation to structure proof: every time a tactic
leaves more than one subgoal, we separate the remaining subgoals by
enclosing them in blocks and indenting.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145433Z" creationid="tlqk35" creationdate="20220524T145421Z">
        <seg>구조화된 증명에 인덴트를 사용하는 것은 유용합니다. 매번 전략은 한 개 이상의 하위 목표를 남겨두므로 
우리는 블럭과 인덴트로 그들을 담아  남은 하위목표와 분리할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It will also use an "if ... then ... else" instead of a <bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> in appropriate situations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170258Z" creationid="tlqk3" creationdate="20220529T170258Z">
        <seg>이것은 적절한 상황에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> 대신  "if ... then ... else"을 사용할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It will unify metavariables in the conclusion if necessary:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063004Z" creationid="tlqk35" creationdate="20220522T063004Z">
        <seg>이것은 필요하다면 결론의 메타변수들을 통합할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>It would be
much nicer if the list of subtrees were given by the type
<bpt i="1" x="1">&lt;g1&gt;</bpt>List (Tree α)<ept i="1">&lt;/g1&gt;</ept>, especially since Lean's library contains a number of functions
and theorems for working with lists.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T170102Z" creationid="tlqk35" creationdate="20220528T170102Z">
        <seg>만약 하위트리의 리스트가 <bpt i="1" x="1">&lt;g1&gt;</bpt>List (Tree α)<ept i="1">&lt;/g1&gt;</ept>형으로 제시된다면 훨씬 더 좋을 것입니다. 왜냐하면 특이 린의 라이브러리가 리스트와 작업할 수 있는 다수의 함수와 정리를 담고 있기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Iterating such
rewrites produces nontrivial propositional reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171647Z" creationid="tlqk35" creationdate="20220524T164027Z">
        <seg>이 다시쓰기를 반복하는 것은 명백하지 않은 명제논리적 추론을 만들어 냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Its use is also not limited to propositions,
though using it for data is somewhat odd:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183723Z" creationid="tlqk35" creationdate="20220321T183723Z">
        <seg>그것의 용도는 명제에마 국한되지 않고 약간 이상하지만 데이터에 대해서도 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Just as dependent function types <bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α) → β a<ept i="1">&lt;/g1&gt;</ept> generalize the
notion of a function type <bpt i="2" x="2">&lt;g2&gt;</bpt>α → β<ept i="2">&lt;/g2&gt;</ept> by allowing <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept> to depend on
<bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>, dependent Cartesian product types <bpt i="5" x="5">&lt;g5&gt;</bpt>(a : α) × β a<ept i="5">&lt;/g5&gt;</ept> generalize
the Cartesian product <bpt i="6" x="6">&lt;g6&gt;</bpt>α × β<ept i="6">&lt;/g6&gt;</ept> in the same way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152228Z" creationid="tlqk35" creationdate="20220321T152228Z">
        <seg>의존적 함수 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α) → β a<ept i="1">&lt;/g1&gt;</ept>는 함수의 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>α → β<ept i="2">&lt;/g2&gt;</ept>의 개념을 <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>에 종속적이라고 함으로써 일반화한 것처럼 의존적 카테시안 곱 유형은 <bpt i="5" x="5">&lt;g5&gt;</bpt>(a : α) × β a<ept i="5">&lt;/g5&gt;</ept>는 카테시안 곱 <bpt i="6" x="6">&lt;g6&gt;</bpt>α × β<ept i="6">&lt;/g6&gt;</ept>를 같은 방식으로 일반화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Just as the <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic can be used to carry out proof by cases,
the <bpt i="2" x="2">&lt;g2&gt;</bpt>induction<ept i="2">&lt;/g2&gt;</ept> tactic can be used to carry out proofs by
induction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171959Z" creationid="tlqk3" creationdate="20220527T171959Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략은 경우에 따른 증명을 수행하는데 사용될 수 있다. <bpt i="2" x="2">&lt;g2&gt;</bpt>induction<ept i="2">&lt;/g2&gt;</ept> 전략은 귀납으로 증명을 수행하는데 사용될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Just as the constructive "or" is stronger than the classical "or," so,
too, is the constructive "exists" stronger than the classical
"exists".</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183014Z" creationid="tlqk35" creationdate="20220321T183014Z">
        <seg>직관주의적 "or"은 고전주의의 "or"보다 강한 것처럼 직관주의적 "존재한다"도 고전주의적 "존재한다"보다 강한 의미를 가집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Keep in mind that the notation <bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p<ept i="1">&lt;/g1&gt;</ept> is syntactic sugar for <bpt i="2" x="2">&lt;g2&gt;</bpt>Exists (fun x : α =&gt; p)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T152800Z" creationid="tlqk3" creationdate="20220527T152800Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p<ept i="1">&lt;/g1&gt;</ept> 기호는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Exists (fun x : α =&gt; p)<ept i="2">&lt;/g2&gt;</ept>에 대한 문법적 설탕임을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Keep in mind that you can use the French quotation marks in this way
to refer to <bpt i="1" x="1">&lt;g1&gt;</bpt>anything<ept i="1">&lt;/g1&gt;</ept> in the context, not just things that were
introduced anonymously.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183716Z" creationid="tlqk35" creationdate="20220321T183716Z">
        <seg>여러분은 프랑스 인용부호를 맥락 속에서 익명으로 도입된 것들 뿐만 아니라 <bpt i="1" x="1">&lt;g1&gt;</bpt>어떤 것이든<ept i="1">&lt;/g1&gt;</ept> 참조하기 위해 사용될 수 있다는 점을 명심하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Later, we show how you can extend the proof language using the Lean macro system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183733Z" creationid="tlqk35" creationdate="20220321T183733Z">
        <seg>나중에 우리는 린의 매크로 시스템을 사용해서 증명 언어를 확장하는 방법을 소개합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Later, we will see that <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited<ept i="3">&lt;/g3&gt;</ept> is
an example of a <bpt i="4" x="4">&lt;g4&gt;</bpt>type class<ept i="4">&lt;/g4&gt;</ept> in Lean: Lean can be instructed that
suitable base types are inhabited, and can automatically infer that
other constructed types are inhabited on that basis.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151337Z" creationid="tlqk3" creationdate="20220527T150928Z">
        <seg>나중에 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited<ept i="3">&lt;/g3&gt;</ept>가 린에서 <bpt i="4" x="4">&lt;g4&gt;</bpt>type class<ept i="4">&lt;/g4&gt;</ept>의 예임을 보게 될 것입니다. 린은 적절한 기반형이 내장됨을 알게 되면 자동적으로 다른 생성된 유형도 그 기저에 내장되었음을 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean
detects when these arguments can be inferred from later arguments to a
constructor or the return type, and makes them implicit in that case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T155511Z" creationid="tlqk3" creationdate="20220526T155511Z">
        <seg>린은 이 인수가 생성자의 나중 인수나 반환형으로부터 추론될 수 있을 때를 감지하고 그 경우 이들을 암시적이게 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean
simply normalizes these expressions until the constructors <bpt i="2" x="2">&lt;g2&gt;</bpt>zero<ept i="2">&lt;/g2&gt;</ept>
and <bpt i="3" x="3">&lt;g3&gt;</bpt>succ<ept i="3">&lt;/g3&gt;</ept> are exposed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161455Z" creationid="tlqk3" creationdate="20220529T161455Z">
        <seg>린은 단순히 이 표현식들을 생성자 <bpt i="2" x="2">&lt;g2&gt;</bpt>zero<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>succ<ept i="3">&lt;/g3&gt;</ept>이 드러날 때까지 정규화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean
therefore provides <bpt i="3" x="3">&lt;g3&gt;</bpt>Or.inr<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>Or.inl<ept i="4">&lt;/g4&gt;</ept> which can be viewed as
shorthand for <bpt i="5" x="5">&lt;g5&gt;</bpt>Or.intro_right _<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>Or.intro_left _<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164016Z" creationid="tlqk35" creationdate="20220321T164016Z">
        <seg>린은 그러므로  <bpt i="5" x="5">&lt;g5&gt;</bpt>Or.intro_right _<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>Or.intro_left _<ept i="6">&lt;/g6&gt;</ept>의 약식 표현으로 볼 수 있는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Or.inr<ept i="3">&lt;/g3&gt;</ept> 과 <bpt i="4" x="4">&lt;g4&gt;</bpt>Or.inl<ept i="4">&lt;/g4&gt;</ept>을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean 4 supports a new feature called <bpt i="1" x="1">&lt;g1&gt;</bpt>auto bound implicit arguments<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134508Z" creationid="tlqk3" creationdate="20220526T134508Z">
        <seg>린 4는 <bpt i="1" x="1">&lt;g1&gt;</bpt>auto bound implicit arguments<ept i="1">&lt;/g1&gt;</ept>라 하는 새로운 기능을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean allows us to use <bpt i="9" x="9">&lt;g9&gt;</bpt>anonymous constructor<ept i="9">&lt;/g9&gt;</ept> notation
<bpt i="10" x="10">&lt;g10&gt;</bpt>⟨arg1, arg2, ...⟩<ept i="10">&lt;/g10&gt;</ept> in situations like these, when the relevant type is an
inductive type and can be inferred from the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151715Z" creationid="tlqk35" creationdate="20220321T163229Z">
        <seg>연관된 유형이 귀납형이고 맥락으로부터 추리할 수 있는 상황에서 린은 <bpt i="9" x="9">&lt;g9&gt;</bpt>익명 생성자<ept i="9">&lt;/g9&gt;</ept> 표기 <bpt i="10" x="10">&lt;g10&gt;</bpt>⟨arg1, arg2, ...⟩<ept i="10">&lt;/g10&gt;</ept>를 쓸 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean allows users to mark
such subterms as <bpt i="1" x="1">&lt;g1&gt;</bpt>inaccessible<ept i="1">&lt;/g1&gt;</ept> for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143653Z" creationid="tlqk3" creationdate="20220604T143653Z">
        <seg>린은 사용자가 그런 부분항을 패턴 매칭에 대해 <bpt i="1" x="1">&lt;g1&gt;</bpt>inaccessible<ept i="1">&lt;/g1&gt;</ept>으로 표시하도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean allows you to specify that unassigned fields in the
specification of a record should be taken from a previously defined
structure object <bpt i="2" x="2">&lt;g2&gt;</bpt>s<ept i="2">&lt;/g2&gt;</ept> by adding the annotation <bpt i="3" x="3">&lt;g3&gt;</bpt>s with<ept i="3">&lt;/g3&gt;</ept> before the field
assignments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181355Z" creationid="tlqk35" creationdate="20220528T181355Z">
        <seg>린은 여러분이 레코드의 명세에서 이전에 정의된 구조체 개체로부터 <bpt i="3" x="3">&lt;g3&gt;</bpt>s<ept i="3">&lt;/g3&gt;</ept>를 받아  필드 할당 전에 <bpt i="3" x="3">&lt;g3&gt;</bpt>s가 있음<ept i="3">&lt;/g3&gt;</ept> 주석을 추가하여 할당되지 않은 필드를 나타내도록 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also
allows us to specify the type of the final term <bpt i="4" x="4">&lt;g4&gt;</bpt>hp<ept i="4">&lt;/g4&gt;</ept>, explicitly,
with a <bpt i="5" x="5">&lt;g5&gt;</bpt>show<ept i="5">&lt;/g5&gt;</ept> statement.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161051Z" creationid="tlqk35" creationdate="20220321T161051Z">
        <seg>린은 여러분에게 마지막 항 <bpt i="4" x="4">&lt;g4&gt;</bpt>hp<ept i="4">&lt;/g4&gt;</ept>을 명시적으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>show<ept i="5">&lt;/g5&gt;</ept> 문장으로 유형을 명시하는 것을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also allows parameters to occur after <bpt i="4" x="4">&lt;g4&gt;</bpt>:<ept i="4">&lt;/g4&gt;</ept>, but it cannot pattern match on them.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163915Z" creationid="tlqk3" creationdate="20220529T163915Z">
        <seg>린은 매개변수가 <bpt i="4" x="4">&lt;g4&gt;</bpt>:<ept i="4">&lt;/g4&gt;</ept> 뒤에서 나타나는 것도 허용합니다. 그러나 이들에 대해 패턴 매칭은 할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also allows you to introduce "local" definitions using the
<bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144719Z" creationid="tlqk35" creationdate="20220321T144719Z">
        <seg>Lean은 여러분이 <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> 키워드를 사용해 "지역" 정의를 가져올 수 있게 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also has a <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> tactic, which is similar to the <bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept>
tactic, but is used to introduce local definitions instead of
auxiliary facts.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144248Z" creationid="tlqk35" creationdate="20220524T144248Z">
        <seg>Lean은 또 <bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept>전략과 유사한 <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> 전략을 갖고 있습니다. 
그러나 이것은 부가적인 사실 대신 지역 정의를 도입하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also has mechanisms to serve as its own <bpt i="1" x="1">&lt;g1&gt;</bpt>metaprogramming
language<ept i="1">&lt;/g1&gt;</ept>, which means that you can implement automation and extend the functionality of Lean using Lean itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131622Z" creationid="tlqk35" creationdate="20220321T131622Z">
        <seg>또한 Lean은 그 자체로 <bpt i="1" x="1">&lt;g1&gt;</bpt>메타프로그래밍 언어<ept i="1">&lt;/g1&gt;</ept>로 기능하는 작동 원리가 있어 자동화의 수행 및 Lean 자체로 그 기능을 확장할 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also provides
the "bullet" notation <it pos="begin" x="1">&lt;g1&gt;</it>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061823Z" creationid="tlqk35" creationdate="20220522T061751Z">
        <seg>린은 또 구조화한 증명에 대해 "bullet" 기호를 제공합니다.<it pos="begin" x="1">&lt;g1&gt;</it></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also provides a compiler for <bpt i="1" x="1">&lt;g1&gt;</bpt>match-with<ept i="1">&lt;/g1&gt;</ept> expressions found in
many functional languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182836Z" creationid="tlqk3" creationdate="20220603T182836Z">
        <seg>린도 많은 함수형 언어에서 발견되다시피 컴파일러에게 <bpt i="1" x="1">&lt;g1&gt;</bpt>match-with<ept i="1">&lt;/g1&gt;</ept> 표현식을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also provides a complementary <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept> tactic, which allows you to focus on goal
assign variable names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165442Z" creationid="tlqk3" creationdate="20220527T165442Z">
        <seg>린은 여러분이 목표에 변수 이름을 할당할 수 있게 하는 보완적인 <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept> 전략도 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also provides a pattern-matching <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> expression:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182802Z" creationid="tlqk35" creationdate="20220321T182802Z">
        <seg>또 린은 패턴-매칭 <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> 표현식을 제공합니다.&lt;부분 1562 ¶&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also supports a structured way of reasoning backwards from a
goal, which models the "suffices to show" construction in ordinary
mathematics.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165224Z" creationid="tlqk35" creationdate="20220321T165224Z">
        <seg>린은 또 구조화된 목표로부터 후방향 추론 방식을 지원합니다. 이것은 일상 수학에서 "보여주기에 충분하다" 구성을 모델링 한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also supports mutual recursive definitions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173339Z" creationid="tlqk3" creationdate="20220603T173339Z">
        <seg>린도 상호적인 재귀적 정의를 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean also supports the use of various editors, which provide
continuous checking and feedback.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173524Z" creationid="tlqk35" creationdate="20220524T173524Z">
        <seg>또한 린은 다양한 끊임없는 확인과 피드백을 제공하는 편집기의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean can
usually infer the type <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>, but it is often a good idea to write it
explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144144Z" creationid="tlqk35" creationdate="20220321T144144Z">
        <seg>Lean은 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>의 유형을 추론할 수 있습니다. 그러나 이를 명백히 적는 것이 좋습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean can also handle more complex forms of pattern matching, in which
arguments to dependent types pose additional constraints on the
various cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164517Z" creationid="tlqk3" creationdate="20220529T164517Z">
        <seg>린은 인수가 다양한 경우에 대해 추가적인 제약을 의존 유형에 부여하는 것 같은 패턴 매칭의 더 복잡한 형태도 다룰 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean can not only define mathematical objects and express
mathematical assertions in dependent type theory, but it also can be used as a language for writing proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132153Z" creationid="tlqk35" creationdate="20220321T132120Z">
        <seg>린은 수학적 대상들을 정의하고 수학적 주장을 의존 유형론으로 진술할 수 있고 증명을 작성하는 언어로써 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean comes with <bpt i="3" x="3">&lt;g3&gt;</bpt>ToString<ept i="3">&lt;/g3&gt;</ept> instances
for most builtin types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162130Z" creationid="tlqk3" creationdate="20220604T162130Z">
        <seg>린은 대다수의 내장된 유형에 대한 <bpt i="3" x="3">&lt;g3&gt;</bpt>ToString<ept i="3">&lt;/g3&gt;</ept>와 함께 나옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean converts them into a <bpt i="2" x="2">&lt;g2&gt;</bpt>let rec<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182525Z" creationid="tlqk3" creationdate="20220603T182525Z">
        <seg>린은 그들을 <bpt i="2" x="2">&lt;g2&gt;</bpt>let rec<ept i="2">&lt;/g2&gt;</ept>으로 바꿉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean creates an auxiliary declaration for each <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182022Z" creationid="tlqk3" creationdate="20220603T182022Z">
        <seg>린은 각 <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept>에 대해 부가 선언을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean defines all the standard logical connectives and notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161834Z" creationid="tlqk35" creationdate="20220321T161834Z">
        <seg>린은 모든 표준 논리 연결사와 표기를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean detects that the proof uses <bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept> and automatically adds
<bpt i="2" x="2">&lt;g2&gt;</bpt>hp : p<ept i="2">&lt;/g2&gt;</ept> as a premise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161613Z" creationid="tlqk35" creationdate="20220321T161613Z">
        <seg>린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept>를 사용하는 증명을 감지하고 자동적으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>hp : p<ept i="2">&lt;/g2&gt;</ept>를 전제로 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean elaborates the terms <bpt i="1" x="1">&lt;g1&gt;</bpt>(2 : Nat)<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>(2 : Rational)<ept i="2">&lt;/g2&gt;</ept> as
<bpt i="3" x="3">&lt;g3&gt;</bpt>OfNat.ofNat Nat 2 (instOfNatNat 2)<ept i="3">&lt;/g3&gt;</ept> and
<bpt i="4" x="4">&lt;g4&gt;</bpt>OfNat.ofNat Rational 2 (instOfNatRational 2)<ept i="4">&lt;/g4&gt;</ept> respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162615Z" creationid="tlqk3" creationdate="20220604T162615Z">
        <seg>린은 항 <bpt i="1" x="1">&lt;g1&gt;</bpt>(2 : Nat)<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>(2 : Rational)<ept i="2">&lt;/g2&gt;</ept>을 각각 <bpt i="3" x="3">&lt;g3&gt;</bpt>OfNat.ofNat Nat 2 (instOfNatNat 2)<ept i="3">&lt;/g3&gt;</ept>과
<bpt i="4" x="4">&lt;g4&gt;</bpt>OfNat.ofNat Rational 2 (instOfNatRational 2)<ept i="4">&lt;/g4&gt;</ept>으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean has mechanisms to
detect and insert <bpt i="4" x="4">&lt;g4&gt;</bpt>coercions<ept i="4">&lt;/g4&gt;</ept> of this sort.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124651Z" creationid="tlqk3" creationdate="20220526T124651Z">
        <seg>린은 이런 종류의 <bpt i="4" x="4">&lt;g4&gt;</bpt>coercions<ept i="4">&lt;/g4&gt;</ept>의 감지와 삽입하는 메커니즘이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153412Z" creationid="tlqk35" creationdate="20220321T153412Z">
        <seg>Lean은 암시적인 인수를 인스턴스화(instantiating)하는데 아주 복잡한 매커니즘을 가지고 있습니다. 그리고 우리는 함수의 유형과 술어 그리고 심지어 증명을 추론하는데 사용될 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>y<ept i="2">&lt;/g2&gt;</ept> from the
expression <bpt i="3" x="3">&lt;g3&gt;</bpt>if not y then x + 1 else x + 2<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142601Z" creationid="tlqk35" creationdate="20220321T142601Z">
        <seg>린은 마지막 세 예제를 같은 표현식으로 해석합니다. 마지막 표현식에서 린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>y<ept i="2">&lt;/g2&gt;</ept>의 유형을 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>if not y then x + 1 else x + 2<ept i="3">&lt;/g3&gt;</ept>으로부터 추론합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is a complete programming language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143745Z" creationid="tlqk35" creationdate="20220321T143745Z">
        <seg>린은 완전한 프로그래밍 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is based on a version of dependent type
theory known as the <bpt i="1" x="1">&lt;g1&gt;</bpt>Calculus of Constructions<ept i="1">&lt;/g1&gt;</ept>, with a countable
hierarchy of non-cumulative universes and inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151640Z" creationid="tlqk35" creationdate="20220321T135135Z">
        <seg>린은  <bpt i="1" x="1">&lt;g1&gt;</bpt>직관주의 계산법<ept i="1">&lt;/g1&gt;</ept>이라고 하는 가산적인 비축적적 세계(Universe)와 귀납형이 있는 의존 유형론 버전을 기반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is released under the
<bpt i="2" x="2">&lt;g2&gt;</bpt>Apache 2.0 license<ept i="2">&lt;/g2&gt;</ept>, a permissive open source license that permits others to use and extend the code and
mathematical libraries freely.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131805Z" creationid="tlqk35" creationdate="20220321T131805Z">
        <seg>Lean은  <bpt i="2" x="2">&lt;g2&gt;</bpt>Apache 2.0 라이센스<ept i="2">&lt;/g2&gt;</ept>하에서 배포되었습니다. 이는 타인에게 자유롭게 사용하는 것과 수학 라이브러리 및 코드의 확장을 허락합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean is smart enough to figure out which variables are used
explicitly or implicitly in a definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145931Z" creationid="tlqk35" creationdate="20220321T145931Z">
        <seg>Lean은 정의에서 명시적으로나 암시적으로 사용된 변수를 구분하기에 충분히 똑똑합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean knows that the usual order <bpt i="1" x="1">&lt;g1&gt;</bpt>&lt;<ept i="1">&lt;/g1&gt;</ept> on the natural numbers is well
founded.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170249Z" creationid="tlqk3" creationdate="20220603T170249Z">
        <seg>린은 자연수에 대한 평상시 순서 <bpt i="1" x="1">&lt;g1&gt;</bpt>&lt;<ept i="1">&lt;/g1&gt;</ept>가 잘 세워졌다는 것을 압니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean maintains a number of internal variables that can be set by users
to control its behavior.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125644Z" creationid="tlqk3" creationdate="20220526T125644Z">
        <seg>린은 사용자가 설정하여 그 행동을 제어하는 하는 다수의 내부 변수를 관리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean offers a weaker annotation,
<bpt i="4" x="4">&lt;g4&gt;</bpt>{{y : ℕ}}<ept i="4">&lt;/g4&gt;</ept>, which specifies that a placeholder should only be added
<bpt i="5" x="5">&lt;g5&gt;</bpt>before<ept i="5">&lt;/g5&gt;</ept> a subsequent explicit argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185509Z" creationid="tlqk3" creationdate="20220525T185229Z">
        <seg>린은 종종 자리차지자가 이후의 명시적인 인수 <bpt i="5" x="5">&lt;g5&gt;</bpt>앞에<ept i="5">&lt;/g5&gt;</ept> 추가되어야 함을 나타내는 약한 주석 <bpt i="4" x="4">&lt;g4&gt;</bpt>{{y : ℕ}}<ept i="4">&lt;/g4&gt;</ept>을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides a <bpt i="1" x="1">&lt;g1&gt;</bpt>fun<ept i="1">&lt;/g1&gt;</ept> (or <bpt i="2" x="2">&lt;g2&gt;</bpt>λ<ept i="2">&lt;/g2&gt;</ept>) keyword to create a function
from an expression as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142148Z" creationid="tlqk35" creationdate="20220321T142148Z">
        <seg>린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>fun<ept i="1">&lt;/g1&gt;</ept> (또는 <bpt i="2" x="2">&lt;g2&gt;</bpt>λ<ept i="2">&lt;/g2&gt;</ept>) 키워드를 제공하여 다음과 같은 표현식으로부터 함수를 만들 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides a more convenient way to eliminate from an existential
quantifier with the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expression:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181807Z" creationid="tlqk35" creationdate="20220321T181807Z">
        <seg>린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식이 있는 존재 한정기호를 더 편리하게 제거하는 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides another useful syntactic gadget.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163333Z" creationid="tlqk35" creationdate="20220321T163333Z">
        <seg>린은 또 다른 유용한 문법적 도구를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides natural ways of defining recursive functions, performing
pattern matching, and writing inductive proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160113Z" creationid="tlqk3" creationdate="20220529T160113Z">
        <seg>린은 재귀적인 함수를 정의하는 자연스러운 방법을 제공하고, 패턴 매치를 수행하고, 귀납적 정의를 작성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides various sectioning mechanisms to help structure a
theory.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174732Z" creationid="tlqk35" creationdate="20220524T174732Z">
        <seg>린은 이론을 구조화하는 것을 돕기 위해 구획을 나누는 다양한 메커니즘을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides you with the <bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept> command to make such
declarations look more compact:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145147Z" creationid="tlqk35" creationdate="20220321T145143Z">
        <seg>린은 여러분에게 이런 선언을 더 간결하게 보이게 만들도록 <bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept> 명령을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean provides you with the ability to group definitions into nested,
hierarchical <bpt i="1" x="1">&lt;g1&gt;</bpt>namespaces<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150219Z" creationid="tlqk35" creationdate="20220321T150219Z">
        <seg>Lean은 여러분에게 정의를 중첩되고 계층적인 <bpt i="1" x="1">&lt;g1&gt;</bpt>namespaces<ept i="1">&lt;/g1&gt;</ept>에 묶을 수 있는 능력을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean raises an error if any of the field names remain
unspecified after all the objects are visited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181620Z" creationid="tlqk35" creationdate="20220528T181620Z">
        <seg>린은 모든 개체들이 방문된 이후에도 어떤 필드 이름이라도 명시되지 않고 남아있다면 오류를 발생시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean then automatically builds the
isomorphism between <bpt i="5" x="5">&lt;g5&gt;</bpt>TreeList α<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>List (Tree α)<ept i="6">&lt;/g6&gt;</ept> in its kernel,
and defines the constructors for <bpt i="7" x="7">&lt;g7&gt;</bpt>Tree<ept i="7">&lt;/g7&gt;</ept> in terms of the isomorphism.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T170807Z" creationid="tlqk35" creationdate="20220528T170807Z">
        <seg>그 후 린은 자동적으로 그것의 커널에서 <bpt i="5" x="5">&lt;g5&gt;</bpt>TreeList α<ept i="5">&lt;/g5&gt;</ept>과<bpt i="6" x="6">&lt;g6&gt;</bpt>List (Tree α)<ept i="6">&lt;/g6&gt;</ept> 사이의 동형을 만듭니다. 그리고 동형에 대해서 <bpt i="7" x="7">&lt;g7&gt;</bpt>Tree<ept i="7">&lt;/g7&gt;</ept>에 대한 생성자를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean therefore provides the following alternative
notations for defining elements of a structure type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182051Z" creationid="tlqk35" creationdate="20220528T182051Z">
        <seg>그래서 린은 구조체의 원소를 정의하는데 다음의 대안 기호를 제공합니다</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean tries to use type information to
disambiguate the meaning in context, but you can always disambiguate
by giving the full name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180522Z" creationid="tlqk35" creationdate="20220524T180522Z">
        <seg>린은 맥락에서 의미의 모호함을 해소하려고 유형 정보를 사용하려고 합니다. 
그러나 여러분은 이들의 완전한 이름을 주는 것으로 모호성을 항상 풀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean uses the
context to infer which one is appropriate.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181106Z" creationid="tlqk35" creationdate="20220321T181106Z">
        <seg>린은 어떤 것이 적절한 지 추론하는데 맥락을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean uses the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> construct internally to implement pattern-matching in all parts of the system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182640Z" creationid="tlqk3" creationdate="20220603T182640Z">
        <seg>린은 시스템의 모든 부분에서 내부적으로 패턴 매칭을 구현하고자 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 생성을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean will even allow us to use an implicit <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>
in the <bpt i="3" x="3">&lt;g3&gt;</bpt>fun<ept i="3">&lt;/g3&gt;</ept> expression:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182848Z" creationid="tlqk35" creationdate="20220321T182848Z">
        <seg>더욱이 린은 우리에게 <bpt i="3" x="3">&lt;g3&gt;</bpt>fun<ept i="3">&lt;/g3&gt;</ept> 표현식에서 암시적인 <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>를 사용할 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean will start type class synthesizer even when these parameters have missing parts.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163641Z" creationid="tlqk3" creationdate="20220604T163641Z">
        <seg>이들의 매개변수에 모르는 부분이 있을 지라도 린은 유형 클래스 합성기를 시작할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's equation compiler, described in the next
chapter, is needed to make use of these types
effectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T164830Z" creationid="tlqk35" creationdate="20220528T164830Z">
        <seg>다음 장에서 설명할 린의 방정식 컴파일러는 이 유형의 사용을 효과적으로 만들기 위해 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's library contains a large number of common identities, such as these:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175923Z" creationid="tlqk35" creationdate="20220321T175923Z">
        <seg>린의 라이브러리는 이와 같은 흔한 항등식들을 많이 가지고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's library developers follow general naming guidelines to make it
easier to guess the name of a theorem you need, or to find it using
tab completion in editors with a Lean mode that supports this, which
is discussed in the next section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131843Z" creationid="tlqk3" creationdate="20220526T131843Z">
        <seg>린의 라이브러리 개발자는 여러분이 필요한 정리의 이름을 추측하기 더 쉽게 일반적인 이름짓기 규칙을 따릅니다. 혹은 린 모드인 편집기의 탭 완성 지원 기능으로 그것을 찾도록 돕습니다. 탭 완성은 다음 섹션에서 얘기합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's mechanisms for guessing a well-founded relation and then
proving that recursive calls decrease are still in a rudimentary
state.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173121Z" creationid="tlqk3" creationdate="20220603T173121Z">
        <seg>린의 잘 세워진 관계식을 추론하는 메커니즘과 재귀적인 호출이 줄어든다는 증명은 여전히 기초적인 상태입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's parser is extensible, which is to say, we can define new notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T191247Z" creationid="tlqk3" creationdate="20220525T191247Z">
        <seg>린의 구문분석기는 확장가능성이 있습니다. 그 말은 우리가 새로운 기호를 정의할 수 있다는 뜻입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's standard
library can be found online, on GitHub:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131254Z" creationid="tlqk3" creationdate="20220526T131254Z">
        <seg>린의 표준 라이브러리는 깃허브에서 찾을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's standard library contains proofs of many valid statements of
propositional logic, all of which you are free to use in proofs of
your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170114Z" creationid="tlqk35" creationdate="20220321T170114Z">
        <seg>린의 표준 라이브러리는 명제 논리의 유효한 많은 진술들이 담겨있고 그 모든 것들은 여러분들의 주장을 증명하는데 자유롭게 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's standard library defines two predicates, <bpt i="1" x="1">&lt;g1&gt;</bpt>Acc r a<ept i="1">&lt;/g1&gt;</ept> and
<bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded r<ept i="2">&lt;/g2&gt;</ept>, where <bpt i="3" x="3">&lt;g3&gt;</bpt>r<ept i="3">&lt;/g3&gt;</ept> is a binary relation on a type <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>,
and <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept> is an element of type <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173905Z" creationid="tlqk3" creationdate="20220529T173905Z">
        <seg>린의 표준 라이브러리는 두 술어 <bpt i="1" x="1">&lt;g1&gt;</bpt>Acc r a<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded r<ept i="2">&lt;/g2&gt;</ept>을 정의합니다. 여기서 <bpt i="3" x="3">&lt;g3&gt;</bpt>r<ept i="3">&lt;/g3&gt;</ept>은 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>형에 대한 이항 관계이고 <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>형 원소입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's syntax can be extended and customized by users at every level,
ranging from basic "mixfix" notations to custom elaborators.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T115919Z" creationid="tlqk3" creationdate="20220526T115919Z">
        <seg>린의 문법은 모든 수준에서 사용자에 의해 기본적인 "혼합 수정" 기호에서 관습적인 협력기에 이르기까지 확장되거나 사용자가 정의해 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's task, as a
proof assistant, is to help us to construct such a term, <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept>, and to
verify that it is well-formed and has the correct type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160545Z" creationid="tlqk35" creationdate="20220321T160545Z">
        <seg>증명 보조기로써 린의 일은 그러한 항 <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept>를 생성하고 그것이 올바른 유형이고 잘 형성된 것을 검증하도록 돕는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's underlying foundation has an infinite
hierarchy of types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141603Z" creationid="tlqk35" creationdate="20220321T141603Z">
        <seg>린의 기저에는 무한한 유형의 계층이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Lean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming
language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131550Z" creationid="tlqk35" creationdate="20220321T131550Z">
        <seg>Lean의 기본 논리는 컴퓨팅 해석기(interpretor)을 가지는데 있다. 그래서 Lean은 프로그래밍 언어와 마찬가지로 동등하게 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us consider another example of a type class defined in the
standard library, namely the type class of <bpt i="1" x="1">&lt;g1&gt;</bpt>Decidable<ept i="1">&lt;/g1&gt;</ept>
propositions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171306Z" creationid="tlqk3" creationdate="20220604T171306Z">
        <seg>표준 라이브러리에 정의된 유형 클래스의 다른 예 즉, <bpt i="1" x="1">&lt;g1&gt;</bpt>결정 가능한<ept i="1">&lt;/g1&gt;</ept> 명제 유형 클래스를 고려해 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us consider some more examples of inductively defined types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162833Z" creationid="tlqk3" creationdate="20220527T162833Z">
        <seg>재귀적으로 정의된 유형에 대해 몇 가지 예제를 더 고려해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us first consider the case where the inductive type is <bpt i="1" x="1">&lt;g1&gt;</bpt>not<ept i="1">&lt;/g1&gt;</ept>
specified to land in <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152243Z" creationid="tlqk35" creationdate="20220528T161836Z">
        <seg>우선 귀납형이 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>에 머무른다고 명시되지<bpt i="1" x="1">&lt;g1&gt;</bpt>않은<ept i="1">&lt;/g1&gt;</ept>경우를 생각해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us now turn to one of the most fundamental relations defined in
Lean's library, namely, the equality relation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175313Z" creationid="tlqk35" creationdate="20220321T175313Z">
        <seg>이제 주로 동등 관계라고 하는 린의 라이브러리에 정의된 가장 기초적인 관계 중 하나로 가봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us start with the first step of the program above, declaring an appropriate class:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160105Z" creationid="tlqk3" creationdate="20220604T160105Z">
        <seg>위 프로그램의 첫 단계인 적절한 클래스를 선언하는 것부터 시작합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let us start with the logical background that
is needed to understand how it works.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173742Z" creationid="tlqk3" creationdate="20220529T173742Z">
        <seg>우선 이것이 어떻게 동작하는지 이해하는데 필요한 논리적 배경으로 시작합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let's create one
that adds two natural numbers:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144254Z" creationid="tlqk35" creationdate="20220321T144254Z">
        <seg>두 자연수를 더하는 함수를 만들어 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Let's take a look at some basic syntax.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140329Z" creationid="tlqk35" creationdate="20220321T140329Z">
        <seg>몇 가지 기본 문법에 대해 살펴봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Like sections, namespaces can be nested:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150535Z" creationid="tlqk35" creationdate="20220321T150535Z">
        <seg>section처럼 이름공간도 중첩될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Like sections, nested namespaces have to be closed in the order they
are opened.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150603Z" creationid="tlqk35" creationdate="20220321T150603Z">
        <seg>섹션과 마찬가지로 중첩된 이름공간은 그들이 열린 순서대로 닫혀야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Local Definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144706Z" creationid="tlqk35" creationdate="20220321T144706Z">
        <seg>지역 정의(Local Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Local Instances</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170215Z" creationid="tlqk3" creationdate="20220604T170215Z">
        <seg>지역 개체</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Local recursive declarations</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181922Z" creationid="tlqk3" creationdate="20220603T181922Z">
        <seg>지역적인 재귀 선언</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Logical Equivalence</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164609Z" creationid="tlqk35" creationdate="20220321T164609Z">
        <seg>논리적 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Logically speaking, having an element <bpt i="1" x="1">&lt;g1&gt;</bpt>t : Decidable p<ept i="1">&lt;/g1&gt;</ept> is stronger
than having an element <bpt i="2" x="2">&lt;g2&gt;</bpt>t : p ∨ ¬p<ept i="2">&lt;/g2&gt;</ept>; it enables us to define values
of an arbitrary type depending on the truth value of <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172304Z" creationid="tlqk3" creationdate="20220604T172304Z">
        <seg>논리적으로 말하자면 원소 <bpt i="1" x="1">&lt;g1&gt;</bpt>t : Decidable p<ept i="1">&lt;/g1&gt;</ept>를 갖는 것은 원소 <bpt i="2" x="2">&lt;g2&gt;</bpt>t : p ∨ ¬p<ept i="2">&lt;/g2&gt;</ept>을 갖는 것보다 강합니다. 이는 우리가 <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>의 진리값에 의존하는 임의의 유형의 값을 정의할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Look up the definition of a Fermat prime or any of the
other statements, if necessary.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183958Z" creationid="tlqk35" creationdate="20220321T183958Z">
        <seg>페르마 소수의 정의나 필요하다면 다른 문장들을 찾아보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Make sure Lean accepts the term with
all the <bpt i="4" x="4">&lt;g4&gt;</bpt>sorry<ept i="4">&lt;/g4&gt;</ept>'s; if not, there are errors that you need to
correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170349Z" creationid="tlqk35" creationdate="20220321T170349Z">
        <seg>린이 모든 <bpt i="4" x="4">&lt;g4&gt;</bpt>sorry<ept i="4">&lt;/g4&gt;</ept>에 대한 말을 받아들이게 만드세요. 그렇지 않으면 여러분이 고쳐야 하는 에러가 생깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Managing Type Class Inference</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T175611Z" creationid="tlqk3" creationdate="20220604T175611Z">
        <seg>유형 클래스 추론 관리하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Many people have contributed to the effort, providing
corrections, suggestions, examples, and text.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134821Z" creationid="tlqk35" creationdate="20220321T134821Z">
        <seg>많은 사람들이 오타 정정, 제안, 예제, 본분을 제공하는 등의 노력으로 기여했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Marking the position as an inaccessible pattern tells the
equation compiler first, that the form of the argument should be
inferred from the constraints posed by the other arguments, and,
second, that the first argument should <bpt i="1" x="1">&lt;g1&gt;</bpt>not<ept i="1">&lt;/g1&gt;</ept> participate in pattern
matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T150734Z" creationid="tlqk3" creationdate="20220604T150734Z">
        <seg>접근 불가한 패턴으로 위치를 표시하는 것은 우선 방정식 컴파일러에게 인수의 모양이 다른 인수에 부과된 제약으로부터 추론될 수 있어야 한다고 말합니다. 그리고 두 번째로 첫 인수가 패턴 매칭에 참여하지 <bpt i="1" x="1">&lt;g1&gt;</bpt>않아야<ept i="1">&lt;/g1&gt;</ept> 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Match Expressions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182731Z" creationid="tlqk3" creationdate="20220603T182731Z">
        <seg>매치 표현식</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More Tactics</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070126Z" creationid="tlqk35" creationdate="20220522T070126Z">
        <seg>이 외의 전략들</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More generally, given an expression <bpt i="1" x="1">&lt;g1&gt;</bpt>p.foo x y z<ept i="1">&lt;/g1&gt;</ept> where <bpt i="2" x="2">&lt;g2&gt;</bpt>p : Point<ept i="2">&lt;/g2&gt;</ept>,
Lean will insert <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept> at the first argument to <bpt i="4" x="4">&lt;g4&gt;</bpt>Point.foo<ept i="4">&lt;/g4&gt;</ept> of type
<bpt i="5" x="5">&lt;g5&gt;</bpt>Point<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180508Z" creationid="tlqk35" creationdate="20220528T180508Z">
        <seg>더 일반적으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>p : Point<ept i="2">&lt;/g2&gt;</ept>일 때 제시된 표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>p.foo x y z<ept i="1">&lt;/g1&gt;</ept>에 대해, 린은 <bpt i="5" x="5">&lt;g5&gt;</bpt>Point<ept i="5">&lt;/g5&gt;</ept>형의 첫 번째 인수로 <bpt i="4" x="4">&lt;g4&gt;</bpt>Point.foo<ept i="4">&lt;/g4&gt;</ept>에  <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>를 삽입할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More importantly, the cases tactic will detect any items
in the local context that depend on the target variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164631Z" creationid="tlqk3" creationdate="20220527T164631Z">
        <seg>더 중요하게 cases 전략은 대상 변수에 의존하는 지역 상황 속 임의의 항목을 감지할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More information can be found on the
Lean <bpt i="1" x="1">&lt;g1&gt;</bpt>documentation pages<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173553Z" creationid="tlqk35" creationdate="20220524T173553Z">
        <seg>린에 대한 더 많은 정보는 <bpt i="1" x="1">&lt;g1&gt;</bpt>documentation pages<ept i="1">&lt;/g1&gt;</ept>에서 찾을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More interestingly, patterns can involve nested
constructors, as in the following examples.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161918Z" creationid="tlqk3" creationdate="20220529T161905Z">
        <seg>더 흥미롭게도 패턴은 다음 예제에 있는 중첩된 생성자에도 관여할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More on Implicit Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184142Z" creationid="tlqk3" creationdate="20220525T184142Z">
        <seg>암시적인 인수에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More on Namespaces</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175445Z" creationid="tlqk35" creationdate="20220524T175445Z">
        <seg>이름공간에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More on Sections</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175439Z" creationid="tlqk35" creationdate="20220524T175439Z">
        <seg>섹션에 대해 더 알아보기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More on the Proof Language</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183223Z" creationid="tlqk35" creationdate="20220321T183223Z">
        <seg>증명 언어에 대한 자세한 내용</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More precisely,
Lean's parser follows a local <bpt i="1" x="1">&lt;g1&gt;</bpt>longest parse<ept i="1">&lt;/g1&gt;</ept> rule in the presence of
ambiguous grammars: when parsing the right-hand side of <bpt i="2" x="2">&lt;g2&gt;</bpt>a ~<ept i="2">&lt;/g2&gt;</ept> in
<bpt i="3" x="3">&lt;g3&gt;</bpt>a ~ b ~ c<ept i="3">&lt;/g3&gt;</ept>, it will continue parsing as long as possible (as the current
precedence allows), not stopping after <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept> but parsing <bpt i="5" x="5">&lt;g5&gt;</bpt>~ c<ept i="5">&lt;/g5&gt;</ept> as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123635Z" creationid="tlqk3" creationdate="20220526T123635Z">
        <seg>더 정확히는 린의 구문분석기는 모호한 문법의 존재에 대해 지역의 <bpt i="1" x="1">&lt;g1&gt;</bpt>가장 긴 구문분석<ept i="1">&lt;/g1&gt;</ept> 규칙을 따릅니다. <bpt i="3" x="3">&lt;g3&gt;</bpt>a ~ b ~ c<ept i="3">&lt;/g3&gt;</ept>에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>a ~<ept i="2">&lt;/g2&gt;</ept>의 우변을 분석할 때 구문분석기는 (현재 우선순위가 허용하는 만큼) 가능한 최대한 분석을 지속할 것입니다. <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept> 뒤에서 멈추지 않고  <bpt i="5" x="5">&lt;g5&gt;</bpt>~ c<ept i="5">&lt;/g5&gt;</ept>에서도 분석을 멈추지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More specifically, Lean is based on a version of a system
known as the Calculus of Constructions with inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151634Z" creationid="tlqk35" creationdate="20220321T132056Z">
        <seg>더 구체적으로 Lean은 귀납형(inductive types)의 직관주의적 계산법(calculus of Construction)으로 알려진 시스템에 기반한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as
reasoning about the functions that the programs compute.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131607Z" creationid="tlqk35" creationdate="20220321T131607Z">
        <seg>더욱이 이것은 정밀한 의미를 갖는 편집프로그램이나 프로그램이 계산하는 함수에 대한 추론 프로그램으로도 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, <bpt i="2" x="2">&lt;g2&gt;</bpt>a+b<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>a*b<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>a-b<ept i="4">&lt;/g4&gt;</ept>, <bpt i="5" x="5">&lt;g5&gt;</bpt>a/b<ept i="5">&lt;/g5&gt;</ept>, and <bpt i="6" x="6">&lt;g6&gt;</bpt>a%b<ept i="6">&lt;/g6&gt;</ept> are notations for the heterogeneous versions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165345Z" creationid="tlqk3" creationdate="20220604T165345Z">
        <seg>게다가 <bpt i="2" x="2">&lt;g2&gt;</bpt>a+b<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>a*b<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>a-b<ept i="4">&lt;/g4&gt;</ept>, <bpt i="5" x="5">&lt;g5&gt;</bpt>a/b<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>a%b<ept i="6">&lt;/g6&gt;</ept>은 이형 버전에 대한 표기입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, <bpt i="5" x="5">&lt;g5&gt;</bpt>Type u<ept i="5">&lt;/g5&gt;</ept> is also just
syntactic sugar for <bpt i="6" x="6">&lt;g6&gt;</bpt>Sort (u+1)<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155755Z" creationid="tlqk35" creationdate="20220321T155755Z">
        <seg>게다가 <bpt i="5" x="5">&lt;g5&gt;</bpt>Type u<ept i="5">&lt;/g5&gt;</ept>도 <bpt i="6" x="6">&lt;g6&gt;</bpt>Sort (u+1)<ept i="6">&lt;/g6&gt;</ept>에 대한 문법적 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, Lean flags an error
if the selected goal is not fully solved at the end of the <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept>
block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061544Z" creationid="tlqk35" creationdate="20220522T061544Z">
        <seg>게다가 린은 선택된 목표가 <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept> 블록의 끝에서 완전히 풀리지 않았다면 오류를 표시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, Lean provides convenient notation
for defining instances of a given structure.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173328Z" creationid="tlqk35" creationdate="20220528T173328Z">
        <seg>게다가 린은 주어진 구조체의 개체를 정의하는데 편리한 기호를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, decidability is preserved under propositional
connectives:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173052Z" creationid="tlqk3" creationdate="20220604T173052Z">
        <seg>게다가 결정 가능성은 명제 연결사 하에 보존됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, if instances are
declared in other modules, the order in which they are tried depends
on the order in which namespaces are opened.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181419Z" creationid="tlqk3" creationdate="20220604T181419Z">
        <seg>또한 개체가 다른 모듈에서 선언된 경우 시도되는 순서는 이름공간이 열린 순서에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, once we make this identification, the rules for implication
show that we can pass back and forth between <bpt i="1" x="1">&lt;g1&gt;</bpt>Implies p q<ept i="1">&lt;/g1&gt;</ept> and
<bpt i="2" x="2">&lt;g2&gt;</bpt>p → q<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155550Z" creationid="tlqk35" creationdate="20220321T155550Z">
        <seg>게다가 한번 우리가 이런 식별을 하면 함의 규칙은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Implies p q<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>p → q<ept i="2">&lt;/g2&gt;</ept>의 앞뒤를 오갈 수 있다는 것을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184343Z" creationid="tlqk35" creationdate="20220321T184343Z">
        <seg>게다가 자동화된 절차 자체가 전략이기 때문에 전략은 Lean의 자동화를 사용하기 위한 관문을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, the
constructors and the recursors provide the only means of defining
functions on these types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160006Z" creationid="tlqk3" creationdate="20220529T160006Z">
        <seg>게다가 생성자와 재귀자는 이 유형에 대한 함수 정의의 유일한 수단을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, the
output indicates that the first argument is implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153759Z" creationid="tlqk35" creationdate="20220321T153759Z">
        <seg>게다가 출력은 첫 번째 인수가 암시적임을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, the <bpt i="5" x="5">&lt;g5&gt;</bpt>zero = n + 1<ept i="5">&lt;/g5&gt;</ept> case is unreachable, and the canonical way to discard such
a case is to use <bpt i="6" x="6">&lt;g6&gt;</bpt>noConfusion<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183800Z" creationid="tlqk3" creationdate="20220603T183800Z">
        <seg>게다가 <bpt i="5" x="5">&lt;g5&gt;</bpt>zero = n + 1<ept i="5">&lt;/g5&gt;</ept> 경우는 도달할 수 없고 정식 방법으로 이 경우를 버리려면 <bpt i="6" x="6">&lt;g6&gt;</bpt>noConfusion<ept i="6">&lt;/g6&gt;</ept>을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moreover, you can use a "wildcard" asterisk to simplify all the hypotheses and the goal:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161754Z" creationid="tlqk35" creationdate="20220524T161754Z">
        <seg>게다가 여러분은 "와일드카드" *로 모든 가정과 목표를 간단히 하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most of
these commands have global effects, which is to say, that they remain
in effect not only in the current file, but also in any file that
imports it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T182353Z" creationid="tlqk3" creationdate="20220525T182353Z">
        <seg>대개 이런 명령들은 전역 효과를 갖습니다. 그 말은 즉, 그들이 현재 파일 뿐 아니라 그것을 불러오는 모든 파일에 대해 영향이 남는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Most parts are optional.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173656Z" creationid="tlqk35" creationdate="20220528T173656Z">
        <seg>대부분은 선택적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Moving a hypothesis into the goal yields an implication:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064037Z" creationid="tlqk35" creationdate="20220522T064037Z">
        <seg>가정을 목표 속으로 옮김으로써 함의를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Much of the background information you will
need in order to do this is not specific to Lean at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132021Z" creationid="tlqk35" creationdate="20220321T132021Z">
        <seg>이를 배우기 위해 필요한 대부분의 배경지식은 Lean으로만 국한되어 있지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiple rewrites can be combined using the notation <bpt i="1" x="1">&lt;g1&gt;</bpt>rw [t_1, ..., t_n]<ept i="1">&lt;/g1&gt;</ept>,
which is just shorthand for <bpt i="2" x="2">&lt;g2&gt;</bpt>rw t_1; ...; rw t_n<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172045Z" creationid="tlqk35" creationdate="20220524T154555Z">
        <seg>다수의 다시쓰기는 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw [t_1, ..., t_n]<ept i="1">&lt;/g1&gt;</ept> 표기을 사용해 결합될 수 있습니다. 
이것은 <bpt i="2" x="2">&lt;g2&gt;</bpt>rw t_1; ...; rw t_n<ept i="2">&lt;/g2&gt;</ept>의 축약된 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Multiple tactic applications can be written in a single line by concatenating with a semicolon.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060802Z" creationid="tlqk35" creationdate="20220522T060802Z">
        <seg>복수의 전략들은 세미콜론으로 연결한 한 줄에 작성될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mutual Recursion</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173321Z" creationid="tlqk3" creationdate="20220603T173321Z">
        <seg>상호적인 재귀</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mutual and Nested Inductive Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152315Z" creationid="tlqk35" creationdate="20220528T164349Z">
        <seg>상호적으로 중첩된 귀납형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Mutual recursive definitions also provide natural ways of working with mutual and nested inductive types, as described in :numref:<bpt i="1" x="1">&lt;g1&gt;</bpt>mutual_and_nested_inductive_types<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174350Z" creationid="tlqk3" creationdate="20220603T174350Z">
        <seg>상호적으로 재귀적인 정의도 :numref:<bpt i="1" x="1">&lt;g1&gt;</bpt>상호적이고 중첩된 재귀형<ept i="1">&lt;/g1&gt;</ept>에서 설명한 것처럼 상호적이고  중첩된 귀납형을 다루는 자연스러운 방식을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Named Arguments</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140434Z" creationid="tlqk3" creationdate="20220526T140418Z">
        <seg>이름 인자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Named arguments also improve the readability of your code by
identifying what each argument represents.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140936Z" creationid="tlqk3" creationdate="20220526T140936Z">
        <seg>이름 지어진 인자들은 각 인자가 나타내는 것을 명시함으로써 여러분의 코드의 가독성을 개선합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Named arguments enable you to specify an argument for a parameter by
matching the argument with its name rather than with its position in
the parameter list.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140704Z" creationid="tlqk3" creationdate="20220526T140425Z">
        <seg>이름 인자는 여러분이 매개변수 리스트에 대한 그것의 위치보다는 그것의 이름으로 매개변수에 대한 인자를 명시하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Names like
<bpt i="4" x="4">&lt;g4&gt;</bpt>Prod.rec<ept i="4">&lt;/g4&gt;</ept> are <bpt i="5" x="5">&lt;g5&gt;</bpt>protected<ept i="5">&lt;/g5&gt;</ept>, which means that one has to use the full
name even when the <bpt i="6" x="6">&lt;g6&gt;</bpt>Prod<ept i="6">&lt;/g6&gt;</ept> namespace is open.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T133931Z" creationid="tlqk3" creationdate="20220526T133931Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>Prod.rec<ept i="4">&lt;/g4&gt;</ept>같은 이름은 <bpt i="5" x="5">&lt;g5&gt;</bpt>protected<ept i="5">&lt;/g5&gt;</ept>입니다. 그말은 누군가가 <bpt i="6" x="6">&lt;g6&gt;</bpt>Prod<ept i="6">&lt;/g6&gt;</ept> 이름공간을 개방했더라도 완전한 이름을 사용해야만 함을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150201Z" creationid="tlqk35" creationdate="20220321T150201Z">
        <seg>이름공간(Namespaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces and sections serve different purposes:
namespaces organize data and sections declare variables for insertion
in definitions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150609Z" creationid="tlqk35" creationdate="20220321T150609Z">
        <seg>이름공간과 섹션은 다른 목적을 갖고 일합니다. 이름공간은 데이터를 정리하고 섹션은 정의의 삽입에 대해 변수를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Namespaces that have been closed can later be reopened, even in another file:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150550Z" creationid="tlqk35" creationdate="20220321T150550Z">
        <seg>닫힌 이름공간은 심지어 다른 파일일지라도 나중에 다시 열릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Navigation using the above commands can be tedious.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183548Z" creationid="tlqk3" creationdate="20220604T183548Z">
        <seg>위 명령을 사용한 탐색은 지루할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negation and Falsity</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164157Z" creationid="tlqk35" creationdate="20220321T164157Z">
        <seg>부정과 거짓</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Negation, <bpt i="1" x="1">&lt;g1&gt;</bpt>¬p<ept i="1">&lt;/g1&gt;</ept>, is actually defined to be <bpt i="2" x="2">&lt;g2&gt;</bpt>p → False<ept i="2">&lt;/g2&gt;</ept>, so we
obtain <bpt i="3" x="3">&lt;g3&gt;</bpt>¬p<ept i="3">&lt;/g3&gt;</ept> by deriving a contradiction from <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164220Z" creationid="tlqk35" creationdate="20220321T164220Z">
        <seg>부정 <bpt i="1" x="1">&lt;g1&gt;</bpt>¬p<ept i="1">&lt;/g1&gt;</ept>은 실제로 <bpt i="2" x="2">&lt;g2&gt;</bpt>p → False<ept i="2">&lt;/g2&gt;</ept>로 정의되어 있습니다. 그래서 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>로부터 모순을 유도함으로써 <bpt i="3" x="3">&lt;g3&gt;</bpt>¬p<ept i="3">&lt;/g3&gt;</ept>를 얻습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Nonetheless, it makes sense to describe the declarations
here, because they are straightforward variations on ordinary
inductive definitions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T164955Z" creationid="tlqk35" creationdate="20220528T164955Z">
        <seg>그래도 여전히 여기에 선언을 설명하는 것이 이치에 맞는 것 같습니다.왜냐하면 그들은 평범한 재귀적 정의에 직관적인 변형이기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Nor do you have
to name a section, which is to say, you can use an anonymous
<bpt i="1" x="1">&lt;g1&gt;</bpt>section<ept i="1">&lt;/g1&gt;</ept> / <bpt i="2" x="2">&lt;g2&gt;</bpt>end<ept i="2">&lt;/g2&gt;</ept> pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150138Z" creationid="tlqk35" creationdate="20220321T150138Z">
        <seg>섹션에 이름을 줄 필요도 없습니다. 그말은 즉슨, 여러분은 익명의 <bpt i="1" x="1">&lt;g1&gt;</bpt>section<ept i="1">&lt;/g1&gt;</ept> / <bpt i="2" x="2">&lt;g2&gt;</bpt>end<ept i="2">&lt;/g2&gt;</ept> 쌍을 사용할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Not</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161954Z" creationid="tlqk35" creationdate="20220321T161954Z">
        <seg>부정</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Not all of the information found here will be useful to you right
away.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173159Z" creationid="tlqk35" creationdate="20220524T173146Z">
        <seg>여기서 찾은 모든 정보가 여러분에게 바로 유용하지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notably, however, there is only one constructor, <bpt i="5" x="5">&lt;g5&gt;</bpt>refl<ept i="5">&lt;/g5&gt;</ept>, which
is an element of <bpt i="6" x="6">&lt;g6&gt;</bpt>Eq a a<ept i="6">&lt;/g6&gt;</ept>, and the curly braces after the
constructor tell Lean to make the argument to <bpt i="7" x="7">&lt;g7&gt;</bpt>refl<ept i="7">&lt;/g7&gt;</ept>
explicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153747Z" creationid="tlqk35" creationdate="20220528T153747Z">
        <seg>하지만 주목할 점은 오직 <bpt i="6" x="6">&lt;g6&gt;</bpt>Eq a a<ept i="6">&lt;/g6&gt;</ept>의 원소인 한 생성자 <bpt i="5" x="5">&lt;g5&gt;</bpt>refl<ept i="5">&lt;/g5&gt;</ept>있습니다. 그리고 생성자 뒤의 중괄호는 린에게 <bpt i="7" x="7">&lt;g7&gt;</bpt>refl<ept i="7">&lt;/g7&gt;</ept>을 명시적인 인수로 만들게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T190612Z" creationid="tlqk3" creationdate="20220525T190612Z">
        <seg>기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notationally,
this hides the specification of the type, making it look as though
<bpt i="2" x="2">&lt;g2&gt;</bpt>ident<ept i="2">&lt;/g2&gt;</ept> simply takes an argument of any type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153317Z" creationid="tlqk35" creationdate="20220321T153317Z">
        <seg>표기상으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>ident<ept i="2">&lt;/g2&gt;</ept>가 단순히 임의의 유형의 인수를 받을 수 있는 것처럼 만들어 유형의 명세를 감춥니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notations and Precedence</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T121326Z" creationid="tlqk3" creationdate="20220526T121326Z">
        <seg>기호와 결합순서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note
that <bpt i="10" x="10">&lt;g10&gt;</bpt>×<ept i="10">&lt;/g10&gt;</ept> is a Unicode symbol.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140054Z" creationid="tlqk35" creationdate="20220321T140054Z">
        <seg><bpt i="10" x="10">&lt;g10&gt;</bpt>×<ept i="10">&lt;/g10&gt;</ept>은 유니코드 기호임을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited.default<ept i="1">&lt;/g1&gt;</ept> doesn't have any explicit argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160148Z" creationid="tlqk3" creationdate="20220604T160148Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited.default<ept i="1">&lt;/g1&gt;</ept>가 어떤 명시적인 인수도 갖지 않음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that
if we used <bpt i="14" x="14">&lt;g14&gt;</bpt>notation<ept i="14">&lt;/g14&gt;</ept> directly to introduce an infix notation like</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123211Z" creationid="tlqk3" creationdate="20220526T123211Z">
        <seg>만약 우리가 이처럼 <bpt i="14" x="14">&lt;g14&gt;</bpt>notation<ept i="14">&lt;/g14&gt;</ept>를 전위 표기를 바로 도입하도록 사용한다면</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="11" x="11">&lt;g11&gt;</bpt>Eq a a<ept i="11">&lt;/g11&gt;</ept> is the only inhabited type in the family of types
<bpt i="12" x="12">&lt;g12&gt;</bpt>Eq a x<ept i="12">&lt;/g12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153941Z" creationid="tlqk35" creationdate="20220528T153941Z">
        <seg><bpt i="11" x="11">&lt;g11&gt;</bpt>Eq a a<ept i="11">&lt;/g11&gt;</ept>는 <bpt i="12" x="12">&lt;g12&gt;</bpt>Eq a x<ept i="12">&lt;/g12&gt;</ept>형의 군에서 유일한 내장 유형임을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="1" x="1">&lt;g1&gt;</bpt>Exists.intro<ept i="1">&lt;/g1&gt;</ept> has implicit arguments: Lean has to infer
the predicate <bpt i="2" x="2">&lt;g2&gt;</bpt>p : α → Prop<ept i="2">&lt;/g2&gt;</ept> in the conclusion <bpt i="3" x="3">&lt;g3&gt;</bpt>∃ x, p x<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181019Z" creationid="tlqk35" creationdate="20220321T181019Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Exists.intro<ept i="1">&lt;/g1&gt;</ept>은 암시적인자를 가지고 있음을 유의하세요. 린은 결론 <bpt i="3" x="3">&lt;g3&gt;</bpt>∃ x, p x<ept i="3">&lt;/g3&gt;</ept>에서 술어 <bpt i="2" x="2">&lt;g2&gt;</bpt>p : α → Prop<ept i="2">&lt;/g2&gt;</ept>를 추론해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.mul_add<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.add_mul<ept i="2">&lt;/g2&gt;</ept> are alternative names
for <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.left_distrib<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.right_distrib<ept i="4">&lt;/g4&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180000Z" creationid="tlqk35" creationdate="20220321T180000Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.mul_add<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.add_mul<ept i="2">&lt;/g2&gt;</ept>은 각각 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.left_distrib<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.right_distrib<ept i="4">&lt;/g4&gt;</ept>에 대한 별명임을 유의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept> works equally well as an induction
principle.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165846Z" creationid="tlqk3" creationdate="20220603T165846Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept>는 귀납 원리와 같이 동등하게 동작함을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that <bpt i="1" x="1">&lt;g1&gt;</bpt>x + y<ept i="1">&lt;/g1&gt;</ept> is notation for <bpt i="2" x="2">&lt;g2&gt;</bpt>Add.add x y<ept i="2">&lt;/g2&gt;</ept> in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155014Z" creationid="tlqk3" creationdate="20220604T155014Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>x + y<ept i="1">&lt;/g1&gt;</ept>는 린에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>Add.add x y<ept i="2">&lt;/g2&gt;</ept>에 대한 기호임을 주의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that Lean hides the other goals inside the <bpt i="1" x="1">&lt;g1&gt;</bpt>case<ept i="1">&lt;/g1&gt;</ept> block.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061427Z" creationid="tlqk35" creationdate="20220522T061427Z">
        <seg>린은 <bpt i="1" x="1">&lt;g1&gt;</bpt>case<ept i="1">&lt;/g1&gt;</ept>블록 안에 다른 목표를 숨긴 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that Lean inferred a more general type using <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort<ept i="1">&lt;/g1&gt;</ept> instead of <bpt i="2" x="2">&lt;g2&gt;</bpt>Type<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134836Z" creationid="tlqk3" creationdate="20220526T134836Z">
        <seg>린은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Type<ept i="2">&lt;/g2&gt;</ept>대신 <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort<ept i="1">&lt;/g1&gt;</ept>를 사용하여 더 일반적인 유형을 추론함을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that double does <bpt i="6" x="6">&lt;g6&gt;</bpt>not<ept i="6">&lt;/g6&gt;</ept> have <bpt i="7" x="7">&lt;g7&gt;</bpt>y<ept i="7">&lt;/g7&gt;</ept> as argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175335Z" creationid="tlqk35" creationdate="20220524T175335Z">
        <seg>double은 <bpt i="7" x="7">&lt;g7&gt;</bpt>y<ept i="7">&lt;/g7&gt;</ept>를 인수로서 갖지 <bpt i="6" x="6">&lt;g6&gt;</bpt>않음<ept i="6">&lt;/g6&gt;</ept>을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that it is often useful to use numeric unicode subscripts,
entered as <bpt i="1" x="1">&lt;g1&gt;</bpt>\0<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>\1<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>\2<ept i="3">&lt;/g3&gt;</ept>, ..., for hypotheses, as we did in
this example.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161817Z" creationid="tlqk35" creationdate="20220321T161817Z">
        <seg>수치 유니코드 밑첨자를 사용하는 것은 종종 유용합니다. 이 예제에서 그런 것처럼 가정에 대해 <bpt i="1" x="1">&lt;g1&gt;</bpt>\0<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>\1<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>\2<ept i="3">&lt;/g3&gt;</ept>, ..., 으로 쳐서 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that names automatically generated by Lean are inaccessible by default.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063146Z" creationid="tlqk35" creationdate="20220522T063146Z">
        <seg>린에 의해 자동으로 생성된 이름들은 기본적으로 접근할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expression is compiled using the <bpt i="2" x="2">&lt;g2&gt;</bpt>recursor<ept i="2">&lt;/g2&gt;</ept> <bpt i="3" x="3">&lt;g3&gt;</bpt>Weekday.rec<ept i="3">&lt;/g3&gt;</ept> generated when
you declare the inductive type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151947Z" creationid="tlqk3" creationdate="20220526T150557Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식은 여러분이 귀납형을 선언할 때 생성한 <bpt i="2" x="2">&lt;g2&gt;</bpt>recursor<ept i="2">&lt;/g2&gt;</ept> <bpt i="3" x="3">&lt;g3&gt;</bpt>Weekday.rec<ept i="3">&lt;/g3&gt;</ept>을 사용하여 컴파일 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the <bpt i="1" x="1">&lt;g1&gt;</bpt>theorem<ept i="1">&lt;/g1&gt;</ept> command is really a version of the
<bpt i="2" x="2">&lt;g2&gt;</bpt>def<ept i="2">&lt;/g2&gt;</ept> command: under the propositions and types
correspondence, proving the theorem <bpt i="3" x="3">&lt;g3&gt;</bpt>p → q → p<ept i="3">&lt;/g3&gt;</ept> is really the same
as defining an element of the associated type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160842Z" creationid="tlqk35" creationdate="20220321T160842Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>theorem<ept i="1">&lt;/g1&gt;</ept> 명령은 <bpt i="2" x="2">&lt;g2&gt;</bpt>def<ept i="2">&lt;/g2&gt;</ept> 명령의 한 버전이라는 것을 주목하세요. 명제와 유형 대응 하에서 정리 <bpt i="3" x="3">&lt;g3&gt;</bpt>p → q → p<ept i="3">&lt;/g3&gt;</ept>의 증명하는 것은 연관된 유형의 원소를 증명하는 것과 정말 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the anonymous constructor
notation <bpt i="5" x="5">&lt;g5&gt;</bpt>⟨w, hw.right, hw.left⟩<ept i="5">&lt;/g5&gt;</ept> abbreviates a nested constructor
application; we could equally well have written <bpt i="6" x="6">&lt;g6&gt;</bpt>⟨w, ⟨hw.right, hw.left⟩⟩<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181633Z" creationid="tlqk35" creationdate="20220321T181633Z">
        <seg>익명 생성자 기호 <bpt i="5" x="5">&lt;g5&gt;</bpt>⟨w, hw.right, hw.left⟩<ept i="5">&lt;/g5&gt;</ept>가 중첩된 생성자 활용을 간략히 한다는 것을 주목하세요. 우리는 이를 <bpt i="6" x="6">&lt;g6&gt;</bpt>⟨w, ⟨hw.right, hw.left⟩⟩<ept i="6">&lt;/g6&gt;</ept>로 동등한 의미를 갖게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the patterns are separated by commas.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162942Z" creationid="tlqk3" creationdate="20220529T162942Z">
        <seg>패턴이 콤마로 나뉜 것에 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the syntax is similar to the one used in <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expressions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070416Z" creationid="tlqk35" creationdate="20220522T070416Z">
        <seg>문법이 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식에서의 것과 비슷함에 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the universe
polymorphic <bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept> is even more verbose than the one previously defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134335Z" creationid="tlqk3" creationdate="20220526T134335Z">
        <seg>심지어 세계 다형적 <bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept>는 이전에 정의한 것보다 더 장황합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that the various <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> options we have discussed --- giving an
explicit list of rules, and using <bpt i="2" x="2">&lt;g2&gt;</bpt>at<ept i="2">&lt;/g2&gt;</ept> to specify the location --- can be combined,
but the order they are listed is rigid.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T165658Z" creationid="tlqk35" creationdate="20220524T165658Z">
        <seg>논의한 다양한 <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> 옵션은 규칙의 명시적인 리스트를 주고 <bpt i="2" x="2">&lt;g2&gt;</bpt>at<ept i="2">&lt;/g2&gt;</ept>을 
사용해 위치를 나타내는 것으로 결합될 수 있다. 그러나 나열된 순서는 변하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that this example is somewhat artificial, one could also do:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183357Z" creationid="tlqk3" creationdate="20220604T183357Z">
        <seg>이 예제는 다소 인위적이며 누군가는 다음과 같이 할 수 있음을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that up to the names we have chosen for the variables, the
definitions are identical to the proofs of the analogous propositions
for conjunction and disjunction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220523T073708Z" creationid="tlqk35" creationdate="20220523T073708Z">
        <seg>우리가 변수에 대한 이름을 선택하는 한 정의들은 
결합자와 분리자에 대한 유사한 명제의 증명과 
동일할 것임을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that we can omit recursive equations for "unreachable" cases such
as <bpt i="1" x="1">&lt;g1&gt;</bpt>head nil<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T184000Z" creationid="tlqk3" creationdate="20220603T184000Z">
        <seg>우리는 재귀 방정식을 <bpt i="1" x="1">&lt;g1&gt;</bpt>head nil<ept i="1">&lt;/g1&gt;</ept> 같이 "도달할 수 없는" 경우에 대해 생략할 수 있음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that you can define a
binary operation like <bpt i="5" x="5">&lt;g5&gt;</bpt>and<ept i="5">&lt;/g5&gt;</ept> using <bpt i="6" x="6">&lt;g6&gt;</bpt>match<ept i="6">&lt;/g6&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152449Z" creationid="tlqk3" creationdate="20220526T152449Z">
        <seg>여러분이  <bpt i="5" x="5">&lt;g5&gt;</bpt>and<ept i="5">&lt;/g5&gt;</ept>같은 이항 연산을 <bpt i="6" x="6">&lt;g6&gt;</bpt>match<ept i="6">&lt;/g6&gt;</ept>를 사용해 정의할 수 있다는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that you can double a natural number <bpt i="1" x="1">&lt;g1&gt;</bpt>n<ept i="1">&lt;/g1&gt;</ept> by <bpt i="2" x="2">&lt;g2&gt;</bpt>double { add := Nat.add } n<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153447Z" creationid="tlqk3" creationdate="20220604T153447Z">
        <seg>여러분은 자연수 <bpt i="1" x="1">&lt;g1&gt;</bpt>n<ept i="1">&lt;/g1&gt;</ept>을 <bpt i="2" x="2">&lt;g2&gt;</bpt>double { add := Nat.add } n<ept i="2">&lt;/g2&gt;</ept>으로 두 배로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that you chain instances and generalize the second instance.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164254Z" creationid="tlqk3" creationdate="20220604T164254Z">
        <seg>여러분은 개체를 연결하고 두 번째 개체를 일반화함을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Note that, Lean "closes" the declaration by adding any local variable occurring in the
<bpt i="5" x="5">&lt;g5&gt;</bpt>let rec<ept i="5">&lt;/g5&gt;</ept> declaration as additional parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182210Z" creationid="tlqk3" creationdate="20220603T182210Z">
        <seg>린이 추가적인 매개변수로 <bpt i="5" x="5">&lt;g5&gt;</bpt>let rec<ept i="5">&lt;/g5&gt;</ept> 선언에서 생긴 임의의 지역변수를 추가함으로써 선언이 닫힌다는 점을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice also that, when the value of an argument is not needed in the
definition, you can use an underscore instead.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163136Z" creationid="tlqk3" creationdate="20220529T163136Z">
        <seg>인수의 값은 정의에서 필요하지 않음도 주목하세요. 여러분은 대신 밑줄 문자를 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice here we called the <bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept> function to create the first
parameter to <bpt i="2" x="2">&lt;g2&gt;</bpt>add<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144328Z" creationid="tlqk35" creationdate="20220321T144328Z">
        <seg>여기서 우리가 <bpt i="2" x="2">&lt;g2&gt;</bpt>add<ept i="2">&lt;/g2&gt;</ept>의 첫 번째 매개변수를 만들기 위해 <bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept> 함수를 호출한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that <bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α) → β<ept i="1">&lt;/g1&gt;</ept> makes sense for any expression <bpt i="2" x="2">&lt;g2&gt;</bpt>β :
Type<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151858Z" creationid="tlqk35" creationdate="20220321T151858Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>(a : α) → β<ept i="1">&lt;/g1&gt;</ept>는  모든 식  <bpt i="2" x="2">&lt;g2&gt;</bpt>β : Type<ept i="2">&lt;/g2&gt;</ept>에 대해 성립하는 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> can be used to produce data as well as prove propositions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164947Z" creationid="tlqk3" creationdate="20220527T164947Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept>는 데이터를 만드는 것만 아니라 명제를 증명하는 데에도 사용될 수 있음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that a type with multiple constructors is disjunctive: an
element of <bpt i="1" x="1">&lt;g1&gt;</bpt>Sum α β<ept i="1">&lt;/g1&gt;</ept> is either of the form <bpt i="2" x="2">&lt;g2&gt;</bpt>inl a<ept i="2">&lt;/g2&gt;</ept> <bpt i="3" x="3">&lt;g3&gt;</bpt>or<ept i="3">&lt;/g3&gt;</ept> of the
form <bpt i="4" x="4">&lt;g4&gt;</bpt>inl b<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T155959Z" creationid="tlqk3" creationdate="20220526T155959Z">
        <seg>다수의 생성자가 있는 유형은 분리적임을 주목하세요. <bpt i="1" x="1">&lt;g1&gt;</bpt>Sum α β<ept i="1">&lt;/g1&gt;</ept>의 원소는 <bpt i="2" x="2">&lt;g2&gt;</bpt>inl a<ept i="2">&lt;/g2&gt;</ept>의 형태 <bpt i="3" x="3">&lt;g3&gt;</bpt>또는<ept i="3">&lt;/g3&gt;</ept> <bpt i="4" x="4">&lt;g4&gt;</bpt>inl b<ept i="4">&lt;/g4&gt;</ept>의 형태입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that an existential proposition is very similar to a sigma
type, as described in dependent types section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181643Z" creationid="tlqk35" creationdate="20220321T181643Z">
        <seg>존재 명제는 의존 유형론 섹션에서 설명했던 시그마 유형과 아주 비슷한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that and-introduction and and-elimination are similar to the
pairing and projection operations for the cartesian product.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162854Z" creationid="tlqk35" creationdate="20220321T162854Z">
        <seg>and-도입과 and-제거는 카테시안 곱 연산의 순서쌍을 구성하는 것과 순서쌍에서 원소를 추출하는 연산과 비슷한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that applying a term <bpt i="1" x="1">&lt;g1&gt;</bpt>t : α → β<ept i="1">&lt;/g1&gt;</ept> to a term <bpt i="2" x="2">&lt;g2&gt;</bpt>s : α<ept i="2">&lt;/g2&gt;</ept> yields
an expression <bpt i="3" x="3">&lt;g3&gt;</bpt>t s : β<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143513Z" creationid="tlqk35" creationdate="20220321T143513Z">
        <seg>항 <bpt i="1" x="1">&lt;g1&gt;</bpt>t : α → β<ept i="1">&lt;/g1&gt;</ept>을 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>s : α<ept i="2">&lt;/g2&gt;</ept>에 적용하여 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>t s : β<ept i="3">&lt;/g3&gt;</ept>을 얻는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that if <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> is any
type, we can form the type <bpt i="2" x="2">&lt;g2&gt;</bpt>α → Prop<ept i="2">&lt;/g2&gt;</ept> of all predicates on <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>
(the "power type of <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>").</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175148Z" creationid="tlqk35" creationdate="20220321T175148Z">
        <seg>만약 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>가 임의의 유형이면, 우리는  <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>에 대한 모든 술어에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>α → Prop<ept i="2">&lt;/g2&gt;</ept>형을 만들 수 있습니다. (" <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>형의 능력")</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that if <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> is any type, we can represent a unary predicate
<bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> on <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept> as an object of type <bpt i="4" x="4">&lt;g4&gt;</bpt>α → Prop<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172626Z" creationid="tlqk35" creationdate="20220321T172626Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> 가 임의의 유형인지를 보세요, 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>에 대해 단항 술어 p를  <bpt i="4" x="4">&lt;g4&gt;</bpt>α → Prop<ept i="4">&lt;/g4&gt;</ept>형의 대상으로 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that implicit arguments are inserted eagerly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184901Z" creationid="tlqk3" creationdate="20220525T184901Z">
        <seg>암시적인 인수는 간절히 삽입됨을 주의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that now the first <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> command gives the type of the
identifier, <bpt i="2" x="2">&lt;g2&gt;</bpt>id<ept i="2">&lt;/g2&gt;</ept>, without inserting any placeholders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153754Z" creationid="tlqk35" creationdate="20220321T153754Z">
        <seg>현재 첫 번째 <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> 명령은 식별자 <bpt i="2" x="2">&lt;g2&gt;</bpt>id<ept i="2">&lt;/g2&gt;</ept>의 유형을 어떤 플레이스 홀더도 삽입하지 않고 주는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the <bpt i="1" x="1">&lt;g1&gt;</bpt>cons<ept i="1">&lt;/g1&gt;</ept> constructor takes an element of
<bpt i="2" x="2">&lt;g2&gt;</bpt>Vector α n<ept i="2">&lt;/g2&gt;</ept> and returns an element of <bpt i="3" x="3">&lt;g3&gt;</bpt>Vector α (n+1)<ept i="3">&lt;/g3&gt;</ept>, thereby using an
element of one member of the family to build an element of another.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153334Z" creationid="tlqk35" creationdate="20220528T153334Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cons<ept i="1">&lt;/g1&gt;</ept> 생성자는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Vector α n<ept i="2">&lt;/g2&gt;</ept>의 원소를 받고 <bpt i="3" x="3">&lt;g3&gt;</bpt>Vector α (n+1)<ept i="3">&lt;/g3&gt;</ept>의 원소를 반환합니다. 그러므로 군의 한 구성원의 원소를 다른 원소를 만드는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the expression <bpt i="1" x="1">&lt;g1&gt;</bpt>m + 3 * k<ept i="1">&lt;/g1&gt;</ept> is erased by <bpt i="2" x="2">&lt;g2&gt;</bpt>generalize<ept i="2">&lt;/g2&gt;</ept>; all
that matters is whether it is of the form <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> or <bpt i="4" x="4">&lt;g4&gt;</bpt>succ a<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170356Z" creationid="tlqk3" creationdate="20220527T170356Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>m + 3 * k<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>generalize<ept i="2">&lt;/g2&gt;</ept>에 의해 지워짐을 보세요. 중요한 것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>0<ept i="3">&lt;/g3&gt;</ept> 혹은 <bpt i="4" x="4">&lt;g4&gt;</bpt>succ a<ept i="4">&lt;/g4&gt;</ept>의 형태인지 아닌지 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the lambda abstractions <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>hq : q<ept i="2">&lt;/g2&gt;</ept> can be
viewed as temporary assumptions in the proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>t1<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161038Z" creationid="tlqk35" creationdate="20220321T161038Z">
        <seg>람다 추상화 <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>hq : q<ept i="2">&lt;/g2&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>t1<ept i="3">&lt;/g3&gt;</ept>의 증명에서 일시적인 가정으로 보일 수 있음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the last example specifies that the rewrite
should take place on the right-hand side by specifying the second
argument to <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat.add_comm<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171924Z" creationid="tlqk35" creationdate="20220524T160039Z">
        <seg>마지막 예제는  <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat.add_comm<ept i="10">&lt;/g10&gt;</ept>의 
두 번째 인수를 명시함으로써 우변에 다시쓰기가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the meaning of the expression <bpt i="1" x="1">&lt;g1&gt;</bpt>let a := t1; t2<ept i="1">&lt;/g1&gt;</ept> is very
similar to the meaning of <bpt i="2" x="2">&lt;g2&gt;</bpt>(fun a =&gt; t2) t1<ept i="2">&lt;/g2&gt;</ept>, but the two are not
the same.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144909Z" creationid="tlqk35" creationdate="20220321T144909Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>let a := t1; t2<ept i="1">&lt;/g1&gt;</ept>의 의미는 <bpt i="2" x="2">&lt;g2&gt;</bpt>(fun a =&gt; t2) t1<ept i="2">&lt;/g2&gt;</ept>의 의미와 아주 비슷함을 주목하세요. 그러나 이 둘은 같지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the product type depends on parameters <bpt i="1" x="1">&lt;g1&gt;</bpt>α β : Type<ept i="1">&lt;/g1&gt;</ept>
which are arguments to the constructors as well as <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T155421Z" creationid="tlqk3" creationdate="20220526T155421Z">
        <seg>곱 유형은 생성자와 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>의 인수인 매개변수 <bpt i="1" x="1">&lt;g1&gt;</bpt>α β : Type<ept i="1">&lt;/g1&gt;</ept>에 의존하였음을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the second example and the last two examples require the
assumption that there is at least one element <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept> of type <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183157Z" creationid="tlqk35" creationdate="20220321T183157Z">
        <seg>두 번째 예제와 마지막 두 예제는 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>형의 한 원소 <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept>가 적어도 하나 있다는 가정을 필요로 한다는 것을 유의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that the second implicit parameter to <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept>, which
provides the context in which the substitution is to occur, has type
<bpt i="2" x="2">&lt;g2&gt;</bpt>α → Prop<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180044Z" creationid="tlqk35" creationdate="20220321T180044Z">
        <seg>대체가 일어나는 곳에 대한 맥락을 제공하는 두번째 암시적 인수 <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept>이 <bpt i="2" x="2">&lt;g2&gt;</bpt>α → Prop<ept i="2">&lt;/g2&gt;</ept>형을 가지는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that there is enough information in the full expression for
Lean to infer the types of <bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>hq<ept i="2">&lt;/g2&gt;</ept> as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164048Z" creationid="tlqk35" creationdate="20220321T164048Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>hp<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>hq<ept i="2">&lt;/g2&gt;</ept>의 유형을 추론하기에 린에게 완전한 표현식에 충분한 정보가 있음을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that we do not include the types <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept> in the target
of the constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152934Z" creationid="tlqk3" creationdate="20220526T152934Z">
        <seg>우리가 생성자의 대상에 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>형과 <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept>형을 포함하지 않은 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that, once again, when <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.recOn<ept i="1">&lt;/g1&gt;</ept> is used in the context of
a proof, it is really the induction principle in disguise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T161151Z" creationid="tlqk3" creationdate="20220527T161151Z">
        <seg>다시 한 번 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.recOn<ept i="1">&lt;/g1&gt;</ept>은 증명의 맥락에서 사용됨을 주목하세요. 이는 정말로 귀납 원리가 위장한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Notice that, under the propositions-as-types correspondence, we can
use <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> to prove theorems as well as define functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151724Z" creationid="tlqk3" creationdate="20220526T151724Z">
        <seg>유형으로써 명제 대응 하에서 우리는 합수를 정의하는 것 뿐만 아니라 정리를 증명하는데 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now to get a bit more abstract, you can also specify arguments that
are like type parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144422Z" creationid="tlqk35" creationdate="20220321T144422Z">
        <seg>이제 약간 더 추상적으로 갑시다. 여러분은 유형 매개변수같은 인수를 지정할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now we can apply the theorem <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept> just as a function application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161146Z" creationid="tlqk35" creationdate="20220321T161146Z">
        <seg>이제 우리는 정리 <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept>을 함수 활용에 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now we populate the class with some instances:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160433Z" creationid="tlqk3" creationdate="20220604T160433Z">
        <seg>이제 몇몇 개체로 클래스를 채우겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now, given that
<bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept> has type <bpt i="6" x="6">&lt;g6&gt;</bpt>∀ x : α, p x ∧ q x<ept i="6">&lt;/g6&gt;</ept>, the expression <bpt i="7" x="7">&lt;g7&gt;</bpt>h y<ept i="7">&lt;/g7&gt;</ept> has type
<bpt i="8" x="8">&lt;g8&gt;</bpt>p y ∧ q y<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173844Z" creationid="tlqk35" creationdate="20220321T173844Z">
        <seg>이제 <bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept>가 <bpt i="6" x="6">&lt;g6&gt;</bpt>∀ x : α, p x ∧ q x<ept i="6">&lt;/g6&gt;</ept>형을 갖는다고 해봅시다. 그러면 표현식 <bpt i="7" x="7">&lt;g7&gt;</bpt>h y<ept i="7">&lt;/g7&gt;</ept>는  <bpt i="8" x="8">&lt;g8&gt;</bpt>p y ∧ q y<ept i="8">&lt;/g8&gt;</ept>형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now, we explore another application.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155131Z" creationid="tlqk3" creationdate="20220604T155131Z">
        <seg>여기서 우리는 다른 적용을 탐색합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Now, we reveal how the notation <bpt i="7" x="7">&lt;g7&gt;</bpt>a*b<ept i="7">&lt;/g7&gt;</ept> is defined in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170133Z" creationid="tlqk3" creationdate="20220604T170133Z">
        <seg>이제 우리는 린에서 기호 <bpt i="7" x="7">&lt;g7&gt;</bpt>a*b<ept i="7">&lt;/g7&gt;</ept>이 어떻게 정의되는지 드러냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numerals</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162145Z" creationid="tlqk3" creationdate="20220604T162145Z">
        <seg>수치값(Numerals)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153644Z" creationid="tlqk35" creationdate="20220321T153644Z">
        <seg>수치들은 Lean에 매우 많이 있습니다. 그러나 수치 유형이 추론되지 못할 때, 린은 기본적으로 그걸 자연수라고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Numerals are polymorphic in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162157Z" creationid="tlqk3" creationdate="20220604T162157Z">
        <seg>수치값들은 린에서 다형적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Objects</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181844Z" creationid="tlqk35" creationdate="20220528T181844Z">
        <seg>대상(개체, 객체)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Of course, a fundamental property of equality is that it is an equivalence relation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175431Z" creationid="tlqk35" creationdate="20220321T175431Z">
        <seg>물론 동등의 기초적인 성질은 등가 관계라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Of course, it is unsound
as a proof method -- for example, you can use it to prove <bpt i="2" x="2">&lt;g2&gt;</bpt>False<ept i="2">&lt;/g2&gt;</ept> --
and Lean produces severe warnings when files use or import theorems
which depend on it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170302Z" creationid="tlqk35" creationdate="20220321T170302Z">
        <seg>물론 증명 방법으로 건전하지 않습니다. -- 예를 들어, 여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>False<ept i="2">&lt;/g2&gt;</ept> 을 증명하는데 그것을 사용할 수 있습니다. --그러면 린은 그것에 의존하는 정리를 불러오거나 그런 파일을 사용할 때 심각한 경고를 보냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Of course, it would be highly cumbersome for users to manually pass the
implementations around in this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153552Z" creationid="tlqk3" creationdate="20220604T153552Z">
        <seg>당연히 이처럼 구현을 수동적으로 넘겨야 한다면 사용자에게 아주 성가실 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Of course, wildcards are allowed:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183731Z" creationid="tlqk3" creationdate="20220604T183731Z">
        <seg>당연히 와일드카드도 허용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often proofs move from one fact to the next, so this can be effective
in eliminating the clutter of lots of labels.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183348Z" creationid="tlqk35" creationdate="20220321T183348Z">
        <seg>증명은 종종 한 사실에서 다음 사실로 이동하기 때문에 이것은 많은 이름으로 생기는 혼동을 없애는 데 효과적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often the name of theorem simply describes the conclusion:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132212Z" creationid="tlqk3" creationdate="20220526T132212Z">
        <seg>정리의 이름은 종종 결론을 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Often, when you import a module, you will want to open one or
more of the namespaces it contains, to have access to the short
identifiers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150448Z" creationid="tlqk35" creationdate="20220321T150448Z">
        <seg>짧은 식별자로 접근하기 위해서 종종 여러분이 모듈을 가져오기(import) 할 때, 모듈이 담은 다수의 이름공간을 열기 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On the assumption that <bpt i="8" x="8">&lt;g8&gt;</bpt>decide p = true<ept i="8">&lt;/g8&gt;</ept> holds, <bpt i="9" x="9">&lt;g9&gt;</bpt>of_decide_eq_true<ept i="9">&lt;/g9&gt;</ept>
produces a proof of <bpt i="10" x="10">&lt;g10&gt;</bpt>p<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174937Z" creationid="tlqk3" creationdate="20220604T174937Z">
        <seg><bpt i="8" x="8">&lt;g8&gt;</bpt>decide p = true<ept i="8">&lt;/g8&gt;</ept>가 성립한다고 가정하면 <bpt i="9" x="9">&lt;g9&gt;</bpt>of_decide_eq_true<ept i="9">&lt;/g9&gt;</ept>는 <bpt i="10" x="10">&lt;g10&gt;</bpt>p<ept i="10">&lt;/g10&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On the other hand, <bpt i="3" x="3">&lt;g3&gt;</bpt>#reduce fib &lt;n&gt;<ept i="3">&lt;/g3&gt;</ept> is efficient because it uses the definition sent to the kernel that
is based on the <bpt i="4" x="4">&lt;g4&gt;</bpt>brecOn<ept i="4">&lt;/g4&gt;</ept> construction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165140Z" creationid="tlqk3" creationdate="20220603T165140Z">
        <seg>다른 한편 <bpt i="3" x="3">&lt;g3&gt;</bpt>#reduce fib &lt;n&gt;<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>brecOn<ept i="4">&lt;/g4&gt;</ept> 생성자에 기반한 커널에 보내져 정의를 사용하기 때문에 효율적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>On this basis, the
standard library provides a default element, <bpt i="6" x="6">&lt;g6&gt;</bpt>defaulty<ept i="6">&lt;/g6&gt;</ept>, of
any inhabited type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165808Z" creationid="tlqk3" creationdate="20220529T165808Z">
        <seg>이 기초로부터 표준 라이브러리는 임의의 거주 유형에 대해 기본 원소 <bpt i="6" x="6">&lt;g6&gt;</bpt>defaulty<ept i="6">&lt;/g6&gt;</ept>를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once
again, we can use arithmetic notation, as in the version below.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162448Z" creationid="tlqk3" creationdate="20220529T162448Z">
        <seg>다시 한 번 우리는 산술적 기호를 아래 버전에서 처럼 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, cases will revert, split, and then reintroduce depedencies in the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165113Z" creationid="tlqk3" creationdate="20220527T165113Z">
        <seg>다시 한번, cases는 맥락의 종속물들을 되돌리고, 나누고, 재도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, it is the Curry-Howard isomorphism that allows
us to co-opt this mechanism for writing proofs as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182618Z" creationid="tlqk35" creationdate="20220321T182618Z">
        <seg>한 번 더  커리-하워드 동형은 우리가 증명을 작성하는 데에도 이 메커니즘과 함께 쓰이게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, using the propositions-as-types correspondence, the
variable <bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept> of type <bpt i="2" x="2">&lt;g2&gt;</bpt>r → s<ept i="2">&lt;/g2&gt;</ept> can be viewed as the hypothesis, or
premise, that <bpt i="3" x="3">&lt;g3&gt;</bpt>r → s<ept i="3">&lt;/g3&gt;</ept> holds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161724Z" creationid="tlqk35" creationdate="20220321T161724Z">
        <seg>다시 한 번, 유형으로써 명제 대응을 사용하면 <bpt i="2" x="2">&lt;g2&gt;</bpt>r → s<ept i="2">&lt;/g2&gt;</ept>형의 변수 <bpt i="1" x="1">&lt;g1&gt;</bpt>h<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="3" x="3">&lt;g3&gt;</bpt>r → s<ept i="3">&lt;/g3&gt;</ept>을 성립시키는 가정 또는 전제로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, you should exercise judgment as to whether such
abbreviations enhance or diminish readability.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164151Z" creationid="tlqk35" creationdate="20220321T164151Z">
        <seg>다시 한 번, 여러분은 그러한 간략화가 가독성을 높이는지 낮추는지 판단을 시험해보셔야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once again, you should try some examples on your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140307Z" creationid="tlqk35" creationdate="20220321T140307Z">
        <seg>다시 한번 여러분 스스로 몇 가지 예제를 시도해보기 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once arrived at the relevant target, we can use <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> as in normal
tactic mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182903Z" creationid="tlqk3" creationdate="20220604T182903Z">
        <seg>일단 연관된 대상에 도달하면 일반 전략 모드처럼 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once the attribute is applied, however, there is no way to permanently
remove it; it persists in any file that imports the one where the
attribute is assigned.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171543Z" creationid="tlqk35" creationdate="20220524T165238Z">
        <seg>그러나 한 번 이 특성이 적용되면 그 특성이 부여된 정리를 불러온 어떤 파일이든 
지속되므로 영구적으로 이를 제거할 방법이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Once the proof of a
theorem is complete, typically we only need to know that the proof
exists; it doesn't matter what the proof is.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160910Z" creationid="tlqk35" creationdate="20220321T160910Z">
        <seg>한번 정리의 증명이 마쳐지면 우리는 증명이 존재한다는 것만 알면 됩니다. 증명이 무엇인지 아는 것은 중요하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One again, you can reduce the proof to:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162702Z" creationid="tlqk3" creationdate="20220527T162240Z">
        <seg>다시한번 여러분은 증명을 다음과 같이 줄일 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can also assign the attribute any time after the definition takes place:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183057Z" creationid="tlqk3" creationdate="20220525T183031Z">
        <seg>어떤 이는 이 정의를 만든 뒤 어느 때든지 특성을 부여할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can also specify imports relative to the current directory; for example,
Importing is transitive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174453Z" creationid="tlqk35" creationdate="20220524T174453Z">
        <seg>어떤 이는 현재 경로에 상대적으로 불러오기를 명시할 수 있습니다. 예를 들어 불러오는 것은 전이적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can always specify the type <bpt i="1" x="1">&lt;g1&gt;</bpt>T<ept i="1">&lt;/g1&gt;</ept> of an expression <bpt i="2" x="2">&lt;g2&gt;</bpt>e<ept i="2">&lt;/g2&gt;</ept> by
writing <bpt i="3" x="3">&lt;g3&gt;</bpt>(e : T)<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153518Z" creationid="tlqk35" creationdate="20220321T153518Z">
        <seg>누군가는 표현식 <bpt i="2" x="2">&lt;g2&gt;</bpt>e<ept i="2">&lt;/g2&gt;</ept>의 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>T<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>(e : T)<ept i="3">&lt;/g3&gt;</ept>와 같이 씀으로써 항상 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can shortcut it using pattern matching as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183652Z" creationid="tlqk3" creationdate="20220604T183652Z">
        <seg>누군가는 다음과 같이 패턴 매칭을 사용하여 그것을 손쉽게 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can show that the type
<bpt i="2" x="2">&lt;g2&gt;</bpt>TreeList α<ept i="2">&lt;/g2&gt;</ept> is <bpt i="3" x="3">&lt;g3&gt;</bpt>isomorphic<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>List (Tree α)<ept i="4">&lt;/g4&gt;</ept>, but translating
results back and forth along this isomorphism is tedious.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T170238Z" creationid="tlqk35" creationdate="20220528T170238Z">
        <seg>어떤 이는 <bpt i="2" x="2">&lt;g2&gt;</bpt>TreeList α<ept i="2">&lt;/g2&gt;</ept>형이 <bpt i="4" x="4">&lt;g4&gt;</bpt>List (Tree α)<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>i동형(somorphic)<ept i="3">&lt;/g3&gt;</ept>임을 보일 수 있습니다. 그러나 이 동형을 따라 결과를 앞뒤로 번역하는 것은 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One can similarly infer the argument in <bpt i="6" x="6">&lt;g6&gt;</bpt>Lst.nil Nat<ept i="6">&lt;/g6&gt;</ept>, not
from anything else in that expression, but from the fact that it is
sent as an argument to the function <bpt i="7" x="7">&lt;g7&gt;</bpt>Lst.cons<ept i="7">&lt;/g7&gt;</ept>, which expects an element
of type <bpt i="8" x="8">&lt;g8&gt;</bpt>Lst α<ept i="8">&lt;/g8&gt;</ept> in that position.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153125Z" creationid="tlqk35" creationdate="20220321T152730Z">
        <seg>어떤 식으로부터도 아니고 <bpt i="8" x="8">&lt;g8&gt;</bpt>Lst α<ept i="8">&lt;/g8&gt;</ept>형의 원소를 기대하는 <bpt i="7" x="7">&lt;g7&gt;</bpt> Lst.cons<ept i="7">&lt;/g7&gt;</ept> 함수에 인수로 전달되었다는 사실로부터 누군가는 비슷하게 <bpt i="6" x="6">&lt;g6&gt;</bpt>Lst.nil Nat<ept i="6">&lt;/g6&gt;</ept>에서 인수를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One consequence of the law of the excluded middle is the principle of
double-negation elimination:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165753Z" creationid="tlqk35" creationdate="20220321T165753Z">
        <seg>배중률의 한 결과는 이중 부정 제거의 원리입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One example is the
definition of <bpt i="5" x="5">&lt;g5&gt;</bpt>Vector α n<ept i="5">&lt;/g5&gt;</ept>, the type of vectors of elements of <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>
of length <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153211Z" creationid="tlqk35" creationdate="20220528T153211Z">
        <seg>한 예제는 길이 <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>의  <bpt i="6" x="6">&lt;g6&gt;</bpt>α<ept i="6">&lt;/g6&gt;</ept>를 원소로 하는 벡터 유형 <bpt i="5" x="5">&lt;g5&gt;</bpt>Vector α n<ept i="5">&lt;/g5&gt;</ept>의 정의입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One solution is to define an auxiliary function:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180121Z" creationid="tlqk3" creationdate="20220603T180121Z">
        <seg>우리의 방법은 부가적인 함수를 정의하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One strategy for proving assertions about objects defined in the
language of dependent type theory is to layer an assertion language
and a proof language on top of the definition language.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154820Z" creationid="tlqk35" creationdate="20220321T154820Z">
        <seg>의존 유형론의 언어로 정의된 객체에 대해서 주장을 증명하는 한 전략은 주장 언어와 증명 언어를 정의언어의 꼭대기 층에 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One thing that is nice about Lean's proof-writing syntax is that it is
possible to mix term-style and tactic-style proofs, and pass between
the two freely.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142848Z" creationid="tlqk35" creationdate="20220524T142848Z">
        <seg>Lean의 증명 작성 문법에 대해 좋은 점은 항 스타일과 전략 스타일의 증명을 섞고,
 이들 사이를 자유로이 왕래할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One thing that makes the simplifier especially useful is that its
capabilities can grow as a library develops.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171639Z" creationid="tlqk35" creationdate="20220524T164211Z">
        <seg>단순화기를 특히 유용하게 만드는 한 가지는 그것의 능력이 
라이브러리가 개발되어 감에 따라 증가한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One very useful family of options controls the way Lean's <bpt i="1" x="1">&lt;g1&gt;</bpt>pretty- printer<ept i="1">&lt;/g1&gt;</ept> displays terms.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125933Z" creationid="tlqk3" creationdate="20220526T125915Z">
        <seg>매우 유용한 옵션 모음 중 하나는 린의 <bpt i="1" x="1">&lt;g1&gt;</bpt>pretty- printer<ept i="1">&lt;/g1&gt;</ept>가 항을 표시하는 방식을 제어합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>One way in which Lean's dependent type theory extends simple type
theory is that types themselves --- entities like <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Bool<ept i="2">&lt;/g2&gt;</ept>
--- are first-class citizens, which is to say that they themselves are
objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141313Z" creationid="tlqk35" creationdate="20220321T141313Z">
        <seg>린의 종속 유형론이 단순 유형론을 확장시키는 한 방법은 ---<bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Bool<ept i="2">&lt;/g2&gt;</ept>같은 개체는 그들 그 자체로 대상인 일등 시민 ---으로 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Open a namespace <bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept> to avoid naming conflicts, and use the
equation compiler to define addition, multiplication, and
exponentiation on the natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180856Z" creationid="tlqk3" creationdate="20220603T180856Z">
        <seg>이름공간<bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept>을 열어 이름 충돌을 피하세요. 그리고 방정식 컴파일러로 덧셈, 곱셈 그리고 거듭제곱을 자연수에 대해 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option <bpt i="1" x="1">&lt;g1&gt;</bpt>synthInstance.maxHeartbeats<ept i="1">&lt;/g1&gt;</ept> specifies the maximum amount of
heartbeats per typeclass resolution problem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180749Z" creationid="tlqk3" creationdate="20220604T180749Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>synthInstance.maxHeartbeats<ept i="1">&lt;/g1&gt;</ept> 옵션은 유형 클래스 해결 문제 당 최대 심박수 양을 지정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Option <bpt i="2" x="2">&lt;g2&gt;</bpt>synthInstance.maxSize<ept i="2">&lt;/g2&gt;</ept> is the maximum number of instances used
to construct a solution in the type class instance synthesis procedure.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180921Z" creationid="tlqk3" creationdate="20220604T180921Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>synthInstance.maxSize<ept i="2">&lt;/g2&gt;</ept> 옵션은 유형 클래스 개체 합성 절차에서 해을 만드는 데 사용되는 최대 개체수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Or</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162105Z" creationid="tlqk35" creationdate="20220321T162105Z">
        <seg>논리합</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Or even this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180458Z" creationid="tlqk35" creationdate="20220321T180458Z">
        <seg>심지어 이렇게도 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Or you can carry out a proof by contradiction:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165949Z" creationid="tlqk35" creationdate="20220321T165949Z">
        <seg>한편 여러분은 귀류법으로 증명을 도출할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ordinarily, you meet such a goal by writing an explicit term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184454Z" creationid="tlqk35" creationdate="20220321T184454Z">
        <seg>일반적으로 명시적인 항을 작성하여 이런 목표를 달성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Ordinary classical logic adds to
this the law of the excluded middle, <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ ¬p<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185340Z" creationid="tlqk35" creationdate="20220321T165657Z">
        <seg>평범한 고전 논리는 여기에 배중률 <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∨ ¬p<ept i="1">&lt;/g1&gt;</ept>을 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other Recursive Data Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162745Z" creationid="tlqk3" creationdate="20220527T162745Z">
        <seg>다른 재귀적인 데이터 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other properties:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170151Z" creationid="tlqk35" creationdate="20220321T170151Z">
        <seg>다른 성질들:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other systems provide search procedures and decision procedures for specific languages and domains,
such as linear or nonlinear expressions over the integers or the real numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131328Z" creationid="tlqk35" creationdate="20220321T131328Z">
        <seg>다른 시스템들은 특정 언어와 영역에 대한 선형 혹은 비선형 식(가령 정수나 실수에 대해 정의된)들에 탐색 절차과 결정 절차를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Other tactics inside conversion mode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183901Z" creationid="tlqk3" creationdate="20220604T183901Z">
        <seg>전환 모드 속 다른 전략</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Otherwise, <bpt i="6" x="6">&lt;g6&gt;</bpt>v<ept i="6">&lt;/g6&gt;</ept> is of the form <bpt i="7" x="7">&lt;g7&gt;</bpt>a :: w<ept i="7">&lt;/g7&gt;</ept>, and we can simply
return <bpt i="8" x="8">&lt;g8&gt;</bpt>w<ept i="8">&lt;/g8&gt;</ept>, after casting it from a vector of length <bpt i="9" x="9">&lt;g9&gt;</bpt>m<ept i="9">&lt;/g9&gt;</ept> to a
vector of length <bpt i="10" x="10">&lt;g10&gt;</bpt>n<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183522Z" creationid="tlqk3" creationdate="20220603T183522Z">
        <seg>그렇지 않으면 <bpt i="6" x="6">&lt;g6&gt;</bpt>v<ept i="6">&lt;/g6&gt;</ept>는 <bpt i="7" x="7">&lt;g7&gt;</bpt>a :: w<ept i="7">&lt;/g7&gt;</ept>꼴이고 길이 <bpt i="9" x="9">&lt;g9&gt;</bpt>m<ept i="9">&lt;/g9&gt;</ept>의 벡터에서 길이 <bpt i="10" x="10">&lt;g10&gt;</bpt>n<ept i="10">&lt;/g10&gt;</ept>의 벡터로 이를 바꾼 후에 우리는 단순히 <bpt i="8" x="8">&lt;g8&gt;</bpt>w<ept i="8">&lt;/g8&gt;</ept>를 반환할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Output parameters</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163056Z" creationid="tlqk3" creationdate="20220604T163056Z">
        <seg>출력 매개변수</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Outside the section, the simplifier will no longer use
<bpt i="1" x="1">&lt;g1&gt;</bpt>reverse_mk_symm<ept i="1">&lt;/g1&gt;</ept> by default.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T165457Z" creationid="tlqk35" creationdate="20220524T165457Z">
        <seg>섹션 바깥 쪽에서 단순화기는 기본적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>reverse_mk_symm<ept i="1">&lt;/g1&gt;</ept>을 사용할 수 없게 될 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Parallel
sequencing is one way to arrange it so that a single tactic is applied
to multiple goals, but there are other ways to do this.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T152200Z" creationid="tlqk35" creationdate="20220524T152200Z">
        <seg>병렬은 이를 배열하는 한 방법이므로 하나의 전략이 다수의 목표에 적용될 수 있습니다. 
그러나 이를 할 수 있는 다른 방식들이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern Matching</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160553Z" creationid="tlqk3" creationdate="20220529T160553Z">
        <seg>패턴 매칭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern matching</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183519Z" creationid="tlqk3" creationdate="20220604T183519Z">
        <seg>패턴 매칭</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern matching
provides an approach that is more convenient, and familiar to users of
functional programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161048Z" creationid="tlqk3" creationdate="20220529T161048Z">
        <seg>패턴 매칭은 더 편리한 접근법과 함수형 프로그래밍 언어의 사용자에게 친숙한 접근법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern matching can also be used to destruct inductively defined propositions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161658Z" creationid="tlqk3" creationdate="20220529T161658Z">
        <seg>패턴 매칭은 재귀적으로 정의된 명제를 파괴하는 데에도 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pattern matching works with any inductive type, such as products and option types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161546Z" creationid="tlqk3" creationdate="20220529T161546Z">
        <seg>패턴 매칭은 곱과 옵션 유형 같은 임의의 재귀형과 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Placeholders without precedence default to <bpt i="1" x="1">&lt;g1&gt;</bpt>0<ept i="1">&lt;/g1&gt;</ept>, i.e. they accept notations of any precedence in their place.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123851Z" creationid="tlqk3" creationdate="20220526T123851Z">
        <seg>우선순위가 없는 자리차지자는 <bpt i="1" x="1">&lt;g1&gt;</bpt>0<ept i="1">&lt;/g1&gt;</ept>으로 설정됩니다. 예를 들어 이들은 그들의 자리에 임의의 우선순위의 기호든 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Please see <bpt i="1" x="1">&lt;g1&gt;</bpt>lean prover<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>lean community<ept i="2">&lt;/g2&gt;</ept> for an up to date list
of our amazing contributors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134918Z" creationid="tlqk35" creationdate="20220321T134918Z">
        <seg>합<bpt i="1" x="1">&lt;g1&gt;</bpt>린 증명보조기<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>린 커뮤니티<ept i="2">&lt;/g2&gt;</ept>에서 놀라운 최신 기여자 명단을 확인할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Pretty printing additional information is often very useful
when you are debugging a proof, or trying to understand a cryptic
error message.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130303Z" creationid="tlqk3" creationdate="20220526T130303Z">
        <seg>깔끔한 출력하기의 추가 정보는 증명의 버그를 없앨때나 암호같은 오류 메시지를 이해하려고 할 때 아주 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Printing them out shows that all three groups of definitions have
exactly the same effect.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145220Z" creationid="tlqk35" creationdate="20220321T145220Z">
        <seg>이것을 출력하는 것은 세 정의 그룹이 정확히 동일한 효과를 가짐을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Priorities are also useful to control the interaction between different default instances.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165813Z" creationid="tlqk3" creationdate="20220604T165813Z">
        <seg>우선 순위는 다른 기본 개체들 간의 상호작용을 제어하는 데에도 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositional Logic</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161827Z" creationid="tlqk35" creationdate="20220321T161827Z">
        <seg>명제 논리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositions and Proofs</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154753Z" creationid="tlqk35" creationdate="20220321T154753Z">
        <seg>명제와 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Propositions as Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154815Z" creationid="tlqk35" creationdate="20220321T154815Z">
        <seg>유형으로써 명제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove <bpt i="1" x="1">&lt;g1&gt;</bpt>¬(p ↔ ¬p)<ept i="1">&lt;/g1&gt;</ept> without using classical logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185359Z" creationid="tlqk35" creationdate="20220321T170721Z">
        <seg>고전 논리를 사용하지 않고 <bpt i="1" x="1">&lt;g1&gt;</bpt>¬(p ↔ ¬p)<ept i="1">&lt;/g1&gt;</ept>을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove as many of the identities listed in the Existential
Quantifier section as you can.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184006Z" creationid="tlqk35" creationdate="20220321T184006Z">
        <seg>존재 정량자에서 수록된 항등식을 여러분이 할 수 있는 만큼 가능한 많이 증명해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove some properties, such as the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171355Z" creationid="tlqk35" creationdate="20220528T171355Z">
        <seg>다음과 같은 몇 가지 성질을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove that this is a contradiction:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183839Z" creationid="tlqk35" creationdate="20220321T183839Z">
        <seg>이것이 모순임을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove the following identities, replacing the "sorry" placeholders
with actual proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170704Z" creationid="tlqk35" creationdate="20220321T170704Z">
        <seg>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove the following identities, replacing the "sorry" placeholders with actual proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170611Z" creationid="tlqk35" creationdate="20220321T170611Z">
        <seg>다음 항등식을 증명하세요. "sorry"를 실제 증명으로 대체하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Prove these equivalences:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183748Z" creationid="tlqk35" creationdate="20220321T183748Z">
        <seg>이 등가식들을 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Proving a fact like <bpt i="1" x="1">&lt;g1&gt;</bpt>zero + m = m<ept i="1">&lt;/g1&gt;</ept>, however, requires a proof by induction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160815Z" creationid="tlqk3" creationdate="20220527T160815Z">
        <seg>하지만 <bpt i="1" x="1">&lt;g1&gt;</bpt>zero + m = m<ept i="1">&lt;/g1&gt;</ept>같은 사실을 증명하는 것은 귀납에 의한 증명이 요구됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Quantifiers and Equality</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172532Z" creationid="tlqk35" creationdate="20220321T172532Z">
        <seg>한정기호와 동등성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rather, it is the fact that we can write them
down and check that they are well-typed that ensures that the
proposition in question is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160408Z" creationid="tlqk35" creationdate="20220321T160408Z">
        <seg>그것보다 우리가 표현식을 쓰고 잘 쓰여졌는지 확인할 수 있다는 사실은 의문의 명제가 참인지를 확실히 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Raw natural numbers are <bpt i="1" x="1">&lt;g1&gt;</bpt>not<ept i="1">&lt;/g1&gt;</ept> polymorphic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162858Z" creationid="tlqk3" creationdate="20220604T162858Z">
        <seg>생 자연수는 다형적이지 <bpt i="1" x="1">&lt;g1&gt;</bpt>않습니다.<ept i="1">&lt;/g1&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall also from <bpt i="6" x="6">&lt;g6&gt;</bpt>Dependent Type Theory<ept i="6">&lt;/g6&gt;</ept>
that to give these definitions the greatest generality possible, we allow
the types <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>β<ept i="8">&lt;/g8&gt;</ept> to belong to any universe.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153712Z" creationid="tlqk3" creationdate="20220526T153712Z">
        <seg><bpt i="6" x="6">&lt;g6&gt;</bpt>종속 유형론<ept i="6">&lt;/g6&gt;</ept>으로부터 이들 정의에 가능한 가장 큰 일반성을 준 것을 기억하세요. 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept>형과 <bpt i="8" x="8">&lt;g8&gt;</bpt>β<ept i="8">&lt;/g8&gt;</ept>형이 임의의 세계에 속함을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall from the <bpt i="1" x="1">&lt;g1&gt;</bpt>Conjunction section<ept i="1">&lt;/g1&gt;</ept> if <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>
has type <bpt i="3" x="3">&lt;g3&gt;</bpt>Point<ept i="3">&lt;/g3&gt;</ept>, the expression <bpt i="4" x="4">&lt;g4&gt;</bpt>p.foo<ept i="4">&lt;/g4&gt;</ept> is interpreted as
<bpt i="5" x="5">&lt;g5&gt;</bpt>Point.foo p<ept i="5">&lt;/g5&gt;</ept>, assuming that the first non-implicit argument to
<bpt i="6" x="6">&lt;g6&gt;</bpt>foo<ept i="6">&lt;/g6&gt;</ept> has type <bpt i="7" x="7">&lt;g7&gt;</bpt>Point<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174736Z" creationid="tlqk35" creationdate="20220528T174736Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>결합 섹션(Conjunction section)<ept i="1">&lt;/g1&gt;</ept>에서 <bpt i="6" x="6">&lt;g6&gt;</bpt>foo<ept i="6">&lt;/g6&gt;</ept>에 대한 첫 번째 비암시적인 인수가 <bpt i="7" x="7">&lt;g7&gt;</bpt>Point<ept i="7">&lt;/g7&gt;</ept>형을 갖는다고 가정했을 때 만약 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>가 <bpt i="3" x="3">&lt;g3&gt;</bpt>Point<ept i="3">&lt;/g3&gt;</ept>형이면 표현식 <bpt i="4" x="4">&lt;g4&gt;</bpt>p.foo<ept i="4">&lt;/g4&gt;</ept>는 <bpt i="5" x="5">&lt;g5&gt;</bpt>Point.foo p<ept i="5">&lt;/g5&gt;</ept>으로 해석됨을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that <bpt i="1" x="1">&lt;g1&gt;</bpt>#eval fib &lt;n&gt;<ept i="1">&lt;/g1&gt;</ept> is exponential on <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;n&gt;<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165004Z" creationid="tlqk3" creationdate="20220603T165004Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>#eval fib &lt;n&gt;<ept i="1">&lt;/g1&gt;</ept>가 <bpt i="2" x="2">&lt;g2&gt;</bpt>&lt;n&gt;<ept i="2">&lt;/g2&gt;</ept>에 대해 지수적이었음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that a non-recursive inductive type that contains only one
constructor is called a <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> or <bpt i="2" x="2">&lt;g2&gt;</bpt>record<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152455Z" creationid="tlqk35" creationdate="20220528T172548Z">
        <seg>한 생성자만을 포함한 비 재귀적인 귀납형은 <bpt i="1" x="1">&lt;g1&gt;</bpt>구조체(structure)<ept i="1">&lt;/g1&gt;</ept> 혹은 <bpt i="2" x="2">&lt;g2&gt;</bpt>레코드(record)<ept i="2">&lt;/g2&gt;</ept>라고 불린다는 것을 떠올려보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that terms in the
Calculus of Constructions have a computational interpretation, and
that the logical framework treats terms with a common reduct as the
same.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175635Z" creationid="tlqk35" creationdate="20220321T175635Z">
        <seg>직관주의적 계산법의 항은 계산적인 해석을 갖고 논리 프레임워크는 공통 환원된 항을 같은 것으로 다룬는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that the <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept> keyword provides one important way of declaring new named
objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143839Z" creationid="tlqk35" creationdate="20220321T143839Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept>가 새 이름을 가진 대상을 선언하는 중요한 방식임을 기억하세요.

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that the <bpt i="1" x="1">&lt;g1&gt;</bpt>import<ept i="1">&lt;/g1&gt;</ept>
command at the beginning of a file imports previously compiled results
from other files, and that importing is transitive; if you import
<bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>Foo<ept i="3">&lt;/g3&gt;</ept> imports <bpt i="4" x="4">&lt;g4&gt;</bpt>Bar<ept i="4">&lt;/g4&gt;</ept>, then the definitions and theorems
from <bpt i="5" x="5">&lt;g5&gt;</bpt>Bar<ept i="5">&lt;/g5&gt;</ept> are available to you as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130820Z" creationid="tlqk3" creationdate="20220526T130820Z">
        <seg>파일의 시작에서  <bpt i="1" x="1">&lt;g1&gt;</bpt>import<ept i="1">&lt;/g1&gt;</ept> 명령은 다른 파일로부터 이전에 컴파일된 결과를 불러오고 그 불러오기는 추이적임을 기억하세요. 만약 여러분이 <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept>를 가져오고 <bpt i="3" x="3">&lt;g3&gt;</bpt>Foo<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>Bar<ept i="4">&lt;/g4&gt;</ept>를 가져오면 <bpt i="5" x="5">&lt;g5&gt;</bpt>Bar<ept i="5">&lt;/g5&gt;</ept>에서 이용가능한 정의와 정리도 여러분이 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that types may not have any elements in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155209Z" creationid="tlqk3" creationdate="20220604T155209Z">
        <seg>유형은 린에서 임의의 원소가 아닐 수 있음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that we can also write theorem <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept> as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161408Z" creationid="tlqk35" creationdate="20220321T161408Z">
        <seg>우리는 정리 <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept>을 다음과 같이 쓸 수 있음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall that, in the case of ordinary
function spaces, we could interpret <bpt i="7" x="7">&lt;g7&gt;</bpt>α → β<ept i="7">&lt;/g7&gt;</ept> as the special case of
<bpt i="8" x="8">&lt;g8&gt;</bpt>(x : α) → β<ept i="8">&lt;/g8&gt;</ept> in which <bpt i="9" x="9">&lt;g9&gt;</bpt>β<ept i="9">&lt;/g9&gt;</ept> does not depend on <bpt i="10" x="10">&lt;g10&gt;</bpt>x<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173603Z" creationid="tlqk35" creationdate="20220321T173603Z">
        <seg>평범한 함수공간의 경우에 대해 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>α → β<ept i="7">&lt;/g7&gt;</ept>을 <bpt i="8" x="8">&lt;g8&gt;</bpt>(x : α) → β<ept i="8">&lt;/g8&gt;</ept>의 특별한 경우로 해석할 수 있음을 생각해보세요. 이때  <bpt i="9" x="9">&lt;g9&gt;</bpt>β<ept i="9">&lt;/g9&gt;</ept>는 <bpt i="10" x="10">&lt;g10&gt;</bpt>x<ept i="10">&lt;/g10&gt;</ept>에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall the definition of <bpt i="2" x="2">&lt;g2&gt;</bpt>even<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>odd<ept i="3">&lt;/g3&gt;</ept> as mutual inductive predicates, as presented as an example there:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174449Z" creationid="tlqk3" creationdate="20220603T174449Z">
        <seg> <bpt i="2" x="2">&lt;g2&gt;</bpt>even<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>odd<ept i="3">&lt;/g3&gt;</ept>을 상호적으로 귀납적인 술어의 정의로 호출한다면 다음 예제와 같이 나타날 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recall this tells Lean that
the argument is implicit, and should be filled in automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170438Z" creationid="tlqk35" creationdate="20220321T170438Z">
        <seg>이것이 린에게 인수가 암시적이고 자동적으로 채우게 함을 의미한다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Recursively define a function that evaluates any such term with respect to an assignment of values to the variables.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171517Z" creationid="tlqk35" creationdate="20220528T171517Z">
        <seg>변수에 값을 할당한 것에 대한 항으로 계산하는 재귀적으로 함수를 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Reflexivity is more powerful than it looks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175629Z" creationid="tlqk35" creationdate="20220321T175629Z">
        <seg>대칭성은 보기 보다 더 강력합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember also that in both the VS Code and Emacs editor modes, tab
completion works in <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option<ept i="1">&lt;/g1&gt;</ept>, to help you find suitable options.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181023Z" creationid="tlqk3" creationdate="20220604T181023Z">
        <seg>또한 VS Code 및 Emacs 편집기 모드에서 탭 완성 기능은 <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option<ept i="1">&lt;/g1&gt;</ept>에서 동작하므로 적절한 옵션을 찾는 데 도움이 됨을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that <bpt i="3" x="3">&lt;g3&gt;</bpt>#check<ept i="3">&lt;/g3&gt;</ept>
is often used in conjunction with the <bpt i="4" x="4">&lt;g4&gt;</bpt>@<ept i="4">&lt;/g4&gt;</ept> operator, which makes all
of the arguments to a theorem or definition explicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125324Z" creationid="tlqk3" creationdate="20220526T125324Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>#check<ept i="3">&lt;/g3&gt;</ept>는  <bpt i="4" x="4">&lt;g4&gt;</bpt>@<ept i="4">&lt;/g4&gt;</ept> 연산자와 결합하여 종종 사용됨을 기억하세요. 이는 정리나 정의의 모든 인수를 명시적이게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that <bpt i="8" x="8">&lt;g8&gt;</bpt>→<ept i="8">&lt;/g8&gt;</ept> associates to the right (nothing changes
now that the arguments are elements of <bpt i="9" x="9">&lt;g9&gt;</bpt>Prop<ept i="9">&lt;/g9&gt;</ept>, instead of some other
<bpt i="10" x="10">&lt;g10&gt;</bpt>Type<ept i="10">&lt;/g10&gt;</ept>), as do the other binary connectives.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162316Z" creationid="tlqk35" creationdate="20220321T162316Z">
        <seg>다른 이항 결합자들처럼 <bpt i="8" x="8">&lt;g8&gt;</bpt>→<ept i="8">&lt;/g8&gt;</ept>은 오른쪽으로 결합한다는 것을 기억하세요.(인수가 <bpt i="10" x="10">&lt;g10&gt;</bpt>Type<ept i="10">&lt;/g10&gt;</ept> 대신 <bpt i="9" x="9">&lt;g9&gt;</bpt>Prop<ept i="9">&lt;/g9&gt;</ept>인 것을 제외하고 변한 건 없습니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that expressions which differ up to renaming of bound
variables are considered to be equivalent.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173915Z" creationid="tlqk35" creationdate="20220321T173915Z">
        <seg>표현식들은 구속변수의 이름이 달라지기까지 동등한 것으로 간주된다는 것을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that identifiers in Lean can be organized into hierarchical
namespaces.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132301Z" creationid="tlqk3" creationdate="20220526T132301Z">
        <seg>린의 식별자들은 계층적인 이름공간 안에 정리될 수 있음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that if you <bpt i="1" x="1">&lt;g1&gt;</bpt>open Classical<ept i="1">&lt;/g1&gt;</ept>, you can use the law of the
excluded middle for any proposition at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171445Z" creationid="tlqk3" creationdate="20220527T171445Z">
        <seg>여러분이 <bpt i="1" x="1">&lt;g1&gt;</bpt>open Classical<ept i="1">&lt;/g1&gt;</ept>을 하면 여러분은 임의의 명제에 대해서 배중률을 사용할 수 있음을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that the point of the <bpt i="3" x="3">&lt;g3&gt;</bpt>variable<ept i="3">&lt;/g3&gt;</ept> command is to
declare variables for use in theorems, as in the following example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175057Z" creationid="tlqk35" creationdate="20220524T175057Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>variable<ept i="3">&lt;/g3&gt;</ept> 명령의 요점은 다음 예제에서 처럼 정리에서 사용하기 위한 변수를 선언하는 것임을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that the standard
library defines notation <bpt i="9" x="9">&lt;g9&gt;</bpt>α × β<ept i="9">&lt;/g9&gt;</ept> for <bpt i="10" x="10">&lt;g10&gt;</bpt>Prod α β<ept i="10">&lt;/g10&gt;</ept> and <bpt i="11" x="11">&lt;g11&gt;</bpt>(a, b)<ept i="11">&lt;/g11&gt;</ept> for
<bpt i="12" x="12">&lt;g12&gt;</bpt>Prod.mk a b<ept i="12">&lt;/g12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153401Z" creationid="tlqk3" creationdate="20220526T153401Z">
        <seg>표준 라이브러리는 <bpt i="10" x="10">&lt;g10&gt;</bpt>Prod α β<ept i="10">&lt;/g10&gt;</ept>에 대해 <bpt i="9" x="9">&lt;g9&gt;</bpt>α × β<ept i="9">&lt;/g9&gt;</ept> 표기를 정의하고 <bpt i="12" x="12">&lt;g12&gt;</bpt>Prod.mk a b<ept i="12">&lt;/g12&gt;</ept>에 대해 <bpt i="11" x="11">&lt;g11&gt;</bpt>(a, b)<ept i="11">&lt;/g11&gt;</ept>를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that this type can just as well
be written <bpt i="5" x="5">&lt;g5&gt;</bpt>∀ (p q : Prop) (hp : p) (hq :q), p<ept i="5">&lt;/g5&gt;</ept>, since the arrow
denotes nothing more than an arrow type in which the target does not
depend on the bound variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161645Z" creationid="tlqk35" creationdate="20220321T161645Z">
        <seg>왜냐하면 화살표는 대상이 구속 변수에 의존하지 않는 화살표 유형만을 나타내기 때문에 이 유형은 <bpt i="5" x="5">&lt;g5&gt;</bpt>∀ (p q : Prop) (hp : p) (hq :q), p<ept i="5">&lt;/g5&gt;</ept>로 쓸 수 있게 함을 기억하세요. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember that, without any parameters, an expression of type
<bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept> is just an assertion.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183859Z" creationid="tlqk35" creationdate="20220321T183859Z">
        <seg>어떤 매개변수도 없이 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>형의 표현식은 그저 주장일 뿐이라는 걸 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Remember the introduction and
elimination rules for dependent arrow types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173012Z" creationid="tlqk35" creationdate="20220321T173012Z">
        <seg>의존 화살표 유형에 대한 도입과 소거 규칙을 기억하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Replace calling <bpt i="1" x="1">&lt;g1&gt;</bpt>rustdoc --test<ept i="1">&lt;/g1&gt;</ept> from <bpt i="2" x="2">&lt;g2&gt;</bpt>mdbook test<ept i="2">&lt;/g2&gt;</ept> with <bpt i="3" x="3">&lt;g3&gt;</bpt>./test<ept i="3">&lt;/g3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171930Z" creationid="tlqk35" creationdate="20220321T171930Z">
        <seg> <bpt i="2" x="2">&lt;g2&gt;</bpt>mdbook test<ept i="2">&lt;/g2&gt;</ept>에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>rustdoc --test<ept i="1">&lt;/g1&gt;</ept>을 호출하는 것을 <bpt i="3" x="3">&lt;g3&gt;</bpt>./test<ept i="3">&lt;/g3&gt;</ept>으로 대체함.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Resolution theorem provers, tableau theorem provers, fast
satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and
first-order logic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131315Z" creationid="tlqk35" creationdate="20220321T131315Z">
        <seg>Resolution 증명 보조기, tableau 증명 보조기, fast satisfiability 솔버 등등은 명제 논리식와 1계 논리식의 유효성을 식별하는 세우는 수단을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returning to the example of lists, you can use the command <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> to
inspect the type of the following <bpt i="2" x="2">&lt;g2&gt;</bpt>List<ept i="2">&lt;/g2&gt;</ept> functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152114Z" creationid="tlqk35" creationdate="20220321T152114Z">
        <seg>리스트의 예로 돌아가서 여러분은 다음 <bpt i="2" x="2">&lt;g2&gt;</bpt>List<ept i="2">&lt;/g2&gt;</ept> 함수의 유형을 검사하기 위해 <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> 명령을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Returning to the previous example and
renaming bound variables for clarity, notice the types of the
following expressions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143523Z" creationid="tlqk35" creationdate="20220321T143523Z">
        <seg>이전 예제로 돌아가 명확성을 위해 구속변수의 이름을 바꿉시다. 다음 표현식의 유형을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rewrites can be applied sequentially, so that the proof above can be
shortened to this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180445Z" creationid="tlqk35" creationdate="20220321T180445Z">
        <seg>다시쓰기는 연속적으로 쓸 수 있습니다. 따라서 위의 증명은 이와 같이 더 짧아질 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Rewriting</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T160714Z" creationid="tlqk35" creationdate="20220524T160714Z">
        <seg>다시쓰기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Roughly
speaking, what characterizes inductive types in <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept> is that one
can only eliminate to other types in <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152059Z" creationid="tlqk3" creationdate="20220527T152242Z">
        <seg>대략적으로 말하면, <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>에서 귀납형을 특징짓는 것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>의 다른 유형으로만 제거할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Roughly speaking, an element of <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept> is said to be
decidable if we can decide whether it is true or false.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171347Z" creationid="tlqk3" creationdate="20220604T171347Z">
        <seg>대략적으로 말하면 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prop<ept i="2">&lt;/g2&gt;</ept>의 원소는 그것이 참인지 거짓인지 결정할 수 있다면 결정 가능하다고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Roughly speaking, each <bpt i="3" x="3">&lt;g3&gt;</bpt>...<ept i="3">&lt;/g3&gt;</ept> can be any arrow type constructed from
<bpt i="4" x="4">&lt;g4&gt;</bpt>Foo<ept i="4">&lt;/g4&gt;</ept> and previously defined types, in which <bpt i="5" x="5">&lt;g5&gt;</bpt>Foo<ept i="5">&lt;/g5&gt;</ept> appears, if at
all, only as the "target" of the dependent arrow type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T143906Z" creationid="tlqk3" creationdate="20220526T143559Z">
        <seg>대략적으로 말하자면 각 <bpt i="3" x="3">&lt;g3&gt;</bpt>...<ept i="3">&lt;/g3&gt;</ept>는 의존 화살표 형의 "대상"으로만 <bpt i="4" x="4">&lt;g4&gt;</bpt>Foo<ept i="4">&lt;/g4&gt;</ept>및 이전에 정의된 유형으로 구성된 모든 화살표 유형이 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Roughly speaking, since we know there is an <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept> satisfying
<bpt i="9" x="9">&lt;g9&gt;</bpt>p x<ept i="9">&lt;/g9&gt;</ept>, we can give it a name, say, <bpt i="10" x="10">&lt;g10&gt;</bpt>w<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181317Z" creationid="tlqk35" creationdate="20220321T181317Z">
        <seg>대략 말하자면 <bpt i="9" x="9">&lt;g9&gt;</bpt>p x<ept i="9">&lt;/g9&gt;</ept>를 만족하는 <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>가 있다는 것을 알기 때문에 이것에 <bpt i="10" x="10">&lt;g10&gt;</bpt>w<ept i="10">&lt;/g10&gt;</ept>라는 이름을 줄 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Roughly, an element of <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited α<ept i="3">&lt;/g3&gt;</ept> is a witness to the fact
that there is an element of <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>; in the <bpt i="5" x="5">&lt;g5&gt;</bpt>Chapter Type Classes<ept i="5">&lt;/g5&gt;</ept>
we will see that Lean can be instructed that suitable
base types are inhabited, and can automatically infer that other
constructed types are inhabited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165706Z" creationid="tlqk3" creationdate="20220529T165706Z">
        <seg>대략적으로 <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited α<ept i="3">&lt;/g3&gt;</ept>의 원소는 <bpt i="4" x="4">&lt;g4&gt;</bpt>α<ept i="4">&lt;/g4&gt;</ept>의 원소가 있다는 사실의 목격자입니다. <bpt i="5" x="5">&lt;g5&gt;</bpt>유형 클래스 장<ept i="5">&lt;/g5&gt;</ept>에서 우리는 린이 적절한 기반 유형이 머물러 있고, 자동적으로 다른 생성 유형이 머물러 있는지 추론하는 것을 배울 수 있음을 볼 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Run <bpt i="1" x="1">&lt;g1&gt;</bpt>mdbook test<ept i="1">&lt;/g1&gt;</ept> to test all <bpt i="2" x="2">&lt;g2&gt;</bpt>lean<ept i="2">&lt;/g2&gt;</ept> code blocks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172249Z" creationid="tlqk35" creationdate="20220321T172249Z">
        <seg>모든  <bpt i="2" x="2">&lt;g2&gt;</bpt>lean<ept i="2">&lt;/g2&gt;</ept>의 코드 블록을 테스트하려면 <bpt i="1" x="1">&lt;g1&gt;</bpt>mdbook test<ept i="1">&lt;/g1&gt;</ept>을 실행하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Scoped Instances</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170657Z" creationid="tlqk3" creationdate="20220604T170657Z">
        <seg>범위가 지정된 개체</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Second, when writing type expressions, arrows associate to the <bpt i="5" x="5">&lt;g5&gt;</bpt>right<ept i="5">&lt;/g5&gt;</ept>; for
example, the type of <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat.add<ept i="6">&lt;/g6&gt;</ept> is <bpt i="7" x="7">&lt;g7&gt;</bpt>Nat → Nat → Nat<ept i="7">&lt;/g7&gt;</ept> which is equivalent
to <bpt i="8" x="8">&lt;g8&gt;</bpt>Nat → (Nat → Nat)<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140808Z" creationid="tlqk35" creationdate="20220321T140808Z">
        <seg>둘째로 유형 표현식을 쓸 때 화살표는<bpt i="5" x="5">&lt;g5&gt;</bpt>오른쪽<ept i="5">&lt;/g5&gt;</ept> 먼저 결합합니다. 가령<bpt i="6" x="6">&lt;g6&gt;</bpt>Nat.add<ept i="6">&lt;/g6&gt;</ept>의 유형은 <bpt i="7" x="7">&lt;g7&gt;</bpt>Nat → Nat → Nat<ept i="7">&lt;/g7&gt;</ept>이고 이는 <bpt i="8" x="8">&lt;g8&gt;</bpt>Nat → (Nat → Nat)<ept i="8">&lt;/g8&gt;</ept>과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sections are also useful for delimiting the scope of
commands such as <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>open<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150626Z" creationid="tlqk35" creationdate="20220321T150626Z">
        <seg>section은 <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>open<ept i="2">&lt;/g2&gt;</ept>같이 명령의 범위를 제한하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sections can also be nested,
which allows you to declare new variables incrementally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150155Z" creationid="tlqk35" creationdate="20220321T150155Z">
        <seg>section은 중첩될 수도 있습니다. 이는 여러분에게 새로운 변수를 점진적으로 선언할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>See the <bpt i="1" x="1">&lt;g1&gt;</bpt>Setting
Up Lean section<ept i="1">&lt;/g1&gt;</ept> of
the <bpt i="2" x="2">&lt;g2&gt;</bpt>Lean 4 Manual<ept i="2">&lt;/g2&gt;</ept> to install Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171440Z" creationid="tlqk35" creationdate="20220321T171440Z">
        <seg>Lean을 설치하려면 <bpt i="2" x="2">&lt;g2&gt;</bpt>Lean 4 Manual<ept i="2">&lt;/g2&gt;</ept>의  <bpt i="1" x="1">&lt;g1&gt;</bpt>Setting Up Lean section<ept i="1">&lt;/g1&gt;</ept>을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Setting Options</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125530Z" creationid="tlqk3" creationdate="20220526T125530Z">
        <seg>옵션 설정하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly,
<bpt i="8" x="8">&lt;g8&gt;</bpt>Iff.mpr h<ept i="8">&lt;/g8&gt;</ept> produces a proof of <bpt i="9" x="9">&lt;g9&gt;</bpt>q → p<ept i="9">&lt;/g9&gt;</ept> from <bpt i="10" x="10">&lt;g10&gt;</bpt>h : p ↔ q<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164748Z" creationid="tlqk35" creationdate="20220321T164748Z">
        <seg>마찬가지로 <bpt i="8" x="8">&lt;g8&gt;</bpt>Iff.mpr h<ept i="8">&lt;/g8&gt;</ept>는 <bpt i="10" x="10">&lt;g10&gt;</bpt>h : p ↔ q<ept i="10">&lt;/g10&gt;</ept>으로부터 <bpt i="9" x="9">&lt;g9&gt;</bpt>q → p<ept i="9">&lt;/g9&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, <bpt i="4" x="4">&lt;g4&gt;</bpt>And.right h<ept i="4">&lt;/g4&gt;</ept> is a proof of <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162807Z" creationid="tlqk35" creationdate="20220321T162807Z">
        <seg>마찬가지로 <bpt i="4" x="4">&lt;g4&gt;</bpt>And.right h<ept i="4">&lt;/g4&gt;</ept>는 <bpt i="5" x="5">&lt;g5&gt;</bpt>q<ept i="5">&lt;/g5&gt;</ept>의 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, <bpt i="4" x="4">&lt;g4&gt;</bpt>Or.intro_right p hq<ept i="4">&lt;/g4&gt;</ept> creates a
proof for <bpt i="5" x="5">&lt;g5&gt;</bpt>p ∨ q<ept i="5">&lt;/g5&gt;</ept> using a proof <bpt i="6" x="6">&lt;g6&gt;</bpt>hq : q<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163629Z" creationid="tlqk35" creationdate="20220321T163629Z">
        <seg>마찬가지로 <bpt i="4" x="4">&lt;g4&gt;</bpt>Or.intro_right p hq<ept i="4">&lt;/g4&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>hq : q<ept i="6">&lt;/g6&gt;</ept>의 증명을 사용하여 <bpt i="5" x="5">&lt;g5&gt;</bpt>p ∨ q<ept i="5">&lt;/g5&gt;</ept> 의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, Lean detects the occurrence of <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept> in
<bpt i="4" x="4">&lt;g4&gt;</bpt>t1<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>t2<ept i="5">&lt;/g5&gt;</ept>, and inserts it automatically there, too.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175253Z" creationid="tlqk35" creationdate="20220524T175253Z">
        <seg>마찬가지로 린은 <bpt i="4" x="4">&lt;g4&gt;</bpt>t1<ept i="4">&lt;/g4&gt;</ept>와 <bpt i="5" x="5">&lt;g5&gt;</bpt>t2<ept i="5">&lt;/g5&gt;</ept>에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept>의 나타남을 감지하고 
거기에도 자동적으로 그것을 삽입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, an object <bpt i="9" x="9">&lt;g9&gt;</bpt>r : α → α → Prop<ept i="9">&lt;/g9&gt;</ept> denotes a binary
relation on <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>: given <bpt i="11" x="11">&lt;g11&gt;</bpt>x y : α<ept i="11">&lt;/g11&gt;</ept>, <bpt i="12" x="12">&lt;g12&gt;</bpt>r x y<ept i="12">&lt;/g12&gt;</ept> denotes the assertion
that <bpt i="13" x="13">&lt;g13&gt;</bpt>x<ept i="13">&lt;/g13&gt;</ept> is related to <bpt i="14" x="14">&lt;g14&gt;</bpt>y<ept i="14">&lt;/g14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172813Z" creationid="tlqk35" creationdate="20220321T172813Z">
        <seg>마찬가지로 대상 <bpt i="9" x="9">&lt;g9&gt;</bpt>r : α → α → Prop<ept i="9">&lt;/g9&gt;</ept>은 <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>에 대한 이항 관계 즉, <bpt i="11" x="11">&lt;g11&gt;</bpt>x y : α<ept i="11">&lt;/g11&gt;</ept>이 주어진다면 , <bpt i="12" x="12">&lt;g12&gt;</bpt>r x y<ept i="12">&lt;/g12&gt;</ept>은 <bpt i="13" x="13">&lt;g13&gt;</bpt>x<ept i="13">&lt;/g13&gt;</ept>가 <bpt i="14" x="14">&lt;g14&gt;</bpt>y<ept i="14">&lt;/g14&gt;</ept>에 연관된다는 주장을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, define the type of propositional formulas, as well as
functions on the type of such formulas: an evaluation function,
functions that measure the complexity of a formula, and a function
that substitutes another formula for a given variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T172021Z" creationid="tlqk35" creationdate="20220528T172021Z">
        <seg>비슷하게 계산 함수와 공식의 복잡도를 측정하는 함수 및 제시한 변수로 다른 식에 대입하는 함수와 마찬가지인 명제 논리식의 유형을 정의하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, if you use an <bpt i="4" x="4">&lt;g4&gt;</bpt>open<ept i="4">&lt;/g4&gt;</ept> command within a
namespace, its effects disappear when the namespace is closed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150742Z" creationid="tlqk35" creationdate="20220321T150742Z">
        <seg>마찬가지로 여러분이 이름공간 내에서 <bpt i="4" x="4">&lt;g4&gt;</bpt>open<ept i="4">&lt;/g4&gt;</ept> 명령을 사용한다면 그것의 효과는 이름공간이 닫힐 때 사라질 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, many theorems hold under the additional assumption that a type is not empty.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155540Z" creationid="tlqk3" creationdate="20220604T155540Z">
        <seg>마찬가지로 많은 정리는 유형이 비어 있지 않을 때 덧셈 가정에  대해서 성립합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, methods of <bpt i="2" x="2">&lt;g2&gt;</bpt>elaboration<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>type inference<ept i="3">&lt;/g3&gt;</ept>, which can be used to support
flexible forms of algebraic reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134656Z" creationid="tlqk35" creationdate="20220321T134656Z">
        <seg>비슷하게 대수 추론의 유연한 형태를 지원하는데 사용될 수 있는 <bpt i="2" x="2">&lt;g2&gt;</bpt>협력법<ept i="2">&lt;/g2&gt;</ept>과  <bpt i="3" x="3">&lt;g3&gt;</bpt>유형 추론<ept i="3">&lt;/g3&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, most identities can be proved by introducing suitable <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>, and then using <bpt i="2" x="2">&lt;g2&gt;</bpt>rfl<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152626Z" creationid="tlqk3" creationdate="20220526T152554Z">
        <seg>마찬가지로 대부분의 항등식들은 적절한 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>와 그 뒤 <bpt i="2" x="2">&lt;g2&gt;</bpt>rfl<ept i="2">&lt;/g2&gt;</ept>를 쓰는 것으로 증명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, see if you can figure out how to
define <bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept> on your own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181426Z" creationid="tlqk3" creationdate="20220603T181426Z">
        <seg>마찬가지로 여러분은 여러분 스스로 <bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept>을 정의하는 법을 알아낼 수 있는지 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, the
expression <bpt i="5" x="5">&lt;g5&gt;</bpt>hnp hp<ept i="5">&lt;/g5&gt;</ept> produces a proof of <bpt i="6" x="6">&lt;g6&gt;</bpt>False<ept i="6">&lt;/g6&gt;</ept> from <bpt i="7" x="7">&lt;g7&gt;</bpt>hp : p<ept i="7">&lt;/g7&gt;</ept>
and <bpt i="8" x="8">&lt;g8&gt;</bpt>hnp : ¬p<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164250Z" creationid="tlqk35" creationdate="20220321T164250Z">
        <seg>마찬가지로 표현식 <bpt i="5" x="5">&lt;g5&gt;</bpt>hnp hp<ept i="5">&lt;/g5&gt;</ept>은 <bpt i="7" x="7">&lt;g7&gt;</bpt>hp : p<ept i="7">&lt;/g7&gt;</ept>과 <bpt i="8" x="8">&lt;g8&gt;</bpt>hnp : ¬p<ept i="8">&lt;/g8&gt;</ept>으로부터 <bpt i="6" x="6">&lt;g6&gt;</bpt>False<ept i="6">&lt;/g6&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, two dashes <bpt i="3" x="3">&lt;g3&gt;</bpt>--<ept i="3">&lt;/g3&gt;</ept> indicate that the rest of
the line contains a comment that is also ignored.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135543Z" creationid="tlqk35" creationdate="20220321T135543Z">
        <seg>마찬가지로 두 개의 대시 <bpt i="3" x="3">&lt;g3&gt;</bpt>--<ept i="3">&lt;/g3&gt;</ept>는 이 줄의 나머지는 주석을 포함함을 나타내고 이 또한 무시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, use the equation compiler to define some basic
operations on lists (like the <bpt i="1" x="1">&lt;g1&gt;</bpt>reverse<ept i="1">&lt;/g1&gt;</ept> function) and prove
theorems about lists by induction (such as the fact that
<bpt i="2" x="2">&lt;g2&gt;</bpt>reverse (reverse xs) = xs<ept i="2">&lt;/g2&gt;</ept> for any list <bpt i="3" x="3">&lt;g3&gt;</bpt>xs<ept i="3">&lt;/g3&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181206Z" creationid="tlqk3" creationdate="20220603T181206Z">
        <seg>마찬가지로 방정식 컴파일러를 리스트에 대한 몇 가지 기본 연산(<bpt i="1" x="1">&lt;g1&gt;</bpt>reverse<ept i="1">&lt;/g1&gt;</ept> 함수 같은)을 정의하는데 사용하세요. 그리고 귀납법으로 리스트에 대한 정리(임의의 리스트 <bpt i="3" x="3">&lt;g3&gt;</bpt>xs<ept i="3">&lt;/g3&gt;</ept>에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse (reverse xs) = xs<ept i="2">&lt;/g2&gt;</ept>이라는 사실 같은 것)를 증명하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, we
can think of an implication <bpt i="11" x="11">&lt;g11&gt;</bpt>p → q<ept i="11">&lt;/g11&gt;</ept> between propositions as the
special case of <bpt i="12" x="12">&lt;g12&gt;</bpt>∀ x : p, q<ept i="12">&lt;/g12&gt;</ept> in which the expression <bpt i="13" x="13">&lt;g13&gt;</bpt>q<ept i="13">&lt;/g13&gt;</ept> does not
depend on <bpt i="14" x="14">&lt;g14&gt;</bpt>x<ept i="14">&lt;/g14&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173633Z" creationid="tlqk35" creationdate="20220321T173633Z">
        <seg>마찬가지로 우리는 명제들 사이의 함의 <bpt i="11" x="11">&lt;g11&gt;</bpt>p → q<ept i="11">&lt;/g11&gt;</ept>를 <bpt i="12" x="12">&lt;g12&gt;</bpt>∀ x : p, q<ept i="12">&lt;/g12&gt;</ept>의 특별한 경우로써 생각할 수 있습니다. 이때 <bpt i="13" x="13">&lt;g13&gt;</bpt>q<ept i="13">&lt;/g13&gt;</ept>는 <bpt i="14" x="14">&lt;g14&gt;</bpt>x<ept i="14">&lt;/g14&gt;</ept>에 의존하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, we can inhabit type function with suitable constant functions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161529Z" creationid="tlqk3" creationdate="20220604T161529Z">
        <seg>마찬가지로 우리는 유형 함수를 적절한 상수 함수로 내재시킬 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Similarly, we can register an instance by</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154431Z" creationid="tlqk3" creationdate="20220604T154431Z">
        <seg>마찬가지로 우리는 개체를 다음과 같이 등록할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Simple Type Theory</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135147Z" creationid="tlqk35" creationdate="20220321T135147Z">
        <seg>단순 유형론(Simple Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since addition is defined by recursion on the second argument,
<bpt i="5" x="5">&lt;g5&gt;</bpt>k<ept i="5">&lt;/g5&gt;</ept> is a good guess, and once we make that choice the proof almost writes itself:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162213Z" creationid="tlqk3" creationdate="20220527T162213Z">
        <seg>덧셈은 두 번째 인수에 대해 재귀적으로 정의되어 있기 때문에 <bpt i="5" x="5">&lt;g5&gt;</bpt>k<ept i="5">&lt;/g5&gt;</ept>는 좋은 추측입니다. 그리고 한번 우리가 그 선택을 하면 증명은 거의 술술 써집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since an inductive type lives in <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort u<ept i="1">&lt;/g1&gt;</ept> for some <bpt i="2" x="2">&lt;g2&gt;</bpt>u<ept i="2">&lt;/g2&gt;</ept>, it is
reasonable to ask <bpt i="3" x="3">&lt;g3&gt;</bpt>which<ept i="3">&lt;/g3&gt;</ept> universe levels <bpt i="4" x="4">&lt;g4&gt;</bpt>u<ept i="4">&lt;/g4&gt;</ept> can be instantiated
to.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152221Z" creationid="tlqk35" creationdate="20220528T160840Z">
        <seg>귀납형이 어떤 <bpt i="2" x="2">&lt;g2&gt;</bpt>u<ept i="2">&lt;/g2&gt;</ept>에 대해 <bpt i="1" x="1">&lt;g1&gt;</bpt>Sort u<ept i="1">&lt;/g1&gt;</ept>에 속해 있기 때문에, <bpt i="3" x="3">&lt;g3&gt;</bpt>어느<ept i="3">&lt;/g3&gt;</ept>세계의 수준에 <bpt i="4" x="4">&lt;g4&gt;</bpt>u<ept i="4">&lt;/g4&gt;</ept>가 개체화 될 수 있는지 묻는 것은 합리적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since many of these are already defined in Lean's core library, you
should work within a namespace named <bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept>, or something like
that, in order to avoid name clashes.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171252Z" creationid="tlqk35" creationdate="20220528T171252Z">
        <seg>이미 이들 중 다수가 이미 린의 중앙 라이브러리에 정의되어 있기에 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Hidden<ept i="1">&lt;/g1&gt;</ept> 혹은 이름 충돌을 피할 수 있는 것으로 이름지은 이름공간에서 작업해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Since the values of <bpt i="1" x="1">&lt;g1&gt;</bpt>m<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>n<ept i="2">&lt;/g2&gt;</ept> are not needed, we can just as well use wildcard patterns instead.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165005Z" creationid="tlqk3" creationdate="20220529T165005Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>m<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>n<ept i="2">&lt;/g2&gt;</ept>의 값은 필요하지 않으므로 우리는 와일드카드 패턴을 대신 사용하여도 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Singleton elimination is also used with
heterogeneous equality and well-founded recursion, which will be
discussed in a later chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T164330Z" creationid="tlqk35" creationdate="20220528T164330Z">
        <seg>한 번에 하나씩 제거는 동일하지 않은 동등석과 잘 세워진 제귀에도 사용됩니다. 이것은 이후에 논의할 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So
the expressions in the first two <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> commands below are
elaborated in the same way, whereas the third <bpt i="2" x="2">&lt;g2&gt;</bpt>#check<ept i="2">&lt;/g2&gt;</ept> command
interprets <bpt i="3" x="3">&lt;g3&gt;</bpt>2<ept i="3">&lt;/g3&gt;</ept> as an integer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153707Z" creationid="tlqk35" creationdate="20220321T153707Z">
        <seg>그래서 아래 첫 두 <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept>명령에서 표현식은 같은 방식으로 해석됩니다. 반면 세 번째 <bpt i="2" x="2">&lt;g2&gt;</bpt>#check<ept i="2">&lt;/g2&gt;</ept> 명령은 <bpt i="3" x="3">&lt;g3&gt;</bpt>2<ept i="3">&lt;/g3&gt;</ept>를 정수로 해석합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So <bpt i="2" x="2">&lt;g2&gt;</bpt>def<ept i="2">&lt;/g2&gt;</ept> can also be used to simply name a value like this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144224Z" creationid="tlqk35" creationdate="20220321T144224Z">
        <seg>그래서 <bpt i="2" x="2">&lt;g2&gt;</bpt>def<ept i="2">&lt;/g2&gt;</ept>는 이 같은 값을 단순히 이름으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So constructing an
element <bpt i="8" x="8">&lt;g8&gt;</bpt>t : p<ept i="8">&lt;/g8&gt;</ept> tells us that <bpt i="9" x="9">&lt;g9&gt;</bpt>p<ept i="9">&lt;/g9&gt;</ept> is indeed true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160102Z" creationid="tlqk35" creationdate="20220321T160102Z">
        <seg>그러므로 원소 <bpt i="8" x="8">&lt;g8&gt;</bpt>t : p<ept i="8">&lt;/g8&gt;</ept>을 생성하는 것은 <bpt i="9" x="9">&lt;g9&gt;</bpt>p<ept i="9">&lt;/g9&gt;</ept>가 사실이라고 우리에게 알립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So far, you have seen that Lean allows you to
introduce inductive types with any number of recursive
constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T152303Z" creationid="tlqk35" creationdate="20220528T152303Z">
        <seg>지금까지 여러분은 린이 여러분에게 재귀적인 생성자에 대한 임의의 수로 유도형을 도입하게 해줌을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So if we have
<bpt i="11" x="11">&lt;g11&gt;</bpt>p q r : Prop<ept i="11">&lt;/g11&gt;</ept>, the expression <bpt i="12" x="12">&lt;g12&gt;</bpt>p → q → r<ept i="12">&lt;/g12&gt;</ept> reads "if <bpt i="13" x="13">&lt;g13&gt;</bpt>p<ept i="13">&lt;/g13&gt;</ept>, then if <bpt i="14" x="14">&lt;g14&gt;</bpt>q<ept i="14">&lt;/g14&gt;</ept>,
then <bpt i="15" x="15">&lt;g15&gt;</bpt>r<ept i="15">&lt;/g15&gt;</ept>." This is just the "curried" form of <bpt i="16" x="16">&lt;g16&gt;</bpt>p ∧ q → r<ept i="16">&lt;/g16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162407Z" creationid="tlqk35" creationdate="20220321T162407Z">
        <seg>그래서 만약 <bpt i="11" x="11">&lt;g11&gt;</bpt>p q r : Prop<ept i="11">&lt;/g11&gt;</ept>이 있다면 표현식 <bpt i="12" x="12">&lt;g12&gt;</bpt>p → q → r<ept i="12">&lt;/g12&gt;</ept>은 "<bpt i="13" x="13">&lt;g13&gt;</bpt>p<ept i="13">&lt;/g13&gt;</ept>이면 그러면<bpt i="14" x="14">&lt;g14&gt;</bpt>q<ept i="14">&lt;/g14&gt;</ept>이면<bpt i="15" x="15">&lt;g15&gt;</bpt>r<ept i="15">&lt;/g15&gt;</ept>이다."로 읽습니다. 이는 <bpt i="16" x="16">&lt;g16&gt;</bpt>p ∧ q → r<ept i="16">&lt;/g16&gt;</ept>의 "커리된(curried)" 형태일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So it makes sense to take the type to be the first argument to
<bpt i="8" x="8">&lt;g8&gt;</bpt>cons<ept i="8">&lt;/g8&gt;</ept>, so that for any type, <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept>, <bpt i="10" x="10">&lt;g10&gt;</bpt>cons α<ept i="10">&lt;/g10&gt;</ept> is the insertion
function for lists of type <bpt i="11" x="11">&lt;g11&gt;</bpt>α<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151156Z" creationid="tlqk35" creationdate="20220321T151156Z">
        <seg>그래서 <bpt i="8" x="8">&lt;g8&gt;</bpt>cons<ept i="8">&lt;/g8&gt;</ept>의 첫번째 인수의 유형으로 임의의 유형 <bpt i="9" x="9">&lt;g9&gt;</bpt>α<ept i="9">&lt;/g9&gt;</ept>를 받아들이게 하는게 타당합니다. <bpt i="10" x="10">&lt;g10&gt;</bpt>cons α<ept i="10">&lt;/g10&gt;</ept>는 <bpt i="11" x="11">&lt;g11&gt;</bpt>α<ept i="11">&lt;/g11&gt;</ept>유형을 원소로 하는 리스트에 대한 삽입 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, for example, we could
have used the same variable, <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept>, in both the hypothesis and
conclusion, and instantiated it by a different variable, <bpt i="2" x="2">&lt;g2&gt;</bpt>z<ept i="2">&lt;/g2&gt;</ept>, in the
proof:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173933Z" creationid="tlqk35" creationdate="20220321T173933Z">
        <seg>그럼 예를들어 우리가 같은 변수 <bpt i="1" x="1">&lt;g1&gt;</bpt>x<ept i="1">&lt;/g1&gt;</ept> 가정과 결론 양쪽에 사용할 수 있어야 합니다. 그리고 증명에서 다른 변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>z<ept i="2">&lt;/g2&gt;</ept>에 의해 이것이 개체화됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, for example, you
can write <bpt i="8" x="8">&lt;g8&gt;</bpt>fun x =&gt; g (f x)<ept i="8">&lt;/g8&gt;</ept> instead of <bpt i="9" x="9">&lt;g9&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143113Z" creationid="tlqk35" creationdate="20220321T143113Z">
        <seg>그래서 여러분은 <bpt i="8" x="8">&lt;g8&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="8">&lt;/g8&gt;</ept>대신에 <bpt i="9" x="9">&lt;g9&gt;</bpt>fun x =&gt; g (f x)<ept i="9">&lt;/g9&gt;</ept>와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, if <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>
ordinarily only effects the current goal, <bpt i="4" x="4">&lt;g4&gt;</bpt>focus (all_goals t)<ept i="4">&lt;/g4&gt;</ept> has
the same effect as <bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T153117Z" creationid="tlqk35" creationdate="20220524T153117Z">
        <seg>그래서 만약 <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>이 똑같이 현재 목표에만 영향을 미친다면 
<bpt i="4" x="4">&lt;g4&gt;</bpt>focus (all_goals t)<ept i="4">&lt;/g4&gt;</ept>은 <bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept>와 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>So, you can define instances for particular numerals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162934Z" creationid="tlqk3" creationdate="20220604T162934Z">
        <seg>그래서 여러분은 특정 수치에 대해 개체를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some additional tactics are useful for constructing and destructing
propositions and data.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070154Z" creationid="tlqk35" creationdate="20220522T070154Z">
        <seg>몇 가지 추가적인 전략들은 명제와 데이터를 생성하고 파괴하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some functional programming languages support <bpt i="1" x="1">&lt;g1&gt;</bpt>incomplete
patterns<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165238Z" creationid="tlqk3" creationdate="20220529T165238Z">
        <seg>어떤 함수형 프로그래밍 언어는 <bpt i="1" x="1">&lt;g1&gt;</bpt>불완전한 패턴<ept i="1">&lt;/g1&gt;</ept> 기능을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some mathematically common examples of operations of functions can be
described in terms of lambda abstraction:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142622Z" creationid="tlqk35" creationdate="20220321T142622Z">
        <seg>수학적으로 흔한 함수 연산 예제는 람다 추상화에 대한 것으로 설명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some operations, however, need to be <bpt i="1" x="1">&lt;g1&gt;</bpt>polymorphic<ept i="1">&lt;/g1&gt;</ept> over type
universes.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141814Z" creationid="tlqk35" creationdate="20220321T141814Z">
        <seg>그러나 몇몇 연산은 유형 세계에 대해 <bpt i="1" x="1">&lt;g1&gt;</bpt>다형적(polymorphic)<ept i="1">&lt;/g1&gt;</ept>일 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Some simplifications are possible, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155224Z" creationid="tlqk35" creationdate="20220321T155224Z">
        <seg>하지만 몇 가지 단순화는 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Something funny
is going on: if <bpt i="2" x="2">&lt;g2&gt;</bpt>v<ept i="2">&lt;/g2&gt;</ept> has type <bpt i="3" x="3">&lt;g3&gt;</bpt>Vector α (succ n)<ept i="3">&lt;/g3&gt;</ept>, it <bpt i="4" x="4">&lt;g4&gt;</bpt>can't<ept i="4">&lt;/g4&gt;</ept> be
nil, but it is not clear how to tell that to <bpt i="5" x="5">&lt;g5&gt;</bpt>casesOn<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180106Z" creationid="tlqk3" creationdate="20220603T180106Z">
        <seg>무언가 재밌는 일이 일어나고 있습니다. 만약  <bpt i="2" x="2">&lt;g2&gt;</bpt>v<ept i="2">&lt;/g2&gt;</ept>가 <bpt i="3" x="3">&lt;g3&gt;</bpt>Vector α (succ n)<ept i="3">&lt;/g3&gt;</ept>형이고 그것은 nil일 <bpt i="4" x="4">&lt;g4&gt;</bpt>일 수 없습니다.<ept i="4">&lt;/g4&gt;</ept> 그러나 <bpt i="5" x="5">&lt;g5&gt;</bpt>casesOn<ept i="5">&lt;/g5&gt;</ept>에 대해 구별하는 법이 명확하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes Lean can't find an instance because the class is buried
under a definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180121Z" creationid="tlqk3" creationdate="20220604T180121Z">
        <seg>때때로 린은 클래스가 정의에 묻혀 있어 개채를 찾지 못할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes an argument in a dependent matching pattern is not essential
to the definition, but nonetheless has to be included to specialize
the type of the expression appropriately.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143611Z" creationid="tlqk3" creationdate="20220604T143611Z">
        <seg>떄때로 종속 매칭 패턴에서 인수는 정의에 반드시 필요하지 않습니다. 그럼에도 표현식의 유형을 적절하게 특수화하는데 포함될 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes the left-hand side of an identity can match more than one
subterm in the pattern, in which case the <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> tactic chooses the
first match it finds when traversing the term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172011Z" creationid="tlqk35" creationdate="20220524T155343Z">
        <seg>때때로 항등식의 좌변은 패턴의 한개 이상의 부분항과 동일할 수 있습니다. 
그 경우 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> 전략은 항들을 가로지면서 처음 일치하는 것을 찾고 선택합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes, however, it is useful to limit
the scope of a variable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150032Z" creationid="tlqk35" creationdate="20220321T150032Z">
        <seg>그러나 때때로 변수의 범위를 제한하는 것이 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153716Z" creationid="tlqk35" creationdate="20220321T153716Z">
        <seg>하지만 때때로 우리는 우리 스스로 함수에 대한 인수가 암시적이도록 선언하는 걸 발견합니다. 그러나 지금 인수를 명시적으로 제공하길 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Special modes in Visual Studio Code (VS Code for short) and
Emacs offer powerful support for writing and debugging proofs, and is much better suited for serious use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131922Z" creationid="tlqk35" creationdate="20220321T131922Z">
        <seg>비주얼 스튜디오 코드(짧게는 VS code)에서 특정 모드와 Emacs는 강력한 편집 기능과 증명 디버깅 기능을 지원합니다. 그리고 진지한 사용을 생각한다면 이게 훨씬 적합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Specifically,
<bpt i="3" x="3">&lt;g3&gt;</bpt>congrArg<ept i="3">&lt;/g3&gt;</ept> can be used to replace the argument, <bpt i="4" x="4">&lt;g4&gt;</bpt>congrFun<ept i="4">&lt;/g4&gt;</ept> can be
used to replace the term that is being applied, and <bpt i="5" x="5">&lt;g5&gt;</bpt>congr<ept i="5">&lt;/g5&gt;</ept> can be
used to replace both at once.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175909Z" creationid="tlqk35" creationdate="20220321T175909Z">
        <seg>구체적으로 <bpt i="3" x="3">&lt;g3&gt;</bpt>congrArg<ept i="3">&lt;/g3&gt;</ept>은 인수를 대체하는데 사용될 수 있습니다. <bpt i="4" x="4">&lt;g4&gt;</bpt>congrFun<ept i="4">&lt;/g4&gt;</ept>은 적용된 항을 대체하는데 사용할 수 있습니다. 그리고 <bpt i="5" x="5">&lt;g5&gt;</bpt>congr<ept i="5">&lt;/g5&gt;</ept>는 한번에 둘 다 대체하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Start writing the proof from the top down, using
<bpt i="3" x="3">&lt;g3&gt;</bpt>sorry<ept i="3">&lt;/g3&gt;</ept> to fill in subproofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170320Z" creationid="tlqk35" creationdate="20220321T170320Z">
        <seg>하향식으로 증명 작성을 하작하려면 보조 증명에 <bpt i="3" x="3">&lt;g3&gt;</bpt>sorry<ept i="3">&lt;/g3&gt;</ept>를 채워 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structural Recursion and Induction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170313Z" creationid="tlqk3" creationdate="20220529T170313Z">
        <seg>구조적 재귀와 귀납</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structures and Records</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T172114Z" creationid="tlqk35" creationdate="20220528T172114Z">
        <seg>구조체와 레코드</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structuring Tactic Proofs</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142401Z" creationid="tlqk35" creationdate="20220524T142401Z">
        <seg>전략 증명 구조화하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Structuring conversion tactics</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183749Z" creationid="tlqk3" creationdate="20220604T183749Z">
        <seg>전환 전술 구조화하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such a
function is <bpt i="3" x="3">&lt;g3&gt;</bpt>polymorphic<ept i="3">&lt;/g3&gt;</ept>: you expect the <bpt i="4" x="4">&lt;g4&gt;</bpt>cons<ept i="4">&lt;/g4&gt;</ept> function for
<bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>Bool<ept i="6">&lt;/g6&gt;</ept>, or an arbitrary type <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept> to behave the same way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151118Z" creationid="tlqk35" creationdate="20220321T151118Z">
        <seg>이러한 함수는 <bpt i="3" x="3">&lt;g3&gt;</bpt>polymorphic<ept i="3">&lt;/g3&gt;</ept>입니다. 여러분은 <bpt i="4" x="4">&lt;g4&gt;</bpt>cons<ept i="4">&lt;/g4&gt;</ept>는  <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>Bool<ept i="6">&lt;/g6&gt;</ept> 혹은 임의의 유형  <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept>에 대해 동일한 방식으로 동작해야 한다고 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such examples of <bpt i="1" x="1">&lt;g1&gt;</bpt>dependent pattern matching<ept i="1">&lt;/g1&gt;</ept> are
considered in the <bpt i="2" x="2">&lt;g2&gt;</bpt>Section Dependent Pattern Matching<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164606Z" creationid="tlqk3" creationdate="20220529T164606Z">
        <seg>그런 <bpt i="1" x="1">&lt;g1&gt;</bpt>종속적인 패턴 매칭<ept i="1">&lt;/g1&gt;</ept>의 예제는 <bpt i="2" x="2">&lt;g2&gt;</bpt>종속적인 패턴 매칭 섹션<ept i="2">&lt;/g2&gt;</ept>에서 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such parameters
are simply added to the local context before the definition is
processed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173510Z" creationid="tlqk3" creationdate="20220529T173510Z">
        <seg>그런 매개변수들은 단순히 정의가 처리되기 전에 지역 상황에 추가됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Such systems
can have bugs, and it can be difficult to ensure that the results they deliver are correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131418Z" creationid="tlqk35" creationdate="20220321T131418Z">
        <seg>이런 시스템들은 버그가 생길 수 있고, 그들이 올바르다고 도출한 결과를 확실히 보장하기가 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Sugar for Simple Functions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135917Z" creationid="tlqk3" creationdate="20220526T135917Z">
        <seg>간단한 함수를 위한 설탕</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose that, assuming <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> as a hypothesis, we have a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155118Z" creationid="tlqk35" creationdate="20220321T155118Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>를 가정으로 하면 <bpt i="2" x="2">&lt;g2&gt;</bpt>q<ept i="2">&lt;/g2&gt;</ept>의 증명을 가질 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we define
a function <bpt i="1" x="1">&lt;g1&gt;</bpt>f (x : Nat) {y : Nat} (z : Nat)<ept i="1">&lt;/g1&gt;</ept> with the arguments
shown.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184942Z" creationid="tlqk3" creationdate="20220525T184942Z">
        <seg>우리가 인수를 제시하여 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>f (x : Nat) {y : Nat} (z : Nat)<ept i="1">&lt;/g1&gt;</ept>을 정의했다고 합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we have <bpt i="2" x="2">&lt;g2&gt;</bpt>α : Sort i<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>β : Sort j<ept i="3">&lt;/g3&gt;</ept>, where the
expression <bpt i="4" x="4">&lt;g4&gt;</bpt>β<ept i="4">&lt;/g4&gt;</ept> may depend on a variable <bpt i="5" x="5">&lt;g5&gt;</bpt>x : α<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174455Z" creationid="tlqk35" creationdate="20220321T174455Z">
        <seg>우리가 <bpt i="2" x="2">&lt;g2&gt;</bpt>α : Sort i<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>β : Sort j<ept i="3">&lt;/g3&gt;</ept>을 갖고 있다고 가정합시다. 여기서 표현식 <bpt i="4" x="4">&lt;g4&gt;</bpt>β<ept i="4">&lt;/g4&gt;</ept>는 변수  <bpt i="5" x="5">&lt;g5&gt;</bpt>x : α<ept i="5">&lt;/g5&gt;</ept>에 의존할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we have an implementation of lists as:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152423Z" creationid="tlqk35" creationdate="20220321T152423Z">
        <seg>우리가 리스트의 구현을 다음과 같이 했다고 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we try to prove the commutativity of addition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162301Z" creationid="tlqk3" creationdate="20220527T162301Z">
        <seg>우리가 덧셈에 교환성을 증명하려고 한다 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose we want to prove example
<bpt i="1" x="1">&lt;g1&gt;</bpt>(fun x : Nat =&gt; 0 + x) = (fun x =&gt; x)<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183009Z" creationid="tlqk3" creationdate="20220604T183009Z">
        <seg>예제 <bpt i="1" x="1">&lt;g1&gt;</bpt>(fun x : Nat =&gt; 0 + x) = (fun x =&gt; x)<ept i="1">&lt;/g1&gt;</ept>을 증명하고 싶다고 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you have the variable <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept> and you can
construct an expression <bpt i="3" x="3">&lt;g3&gt;</bpt>t : β<ept i="3">&lt;/g3&gt;</ept>, then the expression <bpt i="4" x="4">&lt;g4&gt;</bpt>fun (x : α)
=&gt; t<ept i="4">&lt;/g4&gt;</ept>, or, equivalently, <bpt i="5" x="5">&lt;g5&gt;</bpt>λ (x : α) =&gt; t<ept i="5">&lt;/g5&gt;</ept>, is an object of type <bpt i="6" x="6">&lt;g6&gt;</bpt>α
→ β<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142401Z" creationid="tlqk35" creationdate="20220321T142401Z">
        <seg>여러분이 변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept>를 갖고 있고 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>t : β<ept i="3">&lt;/g3&gt;</ept>을 만들 수 있다 가정합시다. 그러면 표현식<bpt i="4" x="4">&lt;g4&gt;</bpt>fun (x : α) =&gt; t<ept i="4">&lt;/g4&gt;</ept> 또는 등가적으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>λ (x : α) =&gt; t<ept i="5">&lt;/g5&gt;</ept>은 <bpt i="6" x="6">&lt;g6&gt;</bpt>α → β<ept i="6">&lt;/g6&gt;</ept> 유형인 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose you wish to write a function <bpt i="1" x="1">&lt;g1&gt;</bpt>cons<ept i="1">&lt;/g1&gt;</ept> which inserts a new
element at the head of a list.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151011Z" creationid="tlqk35" creationdate="20220321T151011Z">
        <seg>여러분이 리스트의 머리에 새 원소를 삽입하는 함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>cons<ept i="1">&lt;/g1&gt;</ept>를 만들기 원한다 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Suppose, however, that <bpt i="9" x="9">&lt;g9&gt;</bpt>β<ept i="9">&lt;/g9&gt;</ept>
is of <bpt i="10" x="10">&lt;g10&gt;</bpt>Sort 0<ept i="10">&lt;/g10&gt;</ept>, that is, an element of <bpt i="11" x="11">&lt;g11&gt;</bpt>Prop<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174921Z" creationid="tlqk35" creationdate="20220321T174852Z">
        <seg>그러나 <bpt i="9" x="9">&lt;g9&gt;</bpt>β<ept i="9">&lt;/g9&gt;</ept>가 <bpt i="10" x="10">&lt;g10&gt;</bpt>Sort 0<ept i="10">&lt;/g10&gt;</ept>형이라고 가정하면 즉, <bpt i="11" x="11">&lt;g11&gt;</bpt>Prop<ept i="11">&lt;/g11&gt;</ept>의 원소라면</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Systems of natural deduction for propositional logic also typically rely on the following rule:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155031Z" creationid="tlqk35" creationdate="20220321T155031Z">
        <seg>명제논리의 자연 영역에 대한 체계은 주로 다음 규칙에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>TO DO: eventually, describe using_well_founded.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173305Z" creationid="tlqk3" creationdate="20220603T173305Z">
        <seg>할 것: 결국, 잘 세워진을 사용하는 것을 기술하기.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tactic commands can take compound expressions, not just single
identifiers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060558Z" creationid="tlqk35" creationdate="20220522T060558Z">
        <seg>전략 명령은 하나의 식별자 뿐만 아니라 복합된 식을 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tactics</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184229Z" creationid="tlqk35" creationdate="20220321T184229Z">
        <seg>전략</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tactics for Inductive Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163534Z" creationid="tlqk3" creationdate="20220527T163534Z">
        <seg>귀납형에 대한 전략</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tactics often provide an efficient way of building a proof, but long
sequences of instructions can obscure the structure of the
argument.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142528Z" creationid="tlqk35" creationdate="20220524T142528Z">
        <seg>전략들은 종종 증명을 세우는데 효율적인 방식을 제공합니다. 그러나 
지시사항들의 긴 나열은 인수(argument)의 구조를 모호하게 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Tactics that may produce multiple subgoals often tag them.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060948Z" creationid="tlqk35" creationdate="20220522T060948Z">
        <seg>다수의 하위 목표를 생성할 수 있는 전략은 이들에 표식을 붙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Taking the left conjunct
gives the desired conclusion, <bpt i="9" x="9">&lt;g9&gt;</bpt>p y<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173906Z" creationid="tlqk35" creationdate="20220321T173906Z">
        <seg>왼쪽의 결합자를 취하는 것은 원하는 결론 <bpt i="9" x="9">&lt;g9&gt;</bpt>p y<ept i="9">&lt;/g9&gt;</ept>을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That assignment can also be made local:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183629Z" creationid="tlqk3" creationdate="20220525T183629Z">
        <seg>그 배정는 지역적으로 만들어 질 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That command, which will
be explained in <bpt i="4" x="4">&lt;g4&gt;</bpt>Chapter Type Classes<ept i="4">&lt;/g4&gt;</ept>, works by
assigning an <bpt i="5" x="5">&lt;g5&gt;</bpt>[instance]<ept i="5">&lt;/g5&gt;</ept> attribute to the associated definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183540Z" creationid="tlqk3" creationdate="20220525T183540Z">
        <seg> <bpt i="4" x="4">&lt;g4&gt;</bpt>Chapter Type Classes<ept i="4">&lt;/g4&gt;</ept>에서 설명할 그 명령은 연관된 정의에 <bpt i="5" x="5">&lt;g5&gt;</bpt>[instance]<ept i="5">&lt;/g5&gt;</ept> 특성을 배정하는 것으로 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That expression is syntactic
sugar for <bpt i="6" x="6">&lt;g6&gt;</bpt>ite p a b<ept i="6">&lt;/g6&gt;</ept>, where <bpt i="7" x="7">&lt;g7&gt;</bpt>ite<ept i="7">&lt;/g7&gt;</ept> is defined as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172449Z" creationid="tlqk3" creationdate="20220604T172449Z">
        <seg>그 표현식은 <bpt i="6" x="6">&lt;g6&gt;</bpt>ite p a b<ept i="6">&lt;/g6&gt;</ept>에 대한 문법적 설탕입니다. 여기서 <bpt i="7" x="7">&lt;g7&gt;</bpt>ite<ept i="7">&lt;/g7&gt;</ept> 다음과 같이 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is,
an instance declaration can in turn depend on an implicit instance of a type class.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161013Z" creationid="tlqk3" creationdate="20220604T161013Z">
        <seg>즉, 개체 선언은 유형 클래스의 암시적인 개체에 차례로 의존하게 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, given <bpt i="1" x="1">&lt;g1&gt;</bpt>h1 : a = b<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>h2 : p a<ept i="2">&lt;/g2&gt;</ept>, we
can construct a proof for <bpt i="3" x="3">&lt;g3&gt;</bpt>p b<ept i="3">&lt;/g3&gt;</ept> using substitution:
<bpt i="4" x="4">&lt;g4&gt;</bpt>Eq.subst h1 h2<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175735Z" creationid="tlqk35" creationdate="20220321T175735Z">
        <seg>즉, <bpt i="1" x="1">&lt;g1&gt;</bpt>h1 : a = b<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>h2 : p a<ept i="2">&lt;/g2&gt;</ept>에 대해 <bpt i="3" x="3">&lt;g3&gt;</bpt>p b<ept i="3">&lt;/g3&gt;</ept>에 대한 증명을 <bpt i="4" x="4">&lt;g4&gt;</bpt>Eq.subst h1 h2<ept i="4">&lt;/g4&gt;</ept>과 같은 대체를 사용하여 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>That is, in <bpt i="1" x="1">&lt;g1&gt;</bpt>dite c t e<ept i="1">&lt;/g1&gt;</ept>, we can assume <bpt i="2" x="2">&lt;g2&gt;</bpt>hc : c<ept i="2">&lt;/g2&gt;</ept> in the "then"
branch, and <bpt i="3" x="3">&lt;g3&gt;</bpt>hnc : ¬ c<ept i="3">&lt;/g3&gt;</ept> in the "else" branch.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172752Z" creationid="tlqk3" creationdate="20220604T172752Z">
        <seg>즉, <bpt i="1" x="1">&lt;g1&gt;</bpt>dite c t e<ept i="1">&lt;/g1&gt;</ept>에서 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>hc : c<ept i="2">&lt;/g2&gt;</ept>를 "then" 분기 그리고 "else" 분기에서 <bpt i="3" x="3">&lt;g3&gt;</bpt>hnc : ¬ c<ept i="3">&lt;/g3&gt;</ept>라고 가정할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
<bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> tactics tend to be very effective in proofs
like these.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T161229Z" creationid="tlqk3" creationdate="20220527T161229Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> 전략은 이 같은 증명에서 아주 효과적인 경향이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
<bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept> command also allows us to define new structures based on
previously defined ones.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173304Z" creationid="tlqk35" creationdate="20220528T173304Z">
        <seg>또 <bpt i="2" x="2">&lt;g2&gt;</bpt>structure<ept i="2">&lt;/g2&gt;</ept>  명령은 이전에 정의한 구조체에 기반한 새 구조체를 정의하도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
canonical way to prove <bpt i="2" x="2">&lt;g2&gt;</bpt>∀ y : α, p y<ept i="2">&lt;/g2&gt;</ept> is to take an arbitrary <bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept>,
and prove <bpt i="4" x="4">&lt;g4&gt;</bpt>p y<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173803Z" creationid="tlqk35" creationdate="20220321T173803Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>∀ y : α, p y<ept i="2">&lt;/g2&gt;</ept>을 증명하는 표준 방법은 임의의 <bpt i="3" x="3">&lt;g3&gt;</bpt>y<ept i="3">&lt;/g3&gt;</ept>를 받고  <bpt i="4" x="4">&lt;g4&gt;</bpt>p y<ept i="4">&lt;/g4&gt;</ept>임을 증명하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
command</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174052Z" creationid="tlqk35" creationdate="20220524T174052Z">
        <seg>명령</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
constructors all live in the <bpt i="3" x="3">&lt;g3&gt;</bpt>Weekday<ept i="3">&lt;/g3&gt;</ept> namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T145312Z" creationid="tlqk3" creationdate="20220526T145312Z">
        <seg>생성자는 모두 <bpt i="3" x="3">&lt;g3&gt;</bpt>Weekday<ept i="3">&lt;/g3&gt;</ept> 이름공간에 살고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
definition of equality is atypical, however; see the discussion in the
next section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154200Z" creationid="tlqk35" creationdate="20220528T154200Z">
        <seg>하지만 동등성의 정의는 전형적이지 않습니다. 다음 섹션의 논의를 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
difference is that given <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>hq : q<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>And.intro hp
hq<ept i="3">&lt;/g3&gt;</ept> has type <bpt i="4" x="4">&lt;g4&gt;</bpt>p ∧ q : Prop<ept i="4">&lt;/g4&gt;</ept>, while <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod hp hq<ept i="5">&lt;/g5&gt;</ept> has type
<bpt i="6" x="6">&lt;g6&gt;</bpt>p × q : Type<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162937Z" creationid="tlqk35" creationdate="20220321T162937Z">
        <seg>차이는 <bpt i="1" x="1">&lt;g1&gt;</bpt>hp : p<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>hq : q<ept i="2">&lt;/g2&gt;</ept>가 주어졌을 때 <bpt i="3" x="3">&lt;g3&gt;</bpt>And.intro hp hq<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>p ∧ q : Prop<ept i="4">&lt;/g4&gt;</ept>형을 갖는 한편 <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod hp hq<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>p × q : Type<ept i="6">&lt;/g6&gt;</ept>형을 갖는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
distinction is only useful in constructive mathematics; classically,
every proposition is decidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171429Z" creationid="tlqk3" creationdate="20220604T171429Z">
        <seg>이 구별은 직관주의적 수학에서만 유용합니다. 고전적으로 모든 명제는 결정 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
elimination rules provide for a principle of recursion on the type,
which includes, as a special case, a principle of induction as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T144552Z" creationid="tlqk3" creationdate="20220526T144552Z">
        <seg>제거 규칙은 유형의 재귀의 원리를 제공합니다. 이것은 특별한 경우로서 귀납의 원리도 포합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
function <bpt i="8" x="8">&lt;g8&gt;</bpt>F<ept i="8">&lt;/g8&gt;</ept> provides the inductive recipe for doing that: it tells
us how to construct an element <bpt i="9" x="9">&lt;g9&gt;</bpt>C x<ept i="9">&lt;/g9&gt;</ept>, given elements of <bpt i="10" x="10">&lt;g10&gt;</bpt>C y<ept i="10">&lt;/g10&gt;</ept> for
each predecessor <bpt i="11" x="11">&lt;g11&gt;</bpt>y<ept i="11">&lt;/g11&gt;</ept> of <bpt i="12" x="12">&lt;g12&gt;</bpt>x<ept i="12">&lt;/g12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165813Z" creationid="tlqk3" creationdate="20220603T165813Z">
        <seg>함수 <bpt i="8" x="8">&lt;g8&gt;</bpt>F<ept i="8">&lt;/g8&gt;</ept>는 그것을 하는데 귀납적인 요리법을 제공합니다. 이것은 <bpt i="12" x="12">&lt;g12&gt;</bpt>x<ept i="12">&lt;/g12&gt;</ept>의 각 선행자 <bpt i="11" x="11">&lt;g11&gt;</bpt>y<ept i="11">&lt;/g11&gt;</ept>에 대해<bpt i="10" x="10">&lt;g10&gt;</bpt>C y<ept i="10">&lt;/g10&gt;</ept>의  원소가 주어진 경우 원소 <bpt i="9" x="9">&lt;g9&gt;</bpt>C x<ept i="9">&lt;/g9&gt;</ept>를 생성하는 법을 우리에게 말해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
properties above are stated for the natural numbers (type <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180010Z" creationid="tlqk35" creationdate="20220321T180010Z">
        <seg>위의 성질들은 자연수 (type <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>)에 대해 기술되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The
type <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept> consists of nothing more than the objects that are
constructed in this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T142836Z" creationid="tlqk3" creationdate="20220526T142836Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept> 유형은 이 방식으로 생성된 대상 외에 아무것도 갖고있지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The (unstructured) <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> is particularly useful when you can close several
subgoals using the same tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070730Z" creationid="tlqk35" creationdate="20220522T070730Z">
        <seg>(비구조화된)<bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept>는 여러분이 여러 개의 하위목표를 같은 전략을 사용해 끝낼 때 특히 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="10" x="10">&lt;g10&gt;</bpt>try<ept i="10">&lt;/g10&gt;</ept> tactic ensures that the sequential composition
succeeds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151824Z" creationid="tlqk35" creationdate="20220524T151824Z">
        <seg><bpt i="10" x="10">&lt;g10&gt;</bpt>try<ept i="10">&lt;/g10&gt;</ept> 전략은 순차적인 함성 성공을 보장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>;<ept i="1">&lt;/g1&gt;</ept> can be omitted when a line break is used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144853Z" creationid="tlqk35" creationdate="20220321T144853Z">
        <seg>세미콜론<bpt i="1" x="1">&lt;g1&gt;</bpt>;<ept i="1">&lt;/g1&gt;</ept>은 줄을 분리할 때 사용되므로 생략될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Bool<ept i="1">&lt;/g1&gt;</ept> type in the Lean library is an instance of
enumerated type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151914Z" creationid="tlqk3" creationdate="20220526T151914Z">
        <seg>린 라이브러리에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>Bool<ept i="1">&lt;/g1&gt;</ept>형은 열거 유형의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Decidable<ept i="1">&lt;/g1&gt;</ept> type class also provides a bit of small-scale
automation for proving theorems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174505Z" creationid="tlqk3" creationdate="20220604T174505Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Decidable<ept i="1">&lt;/g1&gt;</ept> 유형 클래스는 정리 증명에 대한 아주 작은 소규모의 자동화도 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Lean Theorem Prover<ept i="1">&lt;/g1&gt;</ept> aims to bridge the gap between interactive and automated theorem proving, by situating
automated tools and methods in a framework that supports user interaction and the construction of fully specified
axiomatic proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131527Z" creationid="tlqk35" creationdate="20220321T131527Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>Lean 증명 보조기<ept i="1">&lt;/g1&gt;</ept>는 사용자의 상호작용과 완전히 구체화된 공리적 증명의 생성을 돕는 자동화된 도구와 방법들을 프레임워크에 둠으로써 상호작용과 자동화된 정리 증명 사이의 빈틈을 메우는 것을 목표로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Lean<ept i="1">&lt;/g1&gt;</ept> project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131729Z" creationid="tlqk35" creationdate="20220321T131729Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Lean<ept i="1">&lt;/g1&gt;</ept> 프로젝트는 마이크로소프트 연구소 Redmond의 Leonardo de Moura가 2013년 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Mul<ept i="1">&lt;/g1&gt;</ept> class is convenient for types that only implement the homogeneous multiplication.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170211Z" creationid="tlqk3" creationdate="20220604T170211Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Mul<ept i="1">&lt;/g1&gt;</ept> 클래스는 동형 곱셈만 구현된 유형에 대해 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.recOn<ept i="1">&lt;/g1&gt;</ept> is similar to <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.rec<ept i="2">&lt;/g2&gt;</ept> but the major premise occurs before the minor premises.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155858Z" creationid="tlqk3" creationdate="20220527T155858Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.recOn<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.rec<ept i="2">&lt;/g2&gt;</ept>과 비슷하지만 주요 전제는 사소한 전제보다 먼저 일어납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>OfNat<ept i="1">&lt;/g1&gt;</ept> instance is parametric on the numeral.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162918Z" creationid="tlqk3" creationdate="20220604T162918Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>OfNat<ept i="1">&lt;/g1&gt;</ept> 개체는 수치에 대해 매개적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> tactic applies an expression, viewed as denoting a
function with zero or more arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184622Z" creationid="tlqk35" creationdate="20220321T184622Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>apply<ept i="1">&lt;/g1&gt;</ept> 전략은 0 또는 그 이상의 인수가 있는 함수를 나타내는 것으로 간주되는 표현식을 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>assumption<ept i="1">&lt;/g1&gt;</ept> tactic looks through the assumptions in context of
the current goal, and if there is one matching the conclusion, it
applies it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062935Z" creationid="tlqk35" creationdate="20220522T062815Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>assumption<ept i="1">&lt;/g1&gt;</ept> 전략은 현재 목표의 맥락 속 가정을 훝어 봅니다. 
그리고 결론과 대응되는 가정이 있다면 그것을 목표에 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept> command can be configured for any relation that supports
some form of transitivity.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180640Z" creationid="tlqk35" creationdate="20220321T180640Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept> 명령은 전달성의 몇몇 형태를 지원하는 어떤 관계에 대해서 설정될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>case<ept i="1">&lt;/g1&gt;</ept> tactic is clever, in that it will match the constructor to the appropriate goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165554Z" creationid="tlqk3" creationdate="20220527T165554Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>case<ept i="1">&lt;/g1&gt;</ept> 전략은 적절한 목표에 대한 생성자를 짝지어준다는 점에서 영리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic can also be used to
decompose a conjunction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071059Z" creationid="tlqk35" creationdate="20220522T071059Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략은 결합자를 분해하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic will also do a
case distinction on a natural number:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220523T073754Z" creationid="tlqk35" creationdate="20220523T073754Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략은 자연수에 대해 경우를 
나눌 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic works on elements of an inductively defined type,
and does what the name suggests: it decomposes the element according
to each of the possible constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163924Z" creationid="tlqk3" creationdate="20220527T163924Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략은 재귀적으로 정의된 유형의 원소와 이름이 제안하는 것에 작용합니다. 이것은 가능한 생성자들의 각각에 따라 원소를 분리한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic, and its companion, the <bpt i="2" x="2">&lt;g2&gt;</bpt>induction<ept i="2">&lt;/g2&gt;</ept> tactic, are discussed in greater detail in
the <bpt i="3" x="3">&lt;g3&gt;</bpt>Tactics for Inductive Types<ept i="3">&lt;/g3&gt;</ept> section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142143Z" creationid="tlqk35" creationdate="20220524T142143Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략 그리고 그것의 동반자인 <bpt i="2" x="2">&lt;g2&gt;</bpt>induction<ept i="2">&lt;/g2&gt;</ept> 전략은 
<bpt i="3" x="3">&lt;g3&gt;</bpt>Tactics for Inductive Types<ept i="3">&lt;/g3&gt;</ept>  섹션에서 더욱 상세히 논의될 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>contradiction<ept i="1">&lt;/g1&gt;</ept> tactic searches for a contradiction among the hypotheses of the current goal:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142215Z" creationid="tlqk35" creationdate="20220524T142215Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>contradiction<ept i="1">&lt;/g1&gt;</ept> 전략은 현재 목표의 가정 사이에 모순을 탐색합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept> keyword declares new constant symbols into the
working environment.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135611Z" creationid="tlqk35" creationdate="20220321T135611Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept>는 작업 환경에 새로운 상수기호를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>example<ept i="1">&lt;/g1&gt;</ept> command states a theorem without naming it or storing
it in the permanent context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162659Z" creationid="tlqk35" creationdate="20220321T162659Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>example<ept i="1">&lt;/g1&gt;</ept> 명령은 이름이 없이 영구적인 맥락으로 저장하지 않는 정리를 기술합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>first | t₁ | t₂ | ... | tₙ<ept i="1">&lt;/g1&gt;</ept> applies each <bpt i="2" x="2">&lt;g2&gt;</bpt>tᵢ<ept i="2">&lt;/g2&gt;</ept> until one succeeds, or else fails:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150543Z" creationid="tlqk35" creationdate="20220524T150543Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>first | t₁ | t₂ | ... | tₙ<ept i="1">&lt;/g1&gt;</ept>은 각각의  <bpt i="2" x="2">&lt;g2&gt;</bpt>tᵢ<ept i="2">&lt;/g2&gt;</ept>에 대해 이 중 하나가 성공하거나 실패할 때까지 적용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>induction<ept i="1">&lt;/g1&gt;</ept> tactic also supports user-defined induction principles with
multiple targets (aka major premises).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172241Z" creationid="tlqk3" creationdate="20220527T172241Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>induction<ept i="1">&lt;/g1&gt;</ept> 전략은 (주요 전제라고도 하는) 다수의 타겟을 갖는 사용자 정의 귀납 원리도 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>inductive<ept i="1">&lt;/g1&gt;</ept> command creates a new type, <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T145246Z" creationid="tlqk3" creationdate="20220526T145246Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>inductive<ept i="1">&lt;/g1&gt;</ept> 명령은 새로운 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>injection<ept i="1">&lt;/g1&gt;</ept> tactic also detects contradictions that arise when different constructors
are set equal to one another, and uses them to close the goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T173115Z" creationid="tlqk3" creationdate="20220527T173115Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>injection<ept i="1">&lt;/g1&gt;</ept> 전략은 서로 다른 생성자들이 서로 같도록 설정되었을 때 일어나는 모순을 감지하고 이들로 목표를 종료하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>intro<ept i="1">&lt;/g1&gt;</ept> command can more generally be used to introduce a variable of any type:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062210Z" creationid="tlqk35" creationdate="20220522T062210Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>intro<ept i="1">&lt;/g1&gt;</ept>명령은 폭넓게로는 임의 유형의 변수를 도입하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>intros<ept i="1">&lt;/g1&gt;</ept> tactic can be used without any arguments, in which
case, it chooses names and introduces as many variables as it can.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062749Z" creationid="tlqk35" creationdate="20220522T062749Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>intros<ept i="1">&lt;/g1&gt;</ept> 전략은 어떠한 인수 없이도 사용될 수 있습니다. 
가령, 그것은 이름을 선택할 수 있고, 원하는 한 많이 많은 변수를 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>map<ept i="1">&lt;/g1&gt;</ept> function is even more tedious to define by hand than the
<bpt i="2" x="2">&lt;g2&gt;</bpt>tail<ept i="2">&lt;/g2&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T184127Z" creationid="tlqk3" creationdate="20220603T184127Z">
        <seg>심지어 <bpt i="1" x="1">&lt;g1&gt;</bpt>map<ept i="1">&lt;/g1&gt;</ept> 함수는 <bpt i="2" x="2">&lt;g2&gt;</bpt>tail<ept i="2">&lt;/g2&gt;</ept> 함수보다 손으로 정의하기에는 더 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expression is part of Lean's function definition system,
which provides convenient and expressive ways of defining complex
functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182612Z" creationid="tlqk35" creationdate="20220321T182458Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식은 복잡한 함수를 정의하는데 편리하고 표현력있는 방식을 제공하는 린의 함수 정의 시스템의 일부분입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>open<ept i="1">&lt;/g1&gt;</ept> command admits variations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180911Z" creationid="tlqk35" creationdate="20220524T180911Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>open<ept i="1">&lt;/g1&gt;</ept> 명령은 변형을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>open<ept i="1">&lt;/g1&gt;</ept> command brings the shorter names into the current
context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150440Z" creationid="tlqk35" creationdate="20220321T150440Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>open<ept i="1">&lt;/g1&gt;</ept> 명령은 현재 맥락에서 짧은 이름을 가져옵니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>or-elimination<ept i="1">&lt;/g1&gt;</ept> rule is slightly more complicated.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163700Z" creationid="tlqk35" creationdate="20220321T163700Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>or-제거<ept i="1">&lt;/g1&gt;</ept> 규칙은 약간 더 복잡합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>repeat<ept i="1">&lt;/g1&gt;</ept> combinator can be used to apply a tactic several times.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063805Z" creationid="tlqk35" creationdate="20220522T063805Z">
        <seg>조합자  <bpt i="1" x="1">&lt;g1&gt;</bpt>repeat<ept i="1">&lt;/g1&gt;</ept>는 한 전략을 여러 차례 적용하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic (abbreviated <bpt i="2" x="2">&lt;g2&gt;</bpt>rw<ept i="2">&lt;/g2&gt;</ept>) and the <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> tactic
were introduced briefly in <bpt i="4" x="4">&lt;g4&gt;</bpt>Calculational Proofs<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T153240Z" creationid="tlqk35" creationdate="20220524T153240Z">
        <seg> (<bpt i="2" x="2">&lt;g2&gt;</bpt>rw<ept i="2">&lt;/g2&gt;</ept>로 축약되는)<bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> 전략과 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept>전략은 
<bpt i="4" x="4">&lt;g4&gt;</bpt>Calculational Proofs<ept i="4">&lt;/g4&gt;</ept>에 간략히 도입되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic is not restricted to propositions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171824Z" creationid="tlqk35" creationdate="20220524T160430Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> 전략은 명제에만 국한되지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic provides a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T153504Z" creationid="tlqk35" creationdate="20220524T153504Z">
        <seg>동등성에 대해 편리하고 효율적인 방식을 제공하면서 
<bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> 전략은 목표와 가정에 치환을 적용하는 기본적인 작동원리를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>rfl<ept i="1">&lt;/g1&gt;</ept> tactic is syntax sugar for <bpt i="2" x="2">&lt;g2&gt;</bpt>exact rfl<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063726Z" creationid="tlqk35" creationdate="20220522T063726Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>rfl<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>exact rfl<ept i="2">&lt;/g2&gt;</ept>에 대한 문법 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> command does
nothing more than annotate the type, and, internally, all the
presentations of <bpt i="2" x="2">&lt;g2&gt;</bpt>t1<ept i="2">&lt;/g2&gt;</ept> that we have seen produce the same term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161127Z" creationid="tlqk35" creationdate="20220321T161127Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> 명령은 유형에 주석을 달 뿐이고, 내부적으로 우리가 본 <bpt i="2" x="2">&lt;g2&gt;</bpt>t1<ept i="2">&lt;/g2&gt;</ept>의 모든 나타남이 동일한 용어를 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> tactic can actually be used to rewrite a goal to something definitionally equivalent:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143548Z" creationid="tlqk35" creationdate="20220524T143548Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>show<ept i="1">&lt;/g1&gt;</ept> 전략은 실제로 무언가 정의 상으로 동등한 목표를 다시 쓰는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> tactic, instead, rewrites the goal by applying the given
identities repeatedly, in any order, anywhere they are applicable in a
term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180515Z" creationid="tlqk35" creationdate="20220321T180515Z">
        <seg>대신 <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> 전략은 주어진 항등식들을 그들이 항에 적용되는 어느 곳이든 임의의 순서대로 반복적으로 사용하여 목표를 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept> identifier magically produces a proof of anything, or
provides an object of any data type at all.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170232Z" creationid="tlqk35" creationdate="20220321T170232Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept> 식별자는 어떤 증명이든 마법같이 만듭니다. 혹은 임의의 데이터 유형의 객체를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept>
command, available in Lean, provides infrastructure to support this
process.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173150Z" creationid="tlqk35" creationdate="20220528T173150Z">
        <seg> 린에서 사용할 수 있는 <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> 명령은 이 절차를 지원하는 기반구조를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> command is especially useful for defining algebraic
structures, and Lean provides substantial infrastructure to support
working with them.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145720Z" creationid="tlqk3" creationdate="20220527T145720Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>structure<ept i="1">&lt;/g1&gt;</ept> 명령은 대수적 구조를 정의하는데 특히 유용합니다. 그리고 린은 이들과 작업을 지원하는 중요한 기반구조를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>tail<ept i="1">&lt;/g1&gt;</ept> function is, however, easy to define using recursive
equations, and the equation compiler generates all the boilerplate
code automatically for us.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183906Z" creationid="tlqk3" creationdate="20220603T183906Z">
        <seg>하지만 <bpt i="1" x="1">&lt;g1&gt;</bpt>tail<ept i="1">&lt;/g1&gt;</ept> 함수는 재귀적인 방정식을 사용해 정의하기 쉽습니다. 그리고 방정식 컴파일러는 모든 보일러 플레이트 코드를 우리를 위해 자동적으로 만들어 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept> command instructs Lean to insert the declared
variables as bound variables in definitions that refer to them by
name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145922Z" creationid="tlqk35" creationdate="20220321T145922Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept>명령은 Lean에게 선언된 변수를 그들을 이름으로 참조하는 정의의 구속 변수로 삽입하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>cases<ept i="2">&lt;/g2&gt;</ept> tactic can be used to
decompose any element of an inductively defined type; <bpt i="3" x="3">&lt;g3&gt;</bpt>constructor<ept i="3">&lt;/g3&gt;</ept>
always applies the first applicable constructor of an inductively defined type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071936Z" creationid="tlqk35" creationdate="20220522T071828Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>cases<ept i="2">&lt;/g2&gt;</ept> 전략은 유도적으로 정의된 유형의 임의의 원소를 분해하는데 사용될 수 있습니다.
<bpt i="3" x="3">&lt;g3&gt;</bpt>constructor<ept i="3">&lt;/g3&gt;</ept>는 항상 유도적으로 정의된 유형의 처음으로 활용할 수 있는 생성자에 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>cond<ept i="2">&lt;/g2&gt;</ept> function is a boolean conditional: <bpt i="3" x="3">&lt;g3&gt;</bpt>cond b t1 t2<ept i="3">&lt;/g3&gt;</ept>
returns <bpt i="4" x="4">&lt;g4&gt;</bpt>t1<ept i="4">&lt;/g4&gt;</ept> if <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept> is true, and <bpt i="6" x="6">&lt;g6&gt;</bpt>t2<ept i="6">&lt;/g6&gt;</ept> otherwise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T154142Z" creationid="tlqk3" creationdate="20220526T154142Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>cond<ept i="2">&lt;/g2&gt;</ept> 함수는 조건 불리언입니다. <bpt i="3" x="3">&lt;g3&gt;</bpt>cond b t1 t2<ept i="3">&lt;/g3&gt;</ept>은 <bpt i="5" x="5">&lt;g5&gt;</bpt>b<ept i="5">&lt;/g5&gt;</ept>가 참이면 <bpt i="4" x="4">&lt;g4&gt;</bpt>t1<ept i="4">&lt;/g4&gt;</ept>을 그렇지 않으면 <bpt i="6" x="6">&lt;g6&gt;</bpt>t2<ept i="6">&lt;/g6&gt;</ept>를 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept>
command is just a variant of <bpt i="3" x="3">&lt;g3&gt;</bpt>apply<ept i="3">&lt;/g3&gt;</ept> which signals that the
expression given should fill the goal exactly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T054950Z" creationid="tlqk35" creationdate="20220522T054950Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>exact<ept i="2">&lt;/g2&gt;</ept>
명령은 목표와 동일한 표현식임을 알리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>apply<ept i="3">&lt;/g3&gt;</ept>의 변형일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>injection<ept i="2">&lt;/g2&gt;</ept> tactic is designed to make use of
this fact:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172856Z" creationid="tlqk3" creationdate="20220527T172856Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>injection<ept i="2">&lt;/g2&gt;</ept> 전략은 이 사실을 사용하도록 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>
statement "destructs" the existential assertion into the components
<bpt i="3" x="3">&lt;g3&gt;</bpt>w<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>hw<ept i="4">&lt;/g4&gt;</ept>, which can then be used in the body of the statement
to prove the proposition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182639Z" creationid="tlqk35" creationdate="20220321T182639Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept> 구문은 존재 주장 속 성분인 <bpt i="3" x="3">&lt;g3&gt;</bpt>w<ept i="3">&lt;/g3&gt;</ept>와 <bpt i="4" x="4">&lt;g4&gt;</bpt>hw<ept i="4">&lt;/g4&gt;</ept>로 '파괴'합니다.  이들은 명제를 증명하기 위해 문장의 몸체에서 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>sorry<ept i="2">&lt;/g2&gt;</ept> does not
prevent the bytecode evaluator from evaluating the function
successfully.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172814Z" creationid="tlqk3" creationdate="20220603T172814Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>sorry<ept i="2">&lt;/g2&gt;</ept>는 바이트코드 평가기가 함수를 성공적으로 평가하는 것을 막지 못합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="2" x="2">&lt;g2&gt;</bpt>try<ept i="2">&lt;/g2&gt;</ept> combinator builds a
tactic that always succeeds, though possibly in a trivial way:
<bpt i="3" x="3">&lt;g3&gt;</bpt>try t<ept i="3">&lt;/g3&gt;</ept> executes <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept> and reports success, even if <bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept> fails.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151428Z" creationid="tlqk35" creationdate="20220524T151428Z">
        <seg>대개 명백한 방식일지라도 <bpt i="2" x="2">&lt;g2&gt;</bpt>try<ept i="2">&lt;/g2&gt;</ept> 조합자는  항상 성공하는 전략을 만들고, 
<bpt i="5" x="5">&lt;g5&gt;</bpt>t<ept i="5">&lt;/g5&gt;</ept>가 실패했음에도 <bpt i="3" x="3">&lt;g3&gt;</bpt>try t<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>t<ept i="4">&lt;/g4&gt;</ept>를 실행하고 성공을 보고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;g3&gt;</bpt>@<ept i="3">&lt;/g3&gt;</ept> symbol
and the difference between the round and curly braces will be
explained momentarily.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152129Z" creationid="tlqk35" creationdate="20220321T152129Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>@<ept i="3">&lt;/g3&gt;</ept> 기호와 소괄호와 중괄호 사이의 차이는 곧 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;g3&gt;</bpt>Option<ept i="3">&lt;/g3&gt;</ept> type provides a way of representing partial functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T150223Z" creationid="tlqk3" creationdate="20220527T150223Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>Option<ept i="3">&lt;/g3&gt;</ept> 형은 부분 함수를 표현하는 한 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;g3&gt;</bpt>local<ept i="3">&lt;/g3&gt;</ept> modifier tells the simplifier
to use these rules in the current file (or section or namespace, as
the case may be).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T162147Z" creationid="tlqk35" creationdate="20220524T162147Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>local<ept i="3">&lt;/g3&gt;</ept> 수정자는 단순화기에게 현재 파일(아마 경우에 따라 섹션, 이름공간) 
속 이 규칙을 사용하라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;g3&gt;</bpt>match<ept i="3">&lt;/g3&gt;</ept> interprets
<bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept> as a pair, <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153530Z" creationid="tlqk3" creationdate="20220526T153530Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>match<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>를 쌍으로서 해석합니다. <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept></seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> tactic also recognizes the <bpt i="4" x="4">&lt;g4&gt;</bpt>←t<ept i="4">&lt;/g4&gt;</ept>
syntax that <bpt i="5" x="5">&lt;g5&gt;</bpt>rewrite<ept i="5">&lt;/g5&gt;</ept> does.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171718Z" creationid="tlqk35" creationdate="20220524T163201Z">
        <seg><bpt i="5" x="5">&lt;g5&gt;</bpt>rewrite<ept i="5">&lt;/g5&gt;</ept>가 그런 것처럼 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> 전략도 <bpt i="4" x="4">&lt;g4&gt;</bpt>←t<ept i="4">&lt;/g4&gt;</ept> 문법을 인식할 수 있습니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="5" x="5">&lt;g5&gt;</bpt>constructor<ept i="5">&lt;/g5&gt;</ept> tactic applies the unique
constructor for conjunction, <bpt i="6" x="6">&lt;g6&gt;</bpt>And.intro<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071324Z" creationid="tlqk35" creationdate="20220522T071324Z">
        <seg><bpt i="5" x="5">&lt;g5&gt;</bpt>constructor<ept i="5">&lt;/g5&gt;</ept> 전략은 결합자 <bpt i="6" x="6">&lt;g6&gt;</bpt>And.intro<ept i="6">&lt;/g6&gt;</ept>에 대한 단일 생성자를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="6" x="6">&lt;g6&gt;</bpt>#check<ept i="6">&lt;/g6&gt;</ept> command asks Lean to report their
types; in Lean, auxiliary commands that query the system for
information typically begin with the hash (#) symbol.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135833Z" creationid="tlqk35" creationdate="20220321T135833Z">
        <seg><bpt i="6" x="6">&lt;g6&gt;</bpt>#check<ept i="6">&lt;/g6&gt;</ept> 명령은 린에게 그것의 유형을 보고하도록 요청합니다. 린에서 시스템에게 정보를 불러오는 보조 명령은 주로 해시(#) 기호로 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="6" x="6">&lt;g6&gt;</bpt>rewrite<ept i="6">&lt;/g6&gt;</ept> tactic will be discussed below.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070109Z" creationid="tlqk35" creationdate="20220522T070050Z">
        <seg><bpt i="6" x="6">&lt;g6&gt;</bpt>rewrite<ept i="6">&lt;/g6&gt;</ept>전략은 아래에서 더 논의할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="7" x="7">&lt;g7&gt;</bpt>#eval<ept i="7">&lt;/g7&gt;</ept> command asks Lean to evaluate the given expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135856Z" creationid="tlqk35" creationdate="20220321T135856Z">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>#eval<ept i="7">&lt;/g7&gt;</ept> 명령은 린에게 제시된 표현의 값을 평가하도록 요청합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The <bpt i="9" x="9">&lt;g9&gt;</bpt>let<ept i="9">&lt;/g9&gt;</ept> construct is a stronger means of abbreviation, and there
are expressions of the form <bpt i="10" x="10">&lt;g10&gt;</bpt>let a := t1; t2<ept i="10">&lt;/g10&gt;</ept> that cannot be
expressed as <bpt i="11" x="11">&lt;g11&gt;</bpt>(fun a =&gt; t2) t1<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145042Z" creationid="tlqk35" creationdate="20220321T145042Z">
        <seg> <bpt i="9" x="9">&lt;g9&gt;</bpt>let<ept i="9">&lt;/g9&gt;</ept> 생성은 약어의 의미로 더 강합니다. 그리고 <bpt i="10" x="10">&lt;g10&gt;</bpt>let a := t1; t2<ept i="10">&lt;/g10&gt;</ept> 형태의 표현식은 <bpt i="11" x="11">&lt;g11&gt;</bpt>(fun a =&gt; t2) t1<ept i="11">&lt;/g11&gt;</ept>같이 표현될 수 없는 식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Calculus of Constructions therefore identifies dependent arrow
types with forall-expressions in this way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173244Z" creationid="tlqk35" creationdate="20220321T173244Z">
        <seg>그러므로 직관주의 계산법은 의존 화살표 유형을 이처럼 모든-표현식으로 바라봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Conversion Tactic Mode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181748Z" creationid="tlqk3" creationdate="20220604T181748Z">
        <seg>전략 모드로 전환</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Existential Quantifier</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180810Z" creationid="tlqk35" creationdate="20220321T180810Z">
        <seg>존재 한정기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Lean standard library contains
many instances of inductive types (e.g., <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>List<ept i="3">&lt;/g3&gt;</ept>),
and even the logical connectives are defined using inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152435Z" creationid="tlqk35" creationdate="20220528T172440Z">
        <seg>린 표준 라이브러리는 귀납형의 만은 개체(예 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>List<ept i="3">&lt;/g3&gt;</ept>)들을 담고 있습니다. 그리고 심지어 논리 결합자도 귀납형을 사용해 정의됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Lean standard library contains the definition <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstance<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161642Z" creationid="tlqk3" creationdate="20220604T161642Z">
        <seg>린 표준 라이브러리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstance<ept i="1">&lt;/g1&gt;</ept> 정의를 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The Universal Quantifier</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172601Z" creationid="tlqk35" creationdate="20220321T172601Z">
        <seg>전칭 한정기호</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The above snippet show three navigation commands:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183247Z" creationid="tlqk3" creationdate="20220604T182550Z">
        <seg>위의 자투리는 세 가지 탐색 명령을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The actual Lean implementation defines homogeneous and heterogeneous classes for arithmetical operators.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165312Z" creationid="tlqk3" creationdate="20220604T165312Z">
        <seg>실제 린에서 구현은 산술 연산자에 대한 동형과 이형 클래스를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The advantage is that we can simply write <bpt i="1" x="1">&lt;g1&gt;</bpt>trans_r hab hbc<ept i="1">&lt;/g1&gt;</ept> as a
proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>r a c<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174303Z" creationid="tlqk35" creationdate="20220321T174303Z">
        <seg>이것의 장점은 우리가 간단히 <bpt i="1" x="1">&lt;g1&gt;</bpt>trans_r hab hbc<ept i="1">&lt;/g1&gt;</ept>을  <bpt i="2" x="2">&lt;g2&gt;</bpt>r a c<ept i="2">&lt;/g2&gt;</ept>의 증명으로 쓸 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The alternatives for each constructor don't need to be solved
in the order the constructors were declared.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165249Z" creationid="tlqk3" creationdate="20220527T165249Z">
        <seg>각 생성자에 대한 대안은 성성자가 선언된 순서대로 풀려야 할 필요는 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The analogy to the logical connectives
should not come as a surprise; as we will see below, they, too, are
examples of inductive type constructions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151842Z" creationid="tlqk3" creationdate="20220526T144423Z">
        <seg>논리 연결사와 유사점은 놀라움으로 오지 말아야 합니다. 우리가 아래에서 보듯이 그들도 귀납형 생성의 예제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The appearances of constructors prompt case splits, with
the arguments to the constructors represented by the given
variables.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171318Z" creationid="tlqk3" creationdate="20220529T171318Z">
        <seg>생성자의 출현은 제시된 변수로 표현된 생성자에 대한 인수로 경우를 신속히 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The arbitrary fact, <bpt i="1" x="1">&lt;g1&gt;</bpt>q<ept i="1">&lt;/g1&gt;</ept>, that follows from falsity is an implicit
argument in <bpt i="2" x="2">&lt;g2&gt;</bpt>False.elim<ept i="2">&lt;/g2&gt;</ept> and is inferred automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164448Z" creationid="tlqk35" creationdate="20220321T164448Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>q<ept i="1">&lt;/g1&gt;</ept>가 어떤 거짓 명제로부터 나온다는 사실은 <bpt i="2" x="2">&lt;g2&gt;</bpt>False.elim<ept i="2">&lt;/g2&gt;</ept>에 대한 암시적 인수이며 자동적으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The argument <bpt i="1" x="1">&lt;g1&gt;</bpt>motive<ept i="1">&lt;/g1&gt;</ept> is used to specify the type of the object you want to
construct, and it is a function because it may depend on the pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T154004Z" creationid="tlqk3" creationdate="20220526T154004Z">
        <seg>인자 <bpt i="1" x="1">&lt;g1&gt;</bpt>motive<ept i="1">&lt;/g1&gt;</ept>는 여러분이 생성하기 원하는 대상의 유형을 명시하는데 사용됩니다. 그리고 이것은 쌍에 의존할 수 있기에 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The argument <bpt i="1" x="1">&lt;g1&gt;</bpt>{n : Nat}<ept i="1">&lt;/g1&gt;</ept> appear after the colon, because it cannot
be held fixed throughout the definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145544Z" creationid="tlqk3" creationdate="20220604T145544Z">
        <seg>인수<bpt i="1" x="1">&lt;g1&gt;</bpt>{n : Nat}<ept i="1">&lt;/g1&gt;</ept> 은 콜론 뒤에 나타납니다. 왜냐하면 이것은 정의 전체에 대해 고정될 수 없기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The argument <bpt i="3" x="3">&lt;g3&gt;</bpt>α : Type<ept i="3">&lt;/g3&gt;</ept>
is a parameter and occurs before the colon to indicate it does not participate in the pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163822Z" creationid="tlqk3" creationdate="20220529T163822Z">
        <seg>인수 <bpt i="3" x="3">&lt;g3&gt;</bpt>α : Type<ept i="3">&lt;/g3&gt;</ept>은 매개변수이고 패턴 매칭에 참여하지 않음을 지칭하는 콜론 앞에 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The attribute can also be applied any time after the theorem is declared:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171556Z" creationid="tlqk35" creationdate="20220524T165001Z">
        <seg>이 특성은 정리가 선언된 이후 언제든지 적용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The automatically generated definitions for indexed
families are far from straightforward.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T184037Z" creationid="tlqk3" creationdate="20220603T184037Z">
        <seg>인덱스된 군을 위한 자동적으로 생성된 정의는 직관과는 거리가 멉니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The classical axioms also give you access to additional patterns of
proof that can be justified by appeal to <bpt i="1" x="1">&lt;g1&gt;</bpt>em<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165913Z" creationid="tlqk35" creationdate="20220321T165852Z">
        <seg>고전적 공리도 여러분에게 <bpt i="1" x="1">&lt;g1&gt;</bpt>em<ept i="1">&lt;/g1&gt;</ept>에 호소하여 정당화될 수 있는 추가적인 증명 패턴의 접근을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The collection is interrupted by nested parentheses.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140339Z" creationid="tlqk3" creationdate="20220526T140339Z">
        <seg>모음은 중첩된 괄호에 의해 중단됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The combinator <bpt i="1" x="1">&lt;g1&gt;</bpt>focus t<ept i="1">&lt;/g1&gt;</ept> ensures that <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept> only effects the current
goal, temporarily hiding the others from the scope.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172118Z" creationid="tlqk35" creationdate="20220524T152951Z">
        <seg>결합자 <bpt i="1" x="1">&lt;g1&gt;</bpt>focus t<ept i="1">&lt;/g1&gt;</ept>은 일시적으로 범위로부터 다른 것들을 숨겨 <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept>가 오직 현재 목표에만 영향을 끼침을 보장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The command
<bpt i="4" x="4">&lt;g4&gt;</bpt>namespace foo<ept i="4">&lt;/g4&gt;</ept> causes <bpt i="5" x="5">&lt;g5&gt;</bpt>foo<ept i="5">&lt;/g5&gt;</ept> to be prepended to the name of each
definition and theorem until <bpt i="6" x="6">&lt;g6&gt;</bpt>end foo<ept i="6">&lt;/g6&gt;</ept> is encountered.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180339Z" creationid="tlqk35" creationdate="20220524T175824Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>namespace foo<ept i="4">&lt;/g4&gt;</ept> 명령은  <bpt i="6" x="6">&lt;g6&gt;</bpt>end foo<ept i="6">&lt;/g6&gt;</ept>와 마추치기 전까지 <bpt i="5" x="5">&lt;g5&gt;</bpt>foo<ept i="5">&lt;/g5&gt;</ept>가 각 정의와 정리의 이름에 앞에 붙게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The command
<bpt i="7" x="7">&lt;g7&gt;</bpt>open foo<ept i="7">&lt;/g7&gt;</ept> then creates temporary <bpt i="8" x="8">&lt;g8&gt;</bpt>aliases<ept i="8">&lt;/g8&gt;</ept> to definitions and
theorems that begin with prefix <bpt i="9" x="9">&lt;g9&gt;</bpt>foo<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180329Z" creationid="tlqk35" creationdate="20220524T180021Z">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>open foo<ept i="7">&lt;/g7&gt;</ept> 명령은 접두사 <bpt i="9" x="9">&lt;g9&gt;</bpt>foo<ept i="9">&lt;/g9&gt;</ept>로 시작하는 정의와 정리에 일시적인 <bpt i="8" x="8">&lt;g8&gt;</bpt>별명<ept i="8">&lt;/g8&gt;</ept>으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The command <bpt i="1" x="1">&lt;g1&gt;</bpt>open List<ept i="1">&lt;/g1&gt;</ept> allows you to use the shorter names:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150528Z" creationid="tlqk35" creationdate="20220321T150528Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>open List<ept i="1">&lt;/g1&gt;</ept> 명령은 여러분이 더 짧은 이름을 사용할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The command <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option pp.all true<ept i="1">&lt;/g1&gt;</ept> carries out these settings all
at once, whereas <bpt i="2" x="2">&lt;g2&gt;</bpt>set_option pp.all false<ept i="2">&lt;/g2&gt;</ept> reverts to the previous
values.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130152Z" creationid="tlqk3" creationdate="20220526T130152Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>set_option pp.all true<ept i="1">&lt;/g1&gt;</ept> 명령은 이 설정을 한번에 수행합니다. 반면 <bpt i="2" x="2">&lt;g2&gt;</bpt>set_option pp.all false<ept i="2">&lt;/g2&gt;</ept>은 이전의 값으로 되돌립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The connective <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept> has a single elimination rule,
<bpt i="2" x="2">&lt;g2&gt;</bpt>False.elim<ept i="2">&lt;/g2&gt;</ept>, which expresses the fact that anything follows from a
contradiction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164351Z" creationid="tlqk35" creationdate="20220321T164351Z">
        <seg>연결사 <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept>은 하나의 제거 규칙 <bpt i="2" x="2">&lt;g2&gt;</bpt>False.elim<ept i="2">&lt;/g2&gt;</ept>을 갖습니다. 이것은 모순으로부터 어떤 것이든 도출된다는 사실을 표현합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The constructors, <bpt i="1" x="1">&lt;g1&gt;</bpt>even_zero<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>even_succ<ept i="2">&lt;/g2&gt;</ept>, and <bpt i="3" x="3">&lt;g3&gt;</bpt>odd_succ<ept i="3">&lt;/g3&gt;</ept> provide positive means for showing that a number is even or odd.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174551Z" creationid="tlqk3" creationdate="20220603T174551Z">
        <seg>생성자 <bpt i="1" x="1">&lt;g1&gt;</bpt>even_zero<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>even_succ<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>odd_succ<ept i="3">&lt;/g3&gt;</ept>은 수가 짝수인지 홀수인지 보이는데 긍정적인 수단을 제공한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The course-of-values recursion is implemented by <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat.brecOn<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165008Z" creationid="tlqk3" creationdate="20220603T164419Z">
        <seg>course-of-values 재귀는 <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat.brecOn<ept i="5">&lt;/g5&gt;</ept>로 구현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The defining equation for <bpt i="1" x="1">&lt;g1&gt;</bpt>div<ept i="1">&lt;/g1&gt;</ept> does <bpt i="2" x="2">&lt;g2&gt;</bpt>not<ept i="2">&lt;/g2&gt;</ept> hold definitionally, but
the equation is available to <bpt i="3" x="3">&lt;g3&gt;</bpt>rewrite<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172430Z" creationid="tlqk3" creationdate="20220603T172430Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>div<ept i="1">&lt;/g1&gt;</ept> 로 방정식을 정의하는 것은 정의로부터 성립하지 <bpt i="2" x="2">&lt;g2&gt;</bpt>않습니다.<ept i="2">&lt;/g2&gt;</ept> 그래도 방정식은 <bpt i="3" x="3">&lt;g3&gt;</bpt>rewrite<ept i="3">&lt;/g3&gt;</ept>와 <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept>를 사용할 수 있습니다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The definition is somewhat inscrutable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171046Z" creationid="tlqk3" creationdate="20220603T171046Z">
        <seg>정의는 무언가 헤아리기가 어렵습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The definition of <bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept> does not have to declare <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> as an
argument; Lean detects the dependence and inserts it
automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175209Z" creationid="tlqk35" creationdate="20220524T175209Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept>의 정의는 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>를 인수로서 정의할 필요가 없습니다.
린은 종속성을 감지하고 그것을 자동적으로 삽입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The definition of <bpt i="1" x="1">&lt;g1&gt;</bpt>yellow<ept i="1">&lt;/g1&gt;</ept> forms the record with the three values
shown, and the projection <bpt i="2" x="2">&lt;g2&gt;</bpt>Color.red<ept i="2">&lt;/g2&gt;</ept> returns the red component.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145459Z" creationid="tlqk3" creationdate="20220527T145459Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>yellow<ept i="1">&lt;/g1&gt;</ept>의 정의는 제시한 세 값의 레코드를 형성합니다. 그리고 투영 <bpt i="2" x="2">&lt;g2&gt;</bpt>Color.red<ept i="2">&lt;/g2&gt;</ept>은 빨간색 성분을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The definitions and theorems in Lean's standard library are spread
across multiple files.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173657Z" creationid="tlqk35" creationdate="20220524T173657Z">
        <seg>린의 정의와 정리 표준 라이브러리는 다수의 파일에 걸쳐 펴져있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The definitions of <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>And<ept i="3">&lt;/g3&gt;</ept>, and <bpt i="4" x="4">&lt;g4&gt;</bpt>Or<ept i="4">&lt;/g4&gt;</ept> are
perfectly analogous to the definitions of <bpt i="5" x="5">&lt;g5&gt;</bpt>Empty<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>Unit<ept i="6">&lt;/g6&gt;</ept>,
<bpt i="7" x="7">&lt;g7&gt;</bpt>Prod<ept i="7">&lt;/g7&gt;</ept>, and <bpt i="8" x="8">&lt;g8&gt;</bpt>Sum<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T152847Z" creationid="tlqk3" creationdate="20220527T152847Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>False<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>And<ept i="3">&lt;/g3&gt;</ept>그리고 <bpt i="4" x="4">&lt;g4&gt;</bpt>Or<ept i="4">&lt;/g4&gt;</ept>의 정의는 완전히 <bpt i="5" x="5">&lt;g5&gt;</bpt>Empty<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>Unit<ept i="6">&lt;/g6&gt;</ept>,
<bpt i="7" x="7">&lt;g7&gt;</bpt>Prod<ept i="7">&lt;/g7&gt;</ept>과 <bpt i="8" x="8">&lt;g8&gt;</bpt>Sum<ept i="8">&lt;/g8&gt;</ept>의 정의와 유사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference between <bpt i="3" x="3">&lt;g3&gt;</bpt>let<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>have<ept i="4">&lt;/g4&gt;</ept> is that
<bpt i="5" x="5">&lt;g5&gt;</bpt>let<ept i="5">&lt;/g5&gt;</ept> introduces a local definition in the context, so that the
definition of the local declaration can be unfolded in the proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144703Z" creationid="tlqk35" creationdate="20220524T144703Z">
        <seg> <bpt i="3" x="3">&lt;g3&gt;</bpt>let<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>have<ept i="4">&lt;/g4&gt;</ept> 사이의 차이는 <bpt i="5" x="5">&lt;g5&gt;</bpt>let<ept i="5">&lt;/g5&gt;</ept>은 맥락 속에 지역 정의를 도입하여 
지역 선언의 정의가 증명속에 접힌채로 될 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference is that
given <bpt i="1" x="1">&lt;g1&gt;</bpt>a : α<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>h : p a<ept i="2">&lt;/g2&gt;</ept>, the term <bpt i="3" x="3">&lt;g3&gt;</bpt>Exists.intro a h<ept i="3">&lt;/g3&gt;</ept> has
type <bpt i="4" x="4">&lt;g4&gt;</bpt>(∃ x : α, p x) : Prop<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>Sigma.mk a h<ept i="5">&lt;/g5&gt;</ept> has type
<bpt i="6" x="6">&lt;g6&gt;</bpt>(Σ x : α, p x) : Type<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181721Z" creationid="tlqk35" creationdate="20220321T181721Z">
        <seg>차이점은 <bpt i="1" x="1">&lt;g1&gt;</bpt>a : α<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>h : p a<ept i="2">&lt;/g2&gt;</ept>에 대해서 항 <bpt i="3" x="3">&lt;g3&gt;</bpt>Exists.intro a h<ept i="3">&lt;/g3&gt;</ept>은 e <bpt i="4" x="4">&lt;g4&gt;</bpt>(∃ x : α, p x) : Prop<ept i="4">&lt;/g4&gt;</ept> 형을 가지고 <bpt i="5" x="5">&lt;g5&gt;</bpt>Sigma.mk a h<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>(Σ x : α, p x) : Type<ept i="6">&lt;/g6&gt;</ept>형을 갖는다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difference is that the first group yields
elements of <bpt i="9" x="9">&lt;g9&gt;</bpt>Prop<ept i="9">&lt;/g9&gt;</ept>, and the second yields elements of <bpt i="10" x="10">&lt;g10&gt;</bpt>Type u<ept i="10">&lt;/g10&gt;</ept> for
some <bpt i="11" x="11">&lt;g11&gt;</bpt>u<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T152951Z" creationid="tlqk3" creationdate="20220527T152951Z">
        <seg>차이점은 첫 번째 그룹은 <bpt i="9" x="9">&lt;g9&gt;</bpt>Prop<ept i="9">&lt;/g9&gt;</ept>의 원소를 얻고 두 번째 그룹은 어떤 <bpt i="11" x="11">&lt;g11&gt;</bpt>u<ept i="11">&lt;/g11&gt;</ept>에 대한 <bpt i="10" x="10">&lt;g10&gt;</bpt>Type u<ept i="10">&lt;/g10&gt;</ept> 의 원소를 얻는다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The difficulty in defining <bpt i="1" x="1">&lt;g1&gt;</bpt>tail<ept i="1">&lt;/g1&gt;</ept> is to maintain the relationships between the indices.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183617Z" creationid="tlqk3" creationdate="20220603T183617Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>tail<ept i="1">&lt;/g1&gt;</ept>을 정의하는데 어려움은 인덱스 사이의 관계를 유지해야 한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The dot notation is convenient not just for accessing the projections
of a record, but also for applying functions defined in a namespace
with the same name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174503Z" creationid="tlqk35" creationdate="20220528T174503Z">
        <seg>점 기호는 레코드의 투영에 접근하는데에만 편리한 게 아니라 같은 이름인 이름공간에 정의된 함수를 적용하는데에도 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elimination principle generated by Lean is as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T153959Z" creationid="tlqk35" creationdate="20220528T153959Z">
        <seg>린에 의해 생성된 제거 원리는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elimination principle, <bpt i="5" x="5">&lt;g5&gt;</bpt>Weekday.rec<ept i="5">&lt;/g5&gt;</ept>, is defined
along with the type <bpt i="6" x="6">&lt;g6&gt;</bpt>Weekday<ept i="6">&lt;/g6&gt;</ept> and its constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T145810Z" creationid="tlqk3" creationdate="20220526T145810Z">
        <seg>제거 규칙  <bpt i="5" x="5">&lt;g5&gt;</bpt>Weekday.rec<ept i="5">&lt;/g5&gt;</ept>은 <bpt i="6" x="6">&lt;g6&gt;</bpt>Weekday<ept i="6">&lt;/g6&gt;</ept>형과 그것의 생성자를 따라 정의되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The elimination rule states:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172924Z" creationid="tlqk35" creationdate="20220321T172924Z">
        <seg>제거 규칙은 이와 같이 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation
compiler generates such theorems internally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173101Z" creationid="tlqk3" creationdate="20220529T173101Z">
        <seg>방정식 컴파일러는 그런 정리를 내부적으로 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation
compiler in and of itself is not clever enough to derive that <bpt i="2" x="2">&lt;g2&gt;</bpt>x -
y<ept i="2">&lt;/g2&gt;</ept> is less than <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept> under the given hypotheses, but we can help it
out by putting this fact in the local context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172220Z" creationid="tlqk3" creationdate="20220603T172212Z">
        <seg>방정식 컴파일러의 속과 그 자체는 주어진 가정 하에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>x -y<ept i="2">&lt;/g2&gt;</ept>가 <bpt i="3" x="3">&lt;g3&gt;</bpt>x<ept i="3">&lt;/g3&gt;</ept>보다 작다는 것을 유도할만큼 영리하지 않습니다. 그러나 우리는 그것을 지역 맥락에 이 사실을 넣음으로써 도울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler
looks in the local context for such information, and, when it finds
it, puts it to good use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172313Z" creationid="tlqk3" creationdate="20220603T172313Z">
        <seg>방정식 컴파일러는 그런 정보에 대해 지역 맥락에서 보고 그것을 찾을 때 사용하기 좋게 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler
tries to ensure that this holds whenever possible, as is the case with
straightforward structural induction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172804Z" creationid="tlqk3" creationdate="20220529T172804Z">
        <seg>방정식 컴파일러는 직관적인 구조적 재귀와 같은 한 언제든 이것이 성립함을 보장하려고 시도합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler can process multiple arguments sequentially.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162851Z" creationid="tlqk3" creationdate="20220529T162851Z">
        <seg>이 방정식 컴파일러는 다수의 인수를 순차적으로 처리할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler first splits on cases as to whether the input is
<bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept> or of the form <bpt i="2" x="2">&lt;g2&gt;</bpt>succ x<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161958Z" creationid="tlqk3" creationdate="20220529T161958Z">
        <seg>방정식 컴파일러는 우선 입력이 <bpt i="1" x="1">&lt;g1&gt;</bpt>zero<ept i="1">&lt;/g1&gt;</ept>인지 <bpt i="2" x="2">&lt;g2&gt;</bpt>succ x<ept i="2">&lt;/g2&gt;</ept>의 꼴인지에 따라 경우를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler is clever.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170053Z" creationid="tlqk3" creationdate="20220529T170053Z">
        <seg>방정식 컴파일러는 영리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equation compiler is designed to make definitions like this more
convenient.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171624Z" creationid="tlqk3" creationdate="20220603T171624Z">
        <seg>방정식 컴파일러는 이 같은 정의를 만드는 데 더 편리하도록 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The equations used to define these function hold definitionally:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161255Z" creationid="tlqk3" creationdate="20220529T161255Z">
        <seg>방정식들은 정의상으로 성립하는 이 함수들을 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example above demonstrates how type classes are used to overload notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155114Z" creationid="tlqk3" creationdate="20220604T155114Z">
        <seg>위의 예제는 어떻게 유형 클래스가 기호를 중복(overload)시키는데 사용되는지 시연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example above shows
that <bpt i="12" x="12">&lt;g12&gt;</bpt>Nat.add 3<ept i="12">&lt;/g12&gt;</ept> has type <bpt i="13" x="13">&lt;g13&gt;</bpt>Nat → Nat<ept i="13">&lt;/g13&gt;</ept>, that is, <bpt i="14" x="14">&lt;g14&gt;</bpt>Nat.add 3<ept i="14">&lt;/g14&gt;</ept> returns a
function that "waits" for a second argument, <bpt i="15" x="15">&lt;g15&gt;</bpt>n<ept i="15">&lt;/g15&gt;</ept>, which is then
equivalent to writing <bpt i="16" x="16">&lt;g16&gt;</bpt>Nat.add 3 n<ept i="16">&lt;/g16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185245Z" creationid="tlqk35" creationdate="20220321T140932Z">
        <seg>위의 예제에서 <bpt i="12" x="12">&lt;g12&gt;</bpt>Nat.add 3<ept i="12">&lt;/g12&gt;</ept>는 <bpt i="13" x="13">&lt;g13&gt;</bpt>Nat → Nat<ept i="13">&lt;/g13&gt;</ept>유형을 가짐을  보였습니다. 즉 <bpt i="14" x="14">&lt;g14&gt;</bpt>Nat.add 3<ept i="14">&lt;/g14&gt;</ept>은 두번째 인자 <bpt i="15" x="15">&lt;g15&gt;</bpt>n<ept i="15">&lt;/g15&gt;</ept>을 "기다리는" 함수를 반환하는 것입니다. 이것은 <bpt i="16" x="16">&lt;g16&gt;</bpt>Nat.add 3 n<ept i="16">&lt;/g16&gt;</ept>로 쓰는 것과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The example above shows that the defining equations for <bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept> hold
definitionally, and the same is true of <bpt i="2" x="2">&lt;g2&gt;</bpt>mul<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172548Z" creationid="tlqk3" creationdate="20220529T172548Z">
        <seg>위 예제에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>add<ept i="1">&lt;/g1&gt;</ept>에 대해 정의한 방정식은 정의로부터 성립함을 보여줍니다. 그리고 <bpt i="2" x="2">&lt;g2&gt;</bpt>mul<ept i="2">&lt;/g2&gt;</ept>에서 같은 방식으로 참이 됨을 보입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The existential
elimination rule, <bpt i="2" x="2">&lt;g2&gt;</bpt>Exists.elim<ept i="2">&lt;/g2&gt;</ept>, performs the opposite operation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181209Z" creationid="tlqk35" creationdate="20220321T181209Z">
        <seg>존재 한정기호 제거 규칙 <bpt i="2" x="2">&lt;g2&gt;</bpt>Exists.elim<ept i="2">&lt;/g2&gt;</ept>은 정반대 연산을 수행합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression
<bpt i="1" x="1">&lt;g1&gt;</bpt>fun x : Nat =&gt; x<ept i="1">&lt;/g1&gt;</ept> denotes the identity function on <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept>, the
expression <bpt i="3" x="3">&lt;g3&gt;</bpt>fun x : Nat =&gt; true<ept i="3">&lt;/g3&gt;</ept> denotes the constant function that
always returns <bpt i="4" x="4">&lt;g4&gt;</bpt>true<ept i="4">&lt;/g4&gt;</ept>, and <bpt i="5" x="5">&lt;g5&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="5">&lt;/g5&gt;</ept> denotes the
composition of <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>g<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142738Z" creationid="tlqk35" creationdate="20220321T142738Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>fun x : Nat =&gt; x<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat<ept i="2">&lt;/g2&gt;</ept>에 대한 항등함수를 의미합니다. 표현식 <bpt i="3" x="3">&lt;g3&gt;</bpt>fun x : Nat =&gt; true<ept i="3">&lt;/g3&gt;</ept>은 항상  <bpt i="4" x="4">&lt;g4&gt;</bpt>true<ept i="4">&lt;/g4&gt;</ept>을 반환하는 상수함수를 가리합니다. 그리고 <bpt i="5" x="5">&lt;g5&gt;</bpt>fun x : Nat =&gt; g (f x)<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept>와 <bpt i="7" x="7">&lt;g7&gt;</bpt>g<ept i="7">&lt;/g7&gt;</ept>의 합성함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;g1&gt;</bpt>And.intro h1 h2<ept i="1">&lt;/g1&gt;</ept> builds a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q<ept i="2">&lt;/g2&gt;</ept> using
proofs <bpt i="3" x="3">&lt;g3&gt;</bpt>h1 : p<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>h2 : q<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162538Z" creationid="tlqk35" creationdate="20220321T162538Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>And.intro h1 h2<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∧ q<ept i="2">&lt;/g2&gt;</ept>의 증명을 <bpt i="3" x="3">&lt;g3&gt;</bpt>h1 : p<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>h2 : q<ept i="4">&lt;/g4&gt;</ept>의 증명을 사용하여 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;g1&gt;</bpt>And.left h<ept i="1">&lt;/g1&gt;</ept> creates a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> from a proof
<bpt i="3" x="3">&lt;g3&gt;</bpt>h : p ∧ q<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162748Z" creationid="tlqk35" creationdate="20220321T162748Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>And.left h<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="3" x="3">&lt;g3&gt;</bpt>h : p ∧ q<ept i="3">&lt;/g3&gt;</ept>의 증명으로부터 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>의 증명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;g1&gt;</bpt>Iff.intro h1 h2<ept i="1">&lt;/g1&gt;</ept> produces a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>p ↔ q<ept i="2">&lt;/g2&gt;</ept> from
<bpt i="3" x="3">&lt;g3&gt;</bpt>h1 : p → q<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>h2 : q → p<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164648Z" creationid="tlqk35" creationdate="20220321T164648Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>Iff.intro h1 h2<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>h1 : p → q<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>h2 : q → p<ept i="4">&lt;/g4&gt;</ept>으로부터  <bpt i="2" x="2">&lt;g2&gt;</bpt>p ↔ q<ept i="2">&lt;/g2&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;g1&gt;</bpt>Or.intro_left q hp<ept i="1">&lt;/g1&gt;</ept> creates a proof of <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∨ q<ept i="2">&lt;/g2&gt;</ept>
from a proof <bpt i="3" x="3">&lt;g3&gt;</bpt>hp : p<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163602Z" creationid="tlqk35" creationdate="20220321T163602Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>Or.intro_left q hp<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>hp : p<ept i="3">&lt;/g3&gt;</ept>의 증명으로부터 <bpt i="2" x="2">&lt;g2&gt;</bpt>p ∨ q<ept i="2">&lt;/g2&gt;</ept>의 증명을 만듭니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="1" x="1">&lt;g1&gt;</bpt>decide p<ept i="1">&lt;/g1&gt;</ept> tries to infer a
decision procedure for <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>, and, if it is successful, evaluates to
either <bpt i="3" x="3">&lt;g3&gt;</bpt>true<ept i="3">&lt;/g3&gt;</ept> or <bpt i="4" x="4">&lt;g4&gt;</bpt>false<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174814Z" creationid="tlqk3" creationdate="20220604T174814Z">
        <seg>표현식 <bpt i="1" x="1">&lt;g1&gt;</bpt>decide p<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>에 대한 결정 절차를 추론하려고 하고, 성공하면 <bpt i="3" x="3">&lt;g3&gt;</bpt>true<ept i="3">&lt;/g3&gt;</ept>나 <bpt i="4" x="4">&lt;g4&gt;</bpt>false <ept i="4">&lt;/g4&gt;</ept>로 평가됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="2" x="2">&lt;g2&gt;</bpt>let a := t1; t2<ept i="2">&lt;/g2&gt;</ept> is
definitionally equal to the result of replacing every occurrence of
<bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> in <bpt i="4" x="4">&lt;g4&gt;</bpt>t2<ept i="4">&lt;/g4&gt;</ept> by <bpt i="5" x="5">&lt;g5&gt;</bpt>t1<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144755Z" creationid="tlqk35" creationdate="20220321T144755Z">
        <seg>표현식 <bpt i="2" x="2">&lt;g2&gt;</bpt>let a := t1; t2<ept i="2">&lt;/g2&gt;</ept> 는 <bpt i="4" x="4">&lt;g4&gt;</bpt>t2<ept i="4">&lt;/g4&gt;</ept>  속 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>의 모든 나타남(occurrence)을 <bpt i="5" x="5">&lt;g5&gt;</bpt>t1<ept i="5">&lt;/g5&gt;</ept>으로 대체한 결과에 대해 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="5" x="5">&lt;g5&gt;</bpt>Iff.mp h<ept i="5">&lt;/g5&gt;</ept>
produces a proof of <bpt i="6" x="6">&lt;g6&gt;</bpt>p → q<ept i="6">&lt;/g6&gt;</ept> from <bpt i="7" x="7">&lt;g7&gt;</bpt>h : p ↔ q<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164712Z" creationid="tlqk35" creationdate="20220321T164712Z">
        <seg>표현식 <bpt i="5" x="5">&lt;g5&gt;</bpt>Iff.mp h<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="7" x="7">&lt;g7&gt;</bpt>h : p ↔ q<ept i="7">&lt;/g7&gt;</ept>으로부터 <bpt i="6" x="6">&lt;g6&gt;</bpt>p → q<ept i="6">&lt;/g6&gt;</ept>의 증명을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The expression <bpt i="8" x="8">&lt;g8&gt;</bpt>p.add q<ept i="8">&lt;/g8&gt;</ept> is therefore
shorthand for <bpt i="9" x="9">&lt;g9&gt;</bpt>Point.add p q<ept i="9">&lt;/g9&gt;</ept> in the example below.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174808Z" creationid="tlqk35" creationdate="20220528T174808Z">
        <seg>표현식 <bpt i="8" x="8">&lt;g8&gt;</bpt>p.add q<ept i="8">&lt;/g8&gt;</ept>는 그러므로 아래 예제에서 <bpt i="9" x="9">&lt;g9&gt;</bpt>Point.add p q<ept i="9">&lt;/g9&gt;</ept>에 대한 축약 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The fact that the rules for implication in a
proof system for natural deduction correspond exactly to the rules
governing abstraction and application for functions is an instance of
the <bpt i="1" x="1">&lt;g1&gt;</bpt>Curry-Howard isomorphism<ept i="1">&lt;/g1&gt;</ept>, sometimes known as the
<bpt i="2" x="2">&lt;g2&gt;</bpt>propositions-as-types<ept i="2">&lt;/g2&gt;</ept> paradigm.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155714Z" creationid="tlqk35" creationdate="20220321T155714Z">
        <seg>자연 추론을 위한 증명 보조기에서 함의에 대한 규칙이 함수 추상화와 함수 적용을 지배하는 규칙과 정확히 일치한다는 사실은 <bpt i="1" x="1">&lt;g1&gt;</bpt>커리-하워드 동형론(Curry-Howard isomorphism) <ept i="1">&lt;/g1&gt;</ept>의 한 예이며, 때때로 <bpt i="2" x="2">&lt;g2&gt;</bpt>유형으로써 명제(propositions-as-types)<ept i="2">&lt;/g2&gt;</ept> 패러다임으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first character <bpt i="3" x="3">&lt;g3&gt;</bpt>|<ept i="3">&lt;/g3&gt;</ept> in an inductive
declaration is optional.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T142937Z" creationid="tlqk3" creationdate="20220526T142937Z">
        <seg>유도 선언에서 첫 문자 <bpt i="3" x="3">&lt;g3&gt;</bpt>|<ept i="3">&lt;/g3&gt;</ept>은 선택적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first element, <bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept>, is commonly known as the "head" of the list,
and the remainder, <bpt i="6" x="6">&lt;g6&gt;</bpt>t<ept i="6">&lt;/g6&gt;</ept>, is known as the "tail."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163233Z" creationid="tlqk3" creationdate="20220527T163233Z">
        <seg>첫 원소 <bpt i="5" x="5">&lt;g5&gt;</bpt>h<ept i="5">&lt;/g5&gt;</ept>는 흔히 리스트의 "헤드"로 알려져 있고 나머지 <bpt i="6" x="6">&lt;g6&gt;</bpt>t<ept i="6">&lt;/g6&gt;</ept>는 "테일"이라고 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first function returns a type
<bpt i="6" x="6">&lt;g6&gt;</bpt>γ<ept i="6">&lt;/g6&gt;</ept> so that is also the return type of the <bpt i="7" x="7">&lt;g7&gt;</bpt>compose<ept i="7">&lt;/g7&gt;</ept> function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144609Z" creationid="tlqk35" creationdate="20220321T144609Z">
        <seg>첫 번째 함수는 유형 <bpt i="6" x="6">&lt;g6&gt;</bpt>γ<ept i="6">&lt;/g6&gt;</ept> 를 반환하여 이게 <bpt i="7" x="7">&lt;g7&gt;</bpt>compose<ept i="7">&lt;/g7&gt;</ept> 함수의 반환형이 되게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first goal is met with the command <bpt i="1" x="1">&lt;g1&gt;</bpt>exact hp<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T054825Z" creationid="tlqk35" creationdate="20220522T054825Z">
        <seg>첫 번째 목표는 <bpt i="1" x="1">&lt;g1&gt;</bpt>exact hp<ept i="1">&lt;/g1&gt;</ept>명령으로 달성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first instance of the tactic adds <bpt i="1" x="1">&lt;g1&gt;</bpt>h' : succ m = succ n<ept i="1">&lt;/g1&gt;</ept> to the
context, and the second adds <bpt i="2" x="2">&lt;g2&gt;</bpt>h'' : m = n<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172947Z" creationid="tlqk3" creationdate="20220527T172947Z">
        <seg>전략의 첫번째 개체는 <bpt i="1" x="1">&lt;g1&gt;</bpt>h' : succ m = succ n<ept i="1">&lt;/g1&gt;</ept>을 맥락에 추가합니다. 그리고 두번째 개체 <bpt i="2" x="2">&lt;g2&gt;</bpt>h'' : m = n<ept i="2">&lt;/g2&gt;</ept>을 추가합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first is to run it from the web: a Javascript version of Lean, a standard
library of definitions and theorems, and an editor are actually downloaded to your browser and run there.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131828Z" creationid="tlqk35" creationdate="20220321T131828Z">
        <seg>첫째는 웹으로부터 이것을 실행하는 것입니다.(Lean의 자바스크립트 버전, 정의와 정리들의 표준 라이브러리, 편집자는 실제로 여러분의 브라우저에 다운로드를 시키고 거기서 실행하는 것임)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first is used to construct a pair, whereas the next two,
<bpt i="1" x="1">&lt;g1&gt;</bpt>Prod.fst<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod.snd<ept i="2">&lt;/g2&gt;</ept>, project the two elements.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T133024Z" creationid="tlqk3" creationdate="20220526T133024Z">
        <seg>첫 째는 쌍을 구성하는데 사용되며 반면 다음 둘은<bpt i="1" x="1">&lt;g1&gt;</bpt>Prod.fst<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prod.snd<ept i="2">&lt;/g2&gt;</ept>은 두 원소를 투영(project)합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first one is the homogeneous
multiplication for natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164217Z" creationid="tlqk3" creationdate="20220604T164217Z">
        <seg>처음 것은 자연수에 대한 동형 곱셈입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first step, <bpt i="1" x="1">&lt;g1&gt;</bpt>rw [Nat.add_zero] at h<ept i="1">&lt;/g1&gt;</ept>, rewrites the hypothesis <bpt i="2" x="2">&lt;g2&gt;</bpt>a + 0 = 0<ept i="2">&lt;/g2&gt;</ept> to <bpt i="3" x="3">&lt;g3&gt;</bpt>a = 0<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171833Z" creationid="tlqk35" creationdate="20220524T160308Z">
        <seg>첫 단계는 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw [Nat.add_zero] at h<ept i="1">&lt;/g1&gt;</ept>는 가정 <bpt i="2" x="2">&lt;g2&gt;</bpt>a + 0 = 0<ept i="2">&lt;/g2&gt;</ept>을 <bpt i="3" x="3">&lt;g3&gt;</bpt>a = 0<ept i="3">&lt;/g3&gt;</ept>으로 다시 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first tactic in the <bpt i="1" x="1">&lt;g1&gt;</bpt>by<ept i="1">&lt;/g1&gt;</ept> block below repeatedly splits
conjunctions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T152742Z" creationid="tlqk35" creationdate="20220524T152742Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>by<ept i="1">&lt;/g1&gt;</ept> 블럭 아래에 첫 번째 전략은 반복적으로 결합자를 나눕니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first version of this book was
written for Lean 2, and the Lean 3 version is is available
<bpt i="3" x="3">&lt;g3&gt;</bpt>here<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171622Z" creationid="tlqk35" creationdate="20220321T171622Z">
        <seg>이 책의 첫 번째 버전은 Lean 2을 위해 쓰였습니다. Lean 3 버전도 <bpt i="3" x="3">&lt;g3&gt;</bpt>여기서<ept i="3">&lt;/g3&gt;</ept> 이용 가능합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The first, <bpt i="1" x="1">&lt;g1&gt;</bpt>Acc<ept i="1">&lt;/g1&gt;</ept>, is an inductively defined predicate.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173930Z" creationid="tlqk3" creationdate="20220529T173930Z">
        <seg>우선 <bpt i="1" x="1">&lt;g1&gt;</bpt>Acc<ept i="1">&lt;/g1&gt;</ept>은 귀납적으로 정의된 술어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following calls a given function twice passing the output of the
first invocation to the second:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144414Z" creationid="tlqk35" creationdate="20220321T144414Z">
        <seg>다음은 주어진 함수를 첫번째 호출의 출력을 두번째에 전달하는 것으로 두 번 호출합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following code block shows the current target
after each line.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182517Z" creationid="tlqk3" creationdate="20220604T182517Z">
        <seg>다음 코드 블록은 각 줄 뒤에 있는 현재 대상을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following command produces the error
"failed to create type class instance for <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited (Nat × ?m.1499)<ept i="3">&lt;/g3&gt;</ept>" because the type has a missing part (i.e., the <bpt i="4" x="4">&lt;g4&gt;</bpt>_<ept i="4">&lt;/g4&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163405Z" creationid="tlqk3" creationdate="20220604T163405Z">
        <seg>다음 명령은 "<bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited (Nat × ?m.1499)<ept i="3">&lt;/g3&gt;</ept>에 대한 유형 클래스 개체를 생성하는데 실패했다(failed to create type class instance for <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited (Nat × ?m.1499)<ept i="3">&lt;/g3&gt;</ept>)"는 오류를 일으킵니다. 왜냐하면 유형에 모르는 부분(즉, <bpt i="4" x="4">&lt;g4&gt;</bpt>_<ept i="4">&lt;/g4&gt;</ept>)이 있기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following definition</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180122Z" creationid="tlqk35" creationdate="20220524T180033Z">
        <seg>다음 정의  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines
the <bpt i="2" x="2">&lt;g2&gt;</bpt>tail<ept i="2">&lt;/g2&gt;</ept> function using pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163649Z" creationid="tlqk3" creationdate="20220529T163649Z">
        <seg>다음 예제는 패턴 매칭을 사용해 <bpt i="2" x="2">&lt;g2&gt;</bpt>tail<ept i="2">&lt;/g2&gt;</ept> 함수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example defines the prefix relation on lists,
proves that this relation is reflexive, and assigns the <bpt i="3" x="3">&lt;g3&gt;</bpt>[simp]<ept i="3">&lt;/g3&gt;</ept> attribute to that theorem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T183037Z" creationid="tlqk3" creationdate="20220525T182849Z">
        <seg>다음 예제에서는 리스트에 대한 접두사 관계를 정의하고, 이 관계는 반사적임을 증명하고, 그 정리에 <bpt i="3" x="3">&lt;g3&gt;</bpt>[simp]<ept i="3">&lt;/g3&gt;</ept> 특성을 부여합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example demonstrates
both approaches.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170043Z" creationid="tlqk3" creationdate="20220529T170043Z">
        <seg>다음 예제는 두 접근법을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example illustrates how this
is done:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181719Z" creationid="tlqk3" creationdate="20220604T181719Z">
        <seg>다음 예제는 이것이 어떻게 이뤄지는지 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example is similar: it converts any natural number to a
binary expression, represented as a list of 0's and 1's.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172628Z" creationid="tlqk3" creationdate="20220603T172628Z">
        <seg>다음 예제는 이것이 어떤 자연수를 이진 표현식으로 바꾸고 0과 1의 리스트로 나타낸다는 점에서 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example uses the <bpt i="1" x="1">&lt;g1&gt;</bpt>intros<ept i="1">&lt;/g1&gt;</ept> command to introduce the three variables and two hypotheses automatically:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063054Z" creationid="tlqk35" creationdate="20220522T063054Z">
        <seg>다음 예제는 <bpt i="1" x="1">&lt;g1&gt;</bpt>intros<ept i="1">&lt;/g1&gt;</ept> 명령을 사용해 세 개의 변수와 두 개의 가정을 자동으로 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following example, we declare an inductive type that defines the
property of "being in the image of <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>".</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T144108Z" creationid="tlqk3" creationdate="20220604T144108Z">
        <seg>다음 예제에서 우리는 "<bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>의 이미지에 있음" 속성을 정의하는 귀납형을 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following is a more natural example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143211Z" creationid="tlqk35" creationdate="20220524T143211Z">
        <seg>다음은 더 자연스러운 예제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following is a shorter version of the preceding
proof:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060622Z" creationid="tlqk35" creationdate="20220522T060622Z">
        <seg>다음은 이전의 증명보다 더 짧은 버전의 증명입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following is a somewhat toy example:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143156Z" creationid="tlqk35" creationdate="20220524T143156Z">
        <seg>다음은 약간 간단한 예제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following is a structured
version of our first tactic proof in this chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061249Z" creationid="tlqk35" creationdate="20220522T061249Z">
        <seg>다음은 이 장의 첫번째 우리의 전략 증명의 구조화된 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following list includes a number of common identities.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170122Z" creationid="tlqk35" creationdate="20220321T170122Z">
        <seg>다음 리스트는 흔히 사용되는 항등식들을 포함합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following options take an input of true or false:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125949Z" creationid="tlqk3" creationdate="20220526T125928Z">
        <seg>다음 옵션은 입력으로 참 혹은 거짓을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The following yields the same result:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144033Z" creationid="tlqk35" creationdate="20220321T144033Z">
        <seg>다음은 같은 결과를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The full list of axioms that are used in Lean to support classical
reasoning are discussed in <bpt i="1" x="1">&lt;g1&gt;</bpt>Axioms and Computations<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170049Z" creationid="tlqk35" creationdate="20220321T170049Z">
        <seg>고전 추론을 지원하기 위해 린에서 사용된 모든 공리의 리스트는 <bpt i="1" x="1">&lt;g1&gt;</bpt>공리와 계산<ept i="1">&lt;/g1&gt;</ept>에서 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function
<bpt i="3" x="3">&lt;g3&gt;</bpt>WellFounded.fix<ept i="3">&lt;/g3&gt;</ept> is another tool Lean uses to justify that a function
terminates.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T170212Z" creationid="tlqk3" creationdate="20220603T170212Z">
        <seg>함수 <bpt i="3" x="3">&lt;g3&gt;</bpt>WellFounded.fix<ept i="3">&lt;/g3&gt;</ept>은 린이 함수 종료를 정당화하는데 사용하는 또 다른 도구입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function <bpt i="1" x="1">&lt;g1&gt;</bpt>fst<ept i="1">&lt;/g1&gt;</ept> takes a pair, <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153441Z" creationid="tlqk3" creationdate="20220526T153441Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>fst<ept i="1">&lt;/g1&gt;</ept> 함수는 쌍 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>를 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function <bpt i="7" x="7">&lt;g7&gt;</bpt>Prod<ept i="7">&lt;/g7&gt;</ept> is
similarly polymorphic:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142043Z" creationid="tlqk35" creationdate="20220321T142043Z">
        <seg>마찬가지로 <bpt i="7" x="7">&lt;g7&gt;</bpt>Prod<ept i="7">&lt;/g7&gt;</ept> 함수는 다형적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The function <bpt i="7" x="7">&lt;g7&gt;</bpt>prod_example<ept i="7">&lt;/g7&gt;</ept> takes a pair consisting of a boolean,
<bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>, and a number, <bpt i="9" x="9">&lt;g9&gt;</bpt>n<ept i="9">&lt;/g9&gt;</ept>, and returns either <bpt i="10" x="10">&lt;g10&gt;</bpt>2 * n<ept i="10">&lt;/g10&gt;</ept> or <bpt i="11" x="11">&lt;g11&gt;</bpt>2 * n + 1<ept i="11">&lt;/g11&gt;</ept>
according to whether <bpt i="12" x="12">&lt;g12&gt;</bpt>b<ept i="12">&lt;/g12&gt;</ept> is true or false.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T154635Z" creationid="tlqk3" creationdate="20220526T154635Z">
        <seg>함수 <bpt i="7" x="7">&lt;g7&gt;</bpt>prod_example<ept i="7">&lt;/g7&gt;</ept>은 불리언형 <bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>과 자연수형 <bpt i="9" x="9">&lt;g9&gt;</bpt>n<ept i="9">&lt;/g9&gt;</ept>을 받고 <bpt i="10" x="10">&lt;g10&gt;</bpt>2 * n<ept i="10">&lt;/g10&gt;</ept>나 <bpt i="11" x="11">&lt;g11&gt;</bpt>2 * n + 1<ept i="11">&lt;/g11&gt;</ept> 둘 중의 하나를 <bpt i="12" x="12">&lt;g12&gt;</bpt>b<ept i="12">&lt;/g12&gt;</ept> 가 참인지 거짓인지에 따라 출력하는 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The functions <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>g<ept i="2">&lt;/g2&gt;</ept> above denote the same function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152345Z" creationid="tlqk35" creationdate="20220321T152345Z">
        <seg>위 함수  <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>g<ept i="2">&lt;/g2&gt;</ept>는 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The functions <bpt i="6" x="6">&lt;g6&gt;</bpt>prod.fst<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>prod.snd<ept i="7">&lt;/g7&gt;</ept>, which return the
first and second elements of a pair, are examples of such projections.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173026Z" creationid="tlqk35" creationdate="20220528T173026Z">
        <seg>순서쌍의 첫 번째와 두 번째 원소를 반환하는 함수 <bpt i="6" x="6">&lt;g6&gt;</bpt>prod.fst<ept i="6">&lt;/g6&gt;</ept>와 <bpt i="7" x="7">&lt;g7&gt;</bpt>prod.snd<ept i="7">&lt;/g7&gt;</ept>는 그런 투영의 예입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The general form is as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173640Z" creationid="tlqk35" creationdate="20220528T173640Z">
        <seg>일반적인 형태는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The general form of a definition is <bpt i="1" x="1">&lt;g1&gt;</bpt>def foo : α := bar<ept i="1">&lt;/g1&gt;</ept> where
<bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> is the type returned from the expression <bpt i="3" x="3">&lt;g3&gt;</bpt>bar<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144127Z" creationid="tlqk35" creationdate="20220321T144127Z">
        <seg>정의의 일반적인 형태는  <bpt i="1" x="1">&lt;g1&gt;</bpt>def foo : α := bar<ept i="1">&lt;/g1&gt;</ept>입니다. 여기서  <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> 는 식 <bpt i="3" x="3">&lt;g3&gt;</bpt>bar<ept i="3">&lt;/g3&gt;</ept>로부터 반환되는 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The general form of a lambda expression is <bpt i="1" x="1">&lt;g1&gt;</bpt>fun x : α =&gt; t<ept i="1">&lt;/g1&gt;</ept>, where
the variable <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> is a "bound variable": it is really a placeholder,
whose "scope" does not extend beyond the expression <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143328Z" creationid="tlqk35" creationdate="20220321T143328Z">
        <seg>람다 표현식의 일반적인 형태는 <bpt i="1" x="1">&lt;g1&gt;</bpt>fun x : α =&gt; t<ept i="1">&lt;/g1&gt;</ept>입니다. 여기서 변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>는 "구속변수"입니다. 이는 그것의 "범위"가 표현식  <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept> 안으로 제한되는 '자리차지자'일 뿐 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify
claims in both domains.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131543Z" creationid="tlqk35" creationdate="20220321T131543Z">
        <seg>목표는 수학적 추론과 복잡한 시스템에 대한 추론을 모두 지원하고 양쪽 영역의 주장을 식별하게 만드는 겁이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The goal of Lean's front end is to interpret user input, construct
formal expressions, and check that they are well formed and type
correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173445Z" creationid="tlqk35" creationdate="20220524T173445Z">
        <seg>린의 프론트 엔드의 목표는 사용자의 입력을 해석하고 형식적인 표현을 만들고 그들이 잘 형성되었고 옳바른 유형인지 확인하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic
show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of
foundational systems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131234Z" creationid="tlqk35" creationdate="20220321T131234Z">
        <seg>수학 진술을 지지하기 위한 황금률은 증명을 제공하는 것이며 20세기 논리학의 발전은 기존은 몇 가지의 공리의 모임과 기초계의 몇 가지 규칙으로 축소될 수 있음을 거의 보여주었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The hypothesis <bpt i="2" x="2">&lt;g2&gt;</bpt>e : m = n + 1<ept i="2">&lt;/g2&gt;</ept> in <bpt i="3" x="3">&lt;g3&gt;</bpt>tailAux<ept i="3">&lt;/g3&gt;</ept> is used to communicate the relationship
between <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept> and the index associated with the minor premise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183709Z" creationid="tlqk3" creationdate="20220603T183709Z">
        <seg> <bpt i="3" x="3">&lt;g3&gt;</bpt>tailAux<ept i="3">&lt;/g3&gt;</ept>의 가정 <bpt i="2" x="2">&lt;g2&gt;</bpt>e : m = n + 1<ept i="2">&lt;/g2&gt;</ept>은 <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>과 작은 전제와 연관된 인덱스 사이의 관계를 소통하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is
that <bpt i="1" x="1">&lt;g1&gt;</bpt>var n<ept i="1">&lt;/g1&gt;</ept> is a variable, <bpt i="2" x="2">&lt;g2&gt;</bpt>vₙ<ept i="2">&lt;/g2&gt;</ept>, and <bpt i="3" x="3">&lt;g3&gt;</bpt>const n<ept i="3">&lt;/g3&gt;</ept> is the
constant whose value is <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181818Z" creationid="tlqk3" creationdate="20220603T181818Z">
        <seg>이해를 돕자면 <bpt i="1" x="1">&lt;g1&gt;</bpt>var n<ept i="1">&lt;/g1&gt;</ept>는 변수, <bpt i="2" x="2">&lt;g2&gt;</bpt>vₙ<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>const n<ept i="3">&lt;/g3&gt;</ept>은 값이 <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>인 상수이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is
that they are structurally smaller, and hence appear in the inductive
type at an earlier stage.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172147Z" creationid="tlqk3" creationdate="20220529T172147Z">
        <seg>아이디어는 이들이 구조적으로 더 작고 그러므로 앞 단에서 귀납형으로 나타날 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is
that we can define two (or more) inductive types at the same time,
where each one refers to the other(s).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152353Z" creationid="tlqk35" creationdate="20220528T165132Z">
        <seg>아이디어는 각각이 서로 다른 이들을 참조하면서 우리가 둘(혹은 그 이상의) 귀납형을 동시에 정의할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is
that we can prove <bpt i="2" x="2">&lt;g2&gt;</bpt>r<ept i="2">&lt;/g2&gt;</ept> from <bpt i="3" x="3">&lt;g3&gt;</bpt>p ∨ q<ept i="3">&lt;/g3&gt;</ept>, by showing that <bpt i="4" x="4">&lt;g4&gt;</bpt>r<ept i="4">&lt;/g4&gt;</ept> follows
from <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept> and that <bpt i="6" x="6">&lt;g6&gt;</bpt>r<ept i="6">&lt;/g6&gt;</ept> follows from <bpt i="7" x="7">&lt;g7&gt;</bpt>q<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163752Z" creationid="tlqk35" creationdate="20220321T163752Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>r<ept i="4">&lt;/g4&gt;</ept>이 <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>로부터 나오고 <bpt i="6" x="6">&lt;g6&gt;</bpt>r<ept i="6">&lt;/g6&gt;</ept>이 <bpt i="7" x="7">&lt;g7&gt;</bpt>q<ept i="7">&lt;/g7&gt;</ept>로부터 나온다는 것을 보임으로써 우리가 <bpt i="3" x="3">&lt;g3&gt;</bpt>p ∨ q<ept i="3">&lt;/g3&gt;</ept>로부터 <bpt i="2" x="2">&lt;g2&gt;</bpt>r<ept i="2">&lt;/g2&gt;</ept>을 증명할 수 있다는 생각입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is as follows.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174605Z" creationid="tlqk35" creationdate="20220321T174605Z">
        <seg>아이디어는 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The idea is to return <bpt i="2" x="2">&lt;g2&gt;</bpt>some a<ept i="2">&lt;/g2&gt;</ept> for the provided patterns, and use
<bpt i="3" x="3">&lt;g3&gt;</bpt>none<ept i="3">&lt;/g3&gt;</ept> for the incomplete cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165957Z" creationid="tlqk3" creationdate="20220529T165957Z">
        <seg>이 아이디어는 제공받은 패턴에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>some a<ept i="2">&lt;/g2&gt;</ept>를 반환하는 것입니다. 그리고 불완전한 경우에 대해 <bpt i="3" x="3">&lt;g3&gt;</bpt>none<ept i="3">&lt;/g3&gt;</ept>을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The implicit argument, <bpt i="1" x="1">&lt;g1&gt;</bpt>motive<ept i="1">&lt;/g1&gt;</ept>, is the codomain of the function being defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155408Z" creationid="tlqk3" creationdate="20220527T155408Z">
        <seg>암시적 인수 <bpt i="1" x="1">&lt;g1&gt;</bpt>motive<ept i="1">&lt;/g1&gt;</ept>는 정의될 함수와 공동 영역입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The impredicativity of Prop means that we
can form propositions that quantify over <bpt i="5" x="5">&lt;g5&gt;</bpt>α → Prop<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175235Z" creationid="tlqk35" creationdate="20220321T175235Z">
        <seg>Prop의 비서술어는 우리가 <bpt i="5" x="5">&lt;g5&gt;</bpt>α → Prop<ept i="5">&lt;/g5&gt;</ept>를 한정하는 명제를 세울 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The inaccessible pattern <bpt i="1" x="1">&lt;g1&gt;</bpt>.(_)<ept i="1">&lt;/g1&gt;</ept> can be written as <bpt i="2" x="2">&lt;g2&gt;</bpt>_<ept i="2">&lt;/g2&gt;</ept> for convenience.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T150800Z" creationid="tlqk3" creationdate="20220604T150800Z">
        <seg>접근 불가한 패턴 <bpt i="1" x="1">&lt;g1&gt;</bpt>.(_)<ept i="1">&lt;/g1&gt;</ept>은 편의상 <bpt i="2" x="2">&lt;g2&gt;</bpt>_<ept i="2">&lt;/g2&gt;</ept>로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The inductively defined types we have seen so far are "flat":
constructors wrap data and insert it into a type, and the
corresponding recursor unpacks the data and acts on it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153813Z" creationid="tlqk3" creationdate="20220527T153813Z">
        <seg>우리가 지금까지 본 재귀적으로 정의된 유형은 "평평"합니다. 생성자는 데이터를 변형해서 유형에 그것을 삽입하고, 그에 대응하는 재귀자는 데이터를 풀고 그것에 작용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The inscription <bpt i="1" x="1">&lt;g1&gt;</bpt>.{u}<ept i="1">&lt;/g1&gt;</ept> tells Lean to instantiate the constants at the universe <bpt i="2" x="2">&lt;g2&gt;</bpt>u<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175555Z" creationid="tlqk35" creationdate="20220321T175555Z">
        <seg>접두사 <bpt i="1" x="1">&lt;g1&gt;</bpt>.{u}<ept i="1">&lt;/g1&gt;</ept>은 린에게 세계변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>u<ept i="2">&lt;/g2&gt;</ept>로 상수를 개체화하라고 말해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance <bpt i="1" x="1">&lt;g1&gt;</bpt>HMul<ept i="1">&lt;/g1&gt;</ept> is not synthesized by Lean because the type of <bpt i="2" x="2">&lt;g2&gt;</bpt>y<ept i="2">&lt;/g2&gt;</ept> has not been provided.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164848Z" creationid="tlqk3" creationdate="20220604T164848Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>y<ept i="2">&lt;/g2&gt;</ept>형으로 제공되지 않았으므로 개체 <bpt i="1" x="1">&lt;g1&gt;</bpt>HMul<ept i="1">&lt;/g1&gt;</ept>은 린으로부터 생성되지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The instance <bpt i="7" x="7">&lt;g7&gt;</bpt>OfNat Nat n<ept i="7">&lt;/g7&gt;</ept> is the default instance (with priority 100) for the <bpt i="8" x="8">&lt;g8&gt;</bpt>OfNat<ept i="8">&lt;/g8&gt;</ept> class.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165422Z" creationid="tlqk3" creationdate="20220604T165422Z">
        <seg>개체 <bpt i="7" x="7">&lt;g7&gt;</bpt>OfNat Nat n<ept i="7">&lt;/g7&gt;</ept>은 <bpt i="8" x="8">&lt;g8&gt;</bpt>OfNat<ept i="8">&lt;/g8&gt;</ept> 클래스에 대한 (우선순위 100의) 기본 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The internally defined function takes, as argument, an element of a sum type, either an input to <bpt i="5" x="5">&lt;g5&gt;</bpt>even<ept i="5">&lt;/g5&gt;</ept>, or an input to <bpt i="6" x="6">&lt;g6&gt;</bpt>odd<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174007Z" creationid="tlqk3" creationdate="20220603T174007Z">
        <seg>내부적으로 정의된 함수는 인수로써 <bpt i="5" x="5">&lt;g5&gt;</bpt>even<ept i="5">&lt;/g5&gt;</ept>의 입력으로나 <bpt i="6" x="6">&lt;g6&gt;</bpt>odd<ept i="6">&lt;/g6&gt;</ept>의 입력으로 합 유형의 원소로 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The internals are meant to be hidden from users; the canonical way to make use of such definitions is to use <bpt i="7" x="7">&lt;g7&gt;</bpt>rewrite<ept i="7">&lt;/g7&gt;</ept> or <bpt i="8" x="8">&lt;g8&gt;</bpt>simp<ept i="8">&lt;/g8&gt;</ept>, as we did above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174208Z" creationid="tlqk3" creationdate="20220603T174208Z">
        <seg>내부는 사용자로부터 숨겨지도록 의도되었습니다. 그런 정의를 만들어 사용하는 정식 방법은 <bpt i="7" x="7">&lt;g7&gt;</bpt>rewrite<ept i="7">&lt;/g7&gt;</ept>나 <bpt i="8" x="8">&lt;g8&gt;</bpt>simp<ept i="8">&lt;/g8&gt;</ept>를 우리가 위에서 했던 것처럼 사용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The interpretation of schematic patterns is the first step of the
compilation process.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160640Z" creationid="tlqk3" creationdate="20220529T160640Z">
        <seg>도식적인 패턴의 해석은 컴파일 과정의 첫 단계입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The introduction and elimination rules we have seen so far are all
constructive, which is to say, they reflect a computational
understanding of the logical connectives based on the
propositions-as-types correspondence.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165648Z" creationid="tlqk35" creationdate="20220321T165648Z">
        <seg>지금까지 우리가 본 도입과 제거 규칙은 모두 직관적입니다. 그 말은 그들은 유형으로써 명제 대응에 기반한 논리 연결사의 계산적인 이해를 반영하고 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The introduction rule is
straightforward: to prove <bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p x<ept i="1">&lt;/g1&gt;</ept>, it suffices to provide a
suitable term <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept> and a proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>p t<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180911Z" creationid="tlqk35" creationdate="20220321T180911Z">
        <seg>도입 규칙은 직관적입니다. <bpt i="1" x="1">&lt;g1&gt;</bpt>∃ x : α, p x<ept i="1">&lt;/g1&gt;</ept>을 증명하기 위해 적절한 항 <bpt i="2" x="2">&lt;g2&gt;</bpt>t<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>p t<ept i="3">&lt;/g3&gt;</ept>의 증명을 제공하는 것으로 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The intuition is that an inductive
type is exhaustively generated by the constructors, and has no
elements beyond those they construct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151940Z" creationid="tlqk3" creationdate="20220526T150231Z">
        <seg>직관적인 설명은 귀납형은 생성자에 의해 철저히 생성된다는 점입니다. 그래서 이들 없이 생긴 원소는 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The intuition is that each constructor specifies a way of building new
objects of <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept>, possibly from previously constructed values.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T142725Z" creationid="tlqk3" creationdate="20220526T142725Z">
        <seg>직관적인 설명은 아마 이전에 구성된 값으로부터 각 생성자가 <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept>의 새로운 대상을 만드는 방식을 지정한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The intuition is that in this case the
elimination does not make use of any information that is not already
given by the mere fact that the type of argument is inhabited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T163733Z" creationid="tlqk35" creationdate="20220528T163733Z">
        <seg>이 경우에 대한 직관적인 설명은 제거가 단순히 인수 유형이 존재한다는 사실에 의해 이미 제공되는 정보를 쓰지 않는다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The judicious use of Unicode improves
legibility, and all modern editors have great support for it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140114Z" creationid="tlqk35" creationdate="20220321T140114Z">
        <seg>분별있는 유니코드의 사용은 가독성을 개선합니다. 그리고 현대의 모든 편집기는 그것의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last chapter introduced you to methods that construct proofs of
statements involving the propositional connectives.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172547Z" creationid="tlqk35" creationdate="20220321T172547Z">
        <seg>지난 장에서 여러분에게 명제적 연결사를 포함한 문장의 증명을 구성하는 방법을 소개했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last expression, for example, denotes the function that takes
three types, <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept>, and <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept>, and two functions, <bpt i="4" x="4">&lt;g4&gt;</bpt>g : β → γ<ept i="4">&lt;/g4&gt;</ept>
and <bpt i="5" x="5">&lt;g5&gt;</bpt>f : α → β<ept i="5">&lt;/g5&gt;</ept>, and returns the composition of <bpt i="6" x="6">&lt;g6&gt;</bpt>g<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>f<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143241Z" creationid="tlqk35" creationdate="20220321T143241Z">
        <seg>마지막 표현식은 세 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept>과 두 함수 <bpt i="4" x="4">&lt;g4&gt;</bpt>g : β → γ<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="5" x="5">&lt;g5&gt;</bpt>f : α → β<ept i="5">&lt;/g5&gt;</ept>을 받고 <bpt i="6" x="6">&lt;g6&gt;</bpt>g<ept i="6">&lt;/g6&gt;</ept>과 <bpt i="7" x="7">&lt;g7&gt;</bpt>f<ept i="7">&lt;/g7&gt;</ept>의 합성을 반환하는 함수를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last two theorems show that the definitions preserve the value.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180218Z" creationid="tlqk3" creationdate="20220603T180218Z">
        <seg>마지막 두 정리는 정의가 값을 보존함을 보이는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The last,
<bpt i="3" x="3">&lt;g3&gt;</bpt>Prod.rec<ept i="3">&lt;/g3&gt;</ept>, provides another mechanism for defining functions on a
product in terms of a function on the two components.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T133757Z" creationid="tlqk3" creationdate="20220526T133757Z">
        <seg>마지막으로 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prod.rec<ept i="3">&lt;/g3&gt;</ept>은 두 원소에 대한 함수에 대한 관점으로 곱에 대한 함수를 정의하는 또다른 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The letter "f" is for "French," since the unicode
symbols can also be used as French quotation marks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183508Z" creationid="tlqk35" creationdate="20220321T183508Z">
        <seg>"f"는 "프랑스"의 첫머리 글자입니다. 왜냐하면 이 유니코드 기호는 프랑스 인용부호로도 사용되기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The list is indefinite, so
that there is a <bpt i="6" x="6">&lt;g6&gt;</bpt>Type n<ept i="6">&lt;/g6&gt;</ept> for every natural number <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141719Z" creationid="tlqk35" creationdate="20220321T141719Z">
        <seg>모든 자연수 <bpt i="6" x="6">&lt;g6&gt;</bpt>n<ept i="6">&lt;/g6&gt;</ept>에 대해 <bpt i="7" x="7">&lt;g7&gt;</bpt>Type n<ept i="7">&lt;/g7&gt;</ept>가 있어서 이런 리스트를 무한히 나열할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The list of subtrees is represented by the type <bpt i="3" x="3">&lt;g3&gt;</bpt>TreeList α<ept i="3">&lt;/g3&gt;</ept>,
which is defined to be either the empty list, <bpt i="4" x="4">&lt;g4&gt;</bpt>nil<ept i="4">&lt;/g4&gt;</ept>, or the
<bpt i="5" x="5">&lt;g5&gt;</bpt>cons<ept i="5">&lt;/g5&gt;</ept> of a tree and an element of <bpt i="6" x="6">&lt;g6&gt;</bpt>TreeList α<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T165935Z" creationid="tlqk35" creationdate="20220528T165935Z">
        <seg>하위 트리의 리스트는 <bpt i="3" x="3">&lt;g3&gt;</bpt>TreeList α<ept i="3">&lt;/g3&gt;</ept>형으로 표현됩니다. 이것은 빈 리스트 <bpt i="4" x="4">&lt;g4&gt;</bpt>nil<ept i="4">&lt;/g4&gt;</ept>이거나 트리의 <bpt i="5" x="5">&lt;g5&gt;</bpt>cons<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>TreeList α<ept i="6">&lt;/g6&gt;</ept>의 원소로 정의될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The macro <bpt i="5" x="5">&lt;g5&gt;</bpt>h ▸ e<ept i="5">&lt;/g5&gt;</ept> uses more effective heuristics for computing
this implicit parameter, and often succeeds in situations where
applying <bpt i="6" x="6">&lt;g6&gt;</bpt>Eq.subst<ept i="6">&lt;/g6&gt;</ept> fails.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180148Z" creationid="tlqk35" creationdate="20220321T180148Z">
        <seg>매크로 <bpt i="5" x="5">&lt;g5&gt;</bpt>h ▸ e<ept i="5">&lt;/g5&gt;</ept>은 이 암시적 인자를 계산하는데 더욱 효과적인 경험론을 사용합니다. 그리고 종종 <bpt i="6" x="6">&lt;g6&gt;</bpt>Eq.subst<ept i="6">&lt;/g6&gt;</ept>의 적용이 실패하는 상황에서 성공적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The main function of Lean is to translate user input to formal
expressions that are checked by the kernel for correctness and then
stored in the environment for later use.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181833Z" creationid="tlqk3" creationdate="20220525T181833Z">
        <seg>린의 주요 기능은 사용자의 입력을 커널에 의해 올바름이 검증된 형식 표현식으로 번역하는 것과 나중에 사용할 수 있도록 환경에 저장해두는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The main idea behind type classes is to make arguments such as <bpt i="1" x="1">&lt;g1&gt;</bpt>Add a<ept i="1">&lt;/g1&gt;</ept> implicit,
and to use a database of user-defined instances to synthesize the desired instances
automatically through a process known as typeclass resolution.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153933Z" creationid="tlqk3" creationdate="20220604T153933Z">
        <seg>유형 클래스 뒤편의 주요 아이디어는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Add a<ept i="1">&lt;/g1&gt;</ept> 같은 인수를 암시적으로 만드는 것이고 사용자 정의 개체들의 데이터베이스를 사용해 유형 클래스 해결책으로 알려진 과정을 통해 원하는 개체를 자동적으로 합성하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The mnemonic in the notation above is that you are generalizing the
goal by setting <bpt i="1" x="1">&lt;g1&gt;</bpt>3<ept i="1">&lt;/g1&gt;</ept> to an arbitrary variable <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065006Z" creationid="tlqk35" creationdate="20220522T065006Z">
        <seg>위의 표기에 대한 기억법은 여러분이 <bpt i="1" x="1">&lt;g1&gt;</bpt>3<ept i="1">&lt;/g1&gt;</ept>으로 설정한 목표을 임의의 변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>로 일반화시키는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most basic form of the
tactic is <bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite [t]<ept i="2">&lt;/g2&gt;</ept>, where <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept> is a term whose type asserts an
equality.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T153620Z" creationid="tlqk35" creationdate="20220524T153620Z">
        <seg>전략의 가장 기본적인 형태는 <bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite [t]<ept i="2">&lt;/g2&gt;</ept>입니다. 
여기서 <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>는 동등석을 주장하는 유형의 항입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The most basic syntax extension commands allow introducing new (or
overloading existing) prefix, infix, and postfix operators.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T121539Z" creationid="tlqk3" creationdate="20220526T121539Z">
        <seg>가장 기본적인 문법 확장 명령은 새로운 (혹은 이미 있는 것을 오버로딩하는 것) 전위, 중위 그리고 후위 연산자를 도입하는 것을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The motivation is to
ensure your tactic proofs do not rely on automatically generated names, and are consequently more robust.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063300Z" creationid="tlqk35" creationdate="20220522T063247Z">
        <seg>그 이유는 여러분의 전략 증명이 자동으로 생성된 이름에 의존하지 않도록 보장하기 위함입니다. 그리고 그 결과로 증명은 더 튼튼하게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The naive
first attempt is to enter tactic mode and try <bpt i="2" x="2">&lt;g2&gt;</bpt>rw [Nat.mul_comm]<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182310Z" creationid="tlqk3" creationdate="20220604T182310Z">
        <seg>첫 순진한 시도는 전략 모드로 들어가 <bpt i="2" x="2">&lt;g2&gt;</bpt>rw [Nat.mul_comm]<ept i="2">&lt;/g2&gt;</ept>을 시도하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The naive first attempt is to enter tactic mode and try
<bpt i="2" x="2">&lt;g2&gt;</bpt>rw [zero_add]<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183032Z" creationid="tlqk3" creationdate="20220604T183032Z">
        <seg>첫 순진한 시도는 전략 모드로 들어가 <bpt i="2" x="2">&lt;g2&gt;</bpt>rw [zero_add]<ept i="2">&lt;/g2&gt;</ept>를 시도하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The name <bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept> is defined as a
function that takes an input parameter <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept> of type <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept>, where the
result of the call is <bpt i="4" x="4">&lt;g4&gt;</bpt>x + x<ept i="4">&lt;/g4&gt;</ept>, so it is returning type <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143946Z" creationid="tlqk35" creationdate="20220321T143946Z">
        <seg>이름 <bpt i="1" x="1">&lt;g1&gt;</bpt>double<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat<ept i="3">&lt;/g3&gt;</ept> 유형의 입력 매개변수 <bpt i="2" x="2">&lt;g2&gt;</bpt>x<ept i="2">&lt;/g2&gt;</ept>를 받고  호출의 결과로 <bpt i="4" x="4">&lt;g4&gt;</bpt>x + x<ept i="4">&lt;/g4&gt;</ept>인 함수로 정의되었습니다. 그래서 <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat<ept i="5">&lt;/g5&gt;</ept> 유형을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The native version is much faster than
the web version, and is more flexible in other ways, too.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131909Z" creationid="tlqk35" creationdate="20220321T131909Z">
        <seg>원본 버전은 웹 버전보다 더 빠르고 다른 방식보다 유연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new notation is preferred to the binary notation since the latter,
before chaining, would stop parsing after <bpt i="1" x="1">&lt;g1&gt;</bpt>1 + 2<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T124058Z" creationid="tlqk3" creationdate="20220526T124058Z">
        <seg>새로운 기호는 이항기호로 정의되길 선호합니다. 왜냐면 뒤에 나올 것은 연결되기 전에 <bpt i="1" x="1">&lt;g1&gt;</bpt>1 + 2<ept i="1">&lt;/g1&gt;</ept> 뒤에 분석을 멈춥니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The new subgoals can be solved in any order.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070437Z" creationid="tlqk35" creationdate="20220522T070437Z">
        <seg>새로운 하위 목표는 임의의 순서로 풀릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next
section offers syntax that allow you to write calculational proofs in
a more natural and perspicuous way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180201Z" creationid="tlqk35" creationdate="20220321T180201Z">
        <seg>다음 섹션은 여러분이 계산 증명을 더 자연스럽고 안목이 있는 방향으로 작성하게 하는 문법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example simplifies all the hypotheses, and then uses them to prove the goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171642Z" creationid="tlqk35" creationdate="20220524T164111Z">
        <seg>다음 예제는 모든 가정을 단순화하고 그 후 이들로 목표를 증명하는데 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example simply permutes the last two lines in
the previous proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165230Z" creationid="tlqk35" creationdate="20220321T165230Z">
        <seg>다음 예제는 이전 증명에서 마지막 두 줄을 단순히 바꾼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next example uses both these rules to produce a
proof of <bpt i="9" x="9">&lt;g9&gt;</bpt>(p → q) → ¬q → ¬p<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164305Z" creationid="tlqk35" creationdate="20220321T164305Z">
        <seg>다음 예제는 <bpt i="9" x="9">&lt;g9&gt;</bpt>(p → q) → ¬q → ¬p<ept i="9">&lt;/g9&gt;</ept>의 증명을 만들기 위해 세 가지 규칙 모두를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next two arguments specify how to compute the zero and successor cases, as described above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155625Z" creationid="tlqk3" creationdate="20220527T155625Z">
        <seg>다음 두 인수는 위에서 설명한 0과 계승자에 대한 경우를 어떻게 계산하는지를 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The next two examples instead apply associativity to
move the parenthesis to the right on both sides, and then switch <bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>
and <bpt i="9" x="9">&lt;g9&gt;</bpt>c<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171936Z" creationid="tlqk35" creationdate="20220524T155903Z">
        <seg>다음 두 예제는 결합성을 적용하는 대신 괄호를 오른쪽으로 옮깁니다. 그리고 <bpt i="8" x="8">&lt;g8&gt;</bpt>b<ept i="8">&lt;/g8&gt;</ept>와 <bpt i="9" x="9">&lt;g9&gt;</bpt>c<ept i="9">&lt;/g9&gt;</ept>를 교환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The notation
<bpt i="2" x="2">&lt;g2&gt;</bpt>rw [t] at h<ept i="2">&lt;/g2&gt;</ept> applies the rewrite <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept> at hypothesis <bpt i="4" x="4">&lt;g4&gt;</bpt>h<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171837Z" creationid="tlqk35" creationdate="20220524T160214Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>rw [t] at h<ept i="2">&lt;/g2&gt;</ept> 표기는 가정 <bpt i="4" x="4">&lt;g4&gt;</bpt>h<ept i="4">&lt;/g4&gt;</ept>에 <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>에 다시쓰기를 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The notation <bpt i="1" x="1">&lt;g1&gt;</bpt>@[simp]<ept i="1">&lt;/g1&gt;</ept> declares <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse_mk_symm<ept i="2">&lt;/g2&gt;</ept> to have the
<bpt i="3" x="3">&lt;g3&gt;</bpt>[simp]<ept i="3">&lt;/g3&gt;</ept> attribute, and can be spelled out more explicitly:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171549Z" creationid="tlqk35" creationdate="20220524T164926Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>@[simp]<ept i="1">&lt;/g1&gt;</ept>표기는 <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse_mk_symm<ept i="2">&lt;/g2&gt;</ept>가 <bpt i="3" x="3">&lt;g3&gt;</bpt>[simp]<ept i="3">&lt;/g3&gt;</ept> 
특성을 갖고 더 명시적으로 쓸 수 있도록 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The notation <bpt i="1" x="1">&lt;g1&gt;</bpt>{x : α // p x}<ept i="1">&lt;/g1&gt;</ept> is syntactic sugar for <bpt i="2" x="2">&lt;g2&gt;</bpt>Subtype (fun x : α =&gt; p x)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153539Z" creationid="tlqk3" creationdate="20220527T153539Z">
        <seg>기호 <bpt i="1" x="1">&lt;g1&gt;</bpt>{x : α // p x}<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>Subtype (fun x : α =&gt; p x)<ept i="2">&lt;/g2&gt;</ept>에 대한 문법적 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The notation <bpt i="2" x="2">&lt;g2&gt;</bpt>.<ept i="2">&lt;/g2&gt;</ept> is whitespace sensitive and relies on the indentation
to detect whether the tactic block ends.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145116Z" creationid="tlqk35" creationdate="20220524T145116Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>.<ept i="2">&lt;/g2&gt;</ept> 표기는 화이트 스페이스(space key)에 민감하고 전략 블럭의 끝인지 감지하기 위해 인덴트(4개의 빈칸, tab key)에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The notation <bpt i="2" x="2">&lt;g2&gt;</bpt>←t<ept i="2">&lt;/g2&gt;</ept> can be used to instruct the
tactic to use the equality <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept> in the reverse direction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172026Z" creationid="tlqk35" creationdate="20220524T154937Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>←t<ept i="2">&lt;/g2&gt;</ept> 기호는 역방향으로 등식 <bpt i="3" x="3">&lt;g3&gt;</bpt>t<ept i="3">&lt;/g3&gt;</ept>을 사용하도록 전략에게 지시하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The one thing you are missing is a mechanism
for defining new data types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172828Z" creationid="tlqk35" creationdate="20220524T172828Z">
        <seg>한 가지 여러분이 놓친 작동원리는 새로운 데이터 형을 정의하는 것에 대한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The order of operations is as follows: unary negation <bpt i="1" x="1">&lt;g1&gt;</bpt>¬<ept i="1">&lt;/g1&gt;</ept> binds most
strongly, then <bpt i="2" x="2">&lt;g2&gt;</bpt>∧<ept i="2">&lt;/g2&gt;</ept>, then <bpt i="3" x="3">&lt;g3&gt;</bpt>∨<ept i="3">&lt;/g3&gt;</ept>, then <bpt i="4" x="4">&lt;g4&gt;</bpt>→<ept i="4">&lt;/g4&gt;</ept>, and finally <bpt i="5" x="5">&lt;g5&gt;</bpt>↔<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162225Z" creationid="tlqk35" creationdate="20220321T162225Z">
        <seg>연산자의 우선순위는 다음과 같습니다. 일항 부정 <bpt i="1" x="1">&lt;g1&gt;</bpt>¬<ept i="1">&lt;/g1&gt;</ept> 은 가장 강하게 결합하고 그 다음은 <bpt i="2" x="2">&lt;g2&gt;</bpt>∧<ept i="2">&lt;/g2&gt;</ept> 그 다음 <bpt i="3" x="3">&lt;g3&gt;</bpt>∨<ept i="3">&lt;/g3&gt;</ept> 그 다음 <bpt i="4" x="4">&lt;g4&gt;</bpt>→<ept i="4">&lt;/g4&gt;</ept> 그리고 마지막으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>↔<ept i="5">&lt;/g5&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The other propositional connectives are
defined in Lean's library in the file <bpt i="2" x="2">&lt;g2&gt;</bpt>Prelude.core<ept i="2">&lt;/g2&gt;</ept> (see
<bpt i="3" x="3">&lt;g3&gt;</bpt>importing files<ept i="3">&lt;/g3&gt;</ept> for more information on the library
hierarchy), and each connective comes with its canonical introduction
and elimination rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162457Z" creationid="tlqk35" creationdate="20220321T162457Z">
        <seg>다른 명제논리적 연결사들은  린의 라이브러리의 <bpt i="2" x="2">&lt;g2&gt;</bpt>Prelude.core<ept i="2">&lt;/g2&gt;</ept> 파일 속에 정의되 있습니다. (라이브러리 계층에 대한 더 많은 정보를 위해 <bpt i="3" x="3">&lt;g3&gt;</bpt>파일 불러오기<ept i="3">&lt;/g3&gt;</ept>를 보세요.) 그리고 각 연결사들마다 그것의 정식 도입, 제거 규칙이 딸려 나옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output of the
<bpt i="2" x="2">&lt;g2&gt;</bpt>#check<ept i="2">&lt;/g2&gt;</ept> command means that whenever <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept> has type <bpt i="4" x="4">&lt;g4&gt;</bpt>Type n<ept i="4">&lt;/g4&gt;</ept>,
<bpt i="5" x="5">&lt;g5&gt;</bpt>List α<ept i="5">&lt;/g5&gt;</ept> also has type <bpt i="6" x="6">&lt;g6&gt;</bpt>Type n<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142028Z" creationid="tlqk35" creationdate="20220321T142028Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>#check<ept i="2">&lt;/g2&gt;</ept> 명령의 출력은 <bpt i="3" x="3">&lt;g3&gt;</bpt>α<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>Type n<ept i="4">&lt;/g4&gt;</ept>유형을 갖는 한 <bpt i="5" x="5">&lt;g5&gt;</bpt>List α<ept i="5">&lt;/g5&gt;</ept>도 <bpt i="6" x="6">&lt;g6&gt;</bpt>Type n<ept i="6">&lt;/g6&gt;</ept> 유형을 가짐을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The output of the first <bpt i="5" x="5">&lt;g5&gt;</bpt>#check<ept i="5">&lt;/g5&gt;</ept>
command is <bpt i="6" x="6">&lt;g6&gt;</bpt>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3<ept i="6">&lt;/g6&gt;</ept>, indicating
that the implicit arguments are unspecified in this case.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174351Z" creationid="tlqk35" creationdate="20220321T174351Z">
        <seg>처음 <bpt i="5" x="5">&lt;g5&gt;</bpt>#check<ept i="5">&lt;/g5&gt;</ept> 명령의 출력은 <bpt i="6" x="6">&lt;g6&gt;</bpt>r ?m.1 ?m.2 → r ?m.2 ?m.3 → r ?m.1 ?m.3<ept i="6">&lt;/g6&gt;</ept>입니다. 이들은 여기에서 명시되지 않은 암시적 인자들을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The parameter list can be separated like this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144304Z" creationid="tlqk35" creationdate="20220321T144304Z">
        <seg>매개변수 리스트는 이와 같이 나눠 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The parameters <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept> are considered input parameters and <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept> an output one.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164137Z" creationid="tlqk3" creationdate="20220604T163904Z">
        <seg>매개변수 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>β<ept i="2">&lt;/g2&gt;</ept>는 입력 매개변수로 <bpt i="3" x="3">&lt;g3&gt;</bpt>γ<ept i="3">&lt;/g3&gt;</ept>는 출력 매개변수 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The parentheses
around <bpt i="3" x="3">&lt;g3&gt;</bpt>h hq<ept i="3">&lt;/g3&gt;</ept> are not necessary, but we have added them for clarity.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T154419Z" creationid="tlqk35" creationdate="20220524T154419Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>h hq<ept i="3">&lt;/g3&gt;</ept> 주위의 괄호는 필요하지 않습니다만 우리는 명황성을 이해 이들을 추가했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The polymorphic method <bpt i="1" x="1">&lt;g1&gt;</bpt>toString<ept i="1">&lt;/g1&gt;</ept> has type <bpt i="2" x="2">&lt;g2&gt;</bpt>{α : Type u} → [ToString α] → α → String<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161846Z" creationid="tlqk3" creationdate="20220604T161846Z">
        <seg>다형적인 방법 <bpt i="1" x="1">&lt;g1&gt;</bpt>toString<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>{α : Type u} → [ToString α] → α → String<ept i="2">&lt;/g2&gt;</ept>형 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The precedence is a natural number describing how "tightly" an
operator binds to its arguments, encoding the order of operations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122211Z" creationid="tlqk3" creationdate="20220526T122211Z">
        <seg>연산의 순서를 부호화하는 우선순위는 연산자가 그것의 인자와 얼마나 "강력하게" 묶여있는지를 설명하는 자연수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153430Z" creationid="tlqk35" creationdate="20220321T153430Z">
        <seg>암시적 인수의 존재는 현재로는 식의 정확한 의미를 고치기에 정보가 불충분함을 의미할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The previous
examples can therefore be written concisely as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164850Z" creationid="tlqk35" creationdate="20220321T164850Z">
        <seg>그러므로 이전 예제는 다음과 같이 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The previous example can be written as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172036Z" creationid="tlqk35" creationdate="20220524T154605Z">
        <seg>다음 예제는 다음과 같이 쓰일 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The problem goes away if we use weak implicit arguments:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T190406Z" creationid="tlqk3" creationdate="20220525T190406Z">
        <seg>문제는 우리가 약한 암시적인 인수를 사용하면 사라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The process of instantiating these
"holes," or "placeholders," in a term is often known as
<bpt i="1" x="1">&lt;g1&gt;</bpt>elaboration<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153423Z" creationid="tlqk35" creationdate="20220321T153423Z">
        <seg>이런 "구멍" 또는 "플레이스 홀더"의 인스턴스화 과정은 <bpt i="1" x="1">&lt;g1&gt;</bpt>협력(elaboration)<ept i="1">&lt;/g1&gt;</ept>으로 불리기도 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product type has one constructor, <bpt i="3" x="3">&lt;g3&gt;</bpt>Prod.mk<ept i="3">&lt;/g3&gt;</ept>,
which takes two arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153055Z" creationid="tlqk3" creationdate="20220526T153055Z">
        <seg>곱 유형은 하나의 생성자 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prod.mk<ept i="3">&lt;/g3&gt;</ept>를 갖고 있습니다. 이것은 두 인수를 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The product type is a
structure, as is the dependent product (Sigma) type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T172704Z" creationid="tlqk35" creationdate="20220528T172704Z">
        <seg>곱 형은 의존적 곱 (시그마) 형과 마찬가지로 구조체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The projection <bpt i="4" x="4">&lt;g4&gt;</bpt>Inhabited.default<ept i="4">&lt;/g4&gt;</ept> will allow us to "extract" such an element of <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept> from an element of <bpt i="6" x="6">&lt;g6&gt;</bpt>Inhabited a<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160343Z" creationid="tlqk3" creationdate="20220604T160343Z">
        <seg>투영 <bpt i="4" x="4">&lt;g4&gt;</bpt>Inhabited.default<ept i="4">&lt;/g4&gt;</ept>은 <bpt i="6" x="6">&lt;g6&gt;</bpt>Inhabited a<ept i="6">&lt;/g6&gt;</ept>의 원소로부터 <bpt i="5" x="5">&lt;g5&gt;</bpt>a<ept i="5">&lt;/g5&gt;</ept>의 원소 같은 것을 "추출"하도록 해줄 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The proof above
is functionally equivalent to the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T171101Z" creationid="tlqk3" creationdate="20220527T171101Z">
        <seg>위의 증명은 다음과 기능적으로 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The proof of <bpt i="1" x="1">&lt;g1&gt;</bpt>zero_add<ept i="1">&lt;/g1&gt;</ept> makes it clear that proof by induction is
really a form of recursion in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T172430Z" creationid="tlqk3" creationdate="20220529T172430Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>zero_add<ept i="1">&lt;/g1&gt;</ept>의 증명은 귀납적 증명은 실제로 린에서 재귀의 한 형태라는 점을 명확히 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The propositional connectives come with the following notation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161840Z" creationid="tlqk35" creationdate="20220321T161840Z">
        <seg>명제 연결사는 다음 기호로 따라온다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The recursor <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.rec<ept i="1">&lt;/g1&gt;</ept> is also used to define substitution:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154226Z" creationid="tlqk35" creationdate="20220528T154226Z">
        <seg>재귀자 <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.rec<ept i="1">&lt;/g1&gt;</ept>도 대입을 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The requirement is that if the latter is present at all, it
occurs only <bpt i="3" x="3">&lt;g3&gt;</bpt>strictly positively<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T160402Z" creationid="tlqk35" creationdate="20220528T160402Z">
        <seg>요구사항은 만약 후자가 전부 나타났다면 이것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>엄격하게 긍정적으로<ept i="3">&lt;/g3&gt;</ept>만 일어납니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The results are broken down into small steps: <bpt i="1" x="1">&lt;g1&gt;</bpt>th1<ept i="1">&lt;/g1&gt;</ept> shows that a
relation that is reflexive and euclidean is symmetric, and <bpt i="2" x="2">&lt;g2&gt;</bpt>th2<ept i="2">&lt;/g2&gt;</ept>
shows that a relation that is symmetric and euclidean is
transitive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185920Z" creationid="tlqk3" creationdate="20220525T185920Z">
        <seg>결과는 작은 단계들로 나눠집니다. <bpt i="1" x="1">&lt;g1&gt;</bpt>th1<ept i="1">&lt;/g1&gt;</ept>은 반사적이고 유클리디안은 대칭적이다는 관계를 증명하고 <bpt i="2" x="2">&lt;g2&gt;</bpt>th2<ept i="2">&lt;/g2&gt;</ept>은 대칭적이고 유클리디언은 추이적이다는 관계를 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The results of these definitions are essentially the same as the ones given earlier in this section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T160525Z" creationid="tlqk3" creationdate="20220526T160525Z">
        <seg>이 정의의 결과는 본질적으로 이전 섹션에서 제시된 것과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The right hand side <bpt i="1" x="1">&lt;g1&gt;</bpt>bar<ept i="1">&lt;/g1&gt;</ept> can be any expression, not just a lambda.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144213Z" creationid="tlqk35" creationdate="20220321T144213Z">
        <seg>우변 <bpt i="1" x="1">&lt;g1&gt;</bpt>bar<ept i="1">&lt;/g1&gt;</ept>는 lambda뿐만 아니라 어떤 식이든 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The rule <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept> is used to define the following auxiliary rules,
which carry out more explicit substitutions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175832Z" creationid="tlqk35" creationdate="20220321T175832Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept>의 규칙은 더 명백한 대체를 수행하는 다음의 부가적인 규칙을 정의하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second argument is often a variable as in the example above, or a <bpt i="2" x="2">&lt;g2&gt;</bpt>raw<ept i="2">&lt;/g2&gt;</ept> natural number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163030Z" creationid="tlqk3" creationdate="20220604T163030Z">
        <seg>두 번째 인수는 종종 위의 예제의 것처럼 변수이거나 <bpt i="2" x="2">&lt;g2&gt;</bpt>생(raw)<ept i="2">&lt;/g2&gt;</ept> 자연수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second is the scalar multiplication for arrays.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164232Z" creationid="tlqk3" creationdate="20220604T164232Z">
        <seg>두 번째 것은 배열에 대한 스칼라 곱셈입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second main reason to use conversion mode is to rewrite under
binders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182953Z" creationid="tlqk3" creationdate="20220604T182953Z">
        <seg>전환 모드를 사용하는 두 번째 주요 이유는 결합자 아래에서 다시쓰기 위한 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The second way to use Lean is to install and run it natively on your computer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131857Z" creationid="tlqk35" creationdate="20220321T131857Z">
        <seg>Lean을 사용하는 두 번째 방법은 여러분의 컴퓨터에 설치하여 로컬로 실행하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The short explanation is that types can depend on parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150811Z" creationid="tlqk35" creationdate="20220321T150811Z">
        <seg>간단한 설명은 유형이 매개변수에 의존할 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The similarity between <bpt i="7" x="7">&lt;g7&gt;</bpt>∃<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>Σ<ept i="8">&lt;/g8&gt;</ept> is another
instance of the Curry-Howard isomorphism.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181755Z" creationid="tlqk35" creationdate="20220321T181755Z">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>∃<ept i="7">&lt;/g7&gt;</ept>과<bpt i="8" x="8">&lt;g8&gt;</bpt>Σ<ept i="8">&lt;/g8&gt;</ept>의 유사점은 이들이 커리-하워드 동형의 또 다른 개체라는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The similarity between <bpt i="7" x="7">&lt;g7&gt;</bpt>∧<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>×<ept i="8">&lt;/g8&gt;</ept> is another instance
of the Curry-Howard isomorphism, but in contrast to implication and
the function space constructor, <bpt i="9" x="9">&lt;g9&gt;</bpt>∧<ept i="9">&lt;/g9&gt;</ept> and <bpt i="10" x="10">&lt;g10&gt;</bpt>×<ept i="10">&lt;/g10&gt;</ept> are treated separately
in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163016Z" creationid="tlqk35" creationdate="20220321T163016Z">
        <seg><bpt i="7" x="7">&lt;g7&gt;</bpt>∧<ept i="7">&lt;/g7&gt;</ept>과 <bpt i="8" x="8">&lt;g8&gt;</bpt>×<ept i="8">&lt;/g8&gt;</ept>의 유사성은 커리-하워드 동형론의 또다른 예입니다. 그러나 함의와 함수 공간 생성자와는 대조적으로  <bpt i="9" x="9">&lt;g9&gt;</bpt>∧<ept i="9">&lt;/g9&gt;</ept>과 <bpt i="10" x="10">&lt;g10&gt;</bpt>×<ept i="10">&lt;/g10&gt;</ept>은 린에서 별개로 다뤄집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The simplest kind of inductive type is simply a type with a finite, enumerated list of elements.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151926Z" creationid="tlqk3" creationdate="20220526T145214Z">
        <seg>가장 간단한 귀납형은 원소의 리스트를 유한하게 열거한 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The simplifier
will loop if you apply it blindly, but <bpt i="5" x="5">&lt;g5&gt;</bpt>rewrite<ept i="5">&lt;/g5&gt;</ept> will do the trick.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172531Z" creationid="tlqk3" creationdate="20220603T172531Z">
        <seg>단순화기는 여러분이 맹목적으로 적용한다면 무한루프를 돌 것입니다. 그러나 <bpt i="5" x="5">&lt;g5&gt;</bpt>rewrite<ept i="5">&lt;/g5&gt;</ept>는 트릭을 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The simplifier then proves <bpt i="1" x="1">&lt;g1&gt;</bpt>isPrefix [1, 2, 3] [1, 2, 3]<ept i="1">&lt;/g1&gt;</ept> by rewriting it to <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T182954Z" creationid="tlqk3" creationdate="20220525T182954Z">
        <seg>그럼 단순화기는 <bpt i="1" x="1">&lt;g1&gt;</bpt>isPrefix [1, 2, 3] [1, 2, 3]<ept i="1">&lt;/g1&gt;</ept>을 그것이 <bpt i="2" x="2">&lt;g2&gt;</bpt>True<ept i="2">&lt;/g2&gt;</ept>라고 다시쓰기하여 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The simplifier will also do propositional rewriting.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T163741Z" creationid="tlqk35" creationdate="20220524T163741Z">
        <seg>단순화기도 명제 다시쓰기를 할 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The solution is:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183135Z" creationid="tlqk3" creationdate="20220604T183135Z">
        <seg>해결책은</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The source
code, and instructions for building Lean, are available at
<bpt i="1" x="1">&lt;g1&gt;</bpt>https://github.com/leanprover/lean4/<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131946Z" creationid="tlqk35" creationdate="20220321T131946Z">
        <seg>Lean을 만든 소스코드와  명령어들은 <bpt i="1" x="1">&lt;g1&gt;</bpt>https://github.com/leanprover/lean4/<ept i="1">&lt;/g1&gt;</ept>에서 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library also contains a variant of <bpt i="1" x="1">&lt;g1&gt;</bpt>ite<ept i="1">&lt;/g1&gt;</ept> called
<bpt i="2" x="2">&lt;g2&gt;</bpt>dite<ept i="2">&lt;/g2&gt;</ept>, the dependent if-then-else expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172553Z" creationid="tlqk3" creationdate="20220604T172553Z">
        <seg>표준 라이브러리는 또 <bpt i="2" x="2">&lt;g2&gt;</bpt>dite (the dependent if-then-else expression)<ept i="2">&lt;/g2&gt;</ept>라는 <bpt i="1" x="1">&lt;g1&gt;</bpt>ite<ept i="1">&lt;/g1&gt;</ept>의 변종을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library defines a type class <bpt i="8" x="8">&lt;g8&gt;</bpt>Inhabited<ept i="8">&lt;/g8&gt;</ept> to enable type class inference to infer a
"default" element of an inhabited type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160029Z" creationid="tlqk3" creationdate="20220604T160029Z">
        <seg>표준 라이브러리는 유형 클래스 추론이 내재된 유형의 "기본" 원소를 유추할 수 있도록 유형 클래스 <bpt i="8" x="8">&lt;g8&gt;</bpt>Inhabited<ept i="8">&lt;/g8&gt;</ept>를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The standard library introduces the
tactic <bpt i="2" x="2">&lt;g2&gt;</bpt>decide<ept i="2">&lt;/g2&gt;</ept> that uses the <bpt i="3" x="3">&lt;g3&gt;</bpt>Decidable<ept i="3">&lt;/g3&gt;</ept> instance to solve simple goals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174558Z" creationid="tlqk3" creationdate="20220604T174558Z">
        <seg>표준 라이브러리는 단순한 목표를 풀기 위해 <bpt i="3" x="3">&lt;g3&gt;</bpt>Decidable<ept i="3">&lt;/g3&gt;</ept> 개체를 사용하는 <bpt i="2" x="2">&lt;g2&gt;</bpt>decide<ept i="2">&lt;/g2&gt;</ept> 전략을 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The statement that <bpt i="1" x="1">&lt;g1&gt;</bpt>r<ept i="1">&lt;/g1&gt;</ept> is well founded, denoted <bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded r<ept i="2">&lt;/g2&gt;</ept>,
is exactly the statement that every element of the type is
accessible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T175121Z" creationid="tlqk3" creationdate="20220529T174746Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>WellFounded r<ept i="2">&lt;/g2&gt;</ept>로 표시되어 잘 세워진 명제 <bpt i="1" x="1">&lt;g1&gt;</bpt>r<ept i="1">&lt;/g1&gt;</ept>는 바로 그 유형의 모든 원소가 접근 가능한 명제입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The structure command also generates useful recursors and
theorems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173919Z" creationid="tlqk35" creationdate="20220528T173919Z">
        <seg>또 구조체 명령은 유용한 재귀자와 정리들을 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The structure command is essentially a "front end" for defining
inductive data types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173413Z" creationid="tlqk35" creationdate="20220528T173413Z">
        <seg>구조체 명령은 본질적은 유도 데이터형을 정의하기 위한 "최전선"입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The style of writing proofs is most effective when it is used in
conjunction with the <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite<ept i="2">&lt;/g2&gt;</ept> tactics, which are
discussed in greater detail in the next chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180349Z" creationid="tlqk35" creationdate="20220321T180349Z">
        <seg>증명 작성 스타일은 <bpt i="1" x="1">&lt;g1&gt;</bpt>simp<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>rewrite<ept i="2">&lt;/g2&gt;</ept> 전략을 결합해 사용되었을 때 가장 효과적입니다. 이것들은 다음 장에서 상세히 논할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The suffix <bpt i="1" x="1">&lt;g1&gt;</bpt>: structure-type<ept i="1">&lt;/g1&gt;</ept> can be omitted whenever the name of
the structure can be inferred from the expected type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T182148Z" creationid="tlqk35" creationdate="20220528T182148Z">
        <seg>접미사 <bpt i="1" x="1">&lt;g1&gt;</bpt>: structure-type<ept i="1">&lt;/g1&gt;</ept>은 언제든지 구조체의 이름이 기대되는 유형으로부터 추론될 수 있는 한 생략될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The syntax for doing so is as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125701Z" creationid="tlqk3" creationdate="20220526T125701Z">
        <seg>그렇게 하는 문법은 다음과 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The syntax is similar to that for mutual inductive types, as described in :numref:<bpt i="1" x="1">&lt;g1&gt;</bpt>mutual_and_nested_inductive_types<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173612Z" creationid="tlqk3" creationdate="20220603T173612Z">
        <seg>numref<bpt i="1" x="1">&lt;g1&gt;</bpt>상호적이고 재귀적인 귀납형<ept i="1">&lt;/g1&gt;</ept>에서 기술한 바처럼 문법은 상호 귀납적인 유형에 대한 것과 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The syntax is similar to that of <bpt i="3" x="3">&lt;g3&gt;</bpt>cases<ept i="3">&lt;/g3&gt;</ept>, except that the
argument can only be a term in the local context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172058Z" creationid="tlqk3" creationdate="20220527T172058Z">
        <seg>인수가 지역 상황에 대한 것이라는 점을 제외하고 문법은 <bpt i="3" x="3">&lt;g3&gt;</bpt>cases<ept i="3">&lt;/g3&gt;</ept>의 것과 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The syntax of the <bpt i="1" x="1">&lt;g1&gt;</bpt>with<ept i="1">&lt;/g1&gt;</ept> is convenient for writing structured proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165312Z" creationid="tlqk3" creationdate="20220527T165312Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>with<ept i="1">&lt;/g1&gt;</ept>의 문법은 구조화된 증명을 작성하는데 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tactic <bpt i="11" x="11">&lt;g11&gt;</bpt>decide<ept i="11">&lt;/g11&gt;</ept> puts it all together: to
prove a target <bpt i="12" x="12">&lt;g12&gt;</bpt>p<ept i="12">&lt;/g12&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T175044Z" creationid="tlqk3" creationdate="20220604T175044Z">
        <seg><bpt i="11" x="11">&lt;g11&gt;</bpt>decide<ept i="11">&lt;/g11&gt;</ept> 전략은 목표 <bpt i="12" x="12">&lt;g12&gt;</bpt>p<ept i="12">&lt;/g12&gt;</ept>를 증명하기 위해 모든 것을 한데 모읍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tactic automatically closes any goal of the form
<bpt i="7" x="7">&lt;g7&gt;</bpt>t = t<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172057Z" creationid="tlqk35" creationdate="20220524T154238Z">
        <seg>전략은 자동적으로 <bpt i="7" x="7">&lt;g7&gt;</bpt>t = t<ept i="7">&lt;/g7&gt;</ept>꼴의 임의의 목표를 자동적으로 마무리짓습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tactic interpreter
-- tries all possible macro extensions for `triv` until one succeeds
macro_rules</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171012Z" creationid="tlqk35" creationdate="20220524T171012Z">
        <seg>The tactic interpreter
-- `triv`에 대한 가능한 모든 매크로 확장을 어떤 것이 macro_rules을 성공할 때까지 시도합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The tactic tries to solve the left disjunct immediately by assumption;
if that fails, it tries to focus on the right disjunct; and if that
doesn't work, it invokes the assumption tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150955Z" creationid="tlqk35" creationdate="20220524T150955Z">
        <seg>전략은 왼쪽의 분리자를 가정으로부터 즉시 풀려고 합니다.
만약 실패하면 이것은 오른쪽 분리자에 초점을 맞춰 시도합니다. 그리고 
이게 성공하지 못하면, 가정 전략을 불러옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The term "predicative" stems from foundational developments around the
turn of the twentieth century, when logicians such as Poincaré and
Russell blamed set-theoretic paradoxes on the "vicious circles" that
arise when we define a property by quantifying over a collection that
includes the very property being defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175119Z" creationid="tlqk35" creationdate="20220321T175119Z">
        <seg>"술어"라는 말은 20세기로 접어드는 시기에 기초수학의 발전으로부터 유래되었습니다.  이때 푸엥카레와 레셀 같은 논리학자들은 정의되는 바로 그 정의되는 성질을 포함하는 모임에 대해 한정함으로써 성질을 정의할 때 발생하는 집합론적 역설 "악순환(vicious circles)"을 비난했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The term rewriter and simplifier are described
briefly in the next section, and then in greater detail in the next
chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180218Z" creationid="tlqk35" creationdate="20220321T180218Z">
        <seg>항 다시쓰기와 단순화는 다음 섹션에서 간단히 설명합니다. 그러고 나서 다음 장에서 아주 상세하게 다룹니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The theorem <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.lt_or_ge m n<ept i="1">&lt;/g1&gt;</ept> says <bpt i="2" x="2">&lt;g2&gt;</bpt>m &lt; n ∨ m ≥ n<ept i="2">&lt;/g2&gt;</ept>, and it is
natural to think of the proof above as splitting on these two
cases.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170957Z" creationid="tlqk3" creationdate="20220527T170957Z">
        <seg>정리 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.lt_or_ge m n<ept i="1">&lt;/g1&gt;</ept>은 <bpt i="2" x="2">&lt;g2&gt;</bpt>m &lt; n ∨ m ≥ n<ept i="2">&lt;/g2&gt;</ept>을 말합니다. 그리고 이것은 이들 두 경우를 나눔으로써 위의 증명이 당연하다고 생각합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The triangle in the second presentation is a macro built on top of
<bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.symm<ept i="2">&lt;/g2&gt;</ept>, and you can enter it by typing <bpt i="3" x="3">&lt;g3&gt;</bpt>\t<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175821Z" creationid="tlqk35" creationdate="20220321T175821Z">
        <seg>두번째 보기에서 삼각형은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.subst<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.symm<ept i="2">&lt;/g2&gt;</ept> 위에 세워진 매크로입니다. 여러분은 이것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>\t<ept i="3">&lt;/g3&gt;</ept>을 쳐서 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two
defining equations for addition now hold definitionally:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160421Z" creationid="tlqk3" creationdate="20220527T160421Z">
        <seg>덧셈에 대해 정의한 두 방정식은 이제 정의상으로 성립합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The two ways we have suggested thinking about the
propositions-as-types paradigm differ in a fundamental way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160323Z" creationid="tlqk35" creationdate="20220321T160323Z">
        <seg>우리가 제안한 유형별 명제 패러다임에 대해 생각하는 두 가지 방법은 근본적인 면에서 다릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type <bpt i="1" x="1">&lt;g1&gt;</bpt>@Nat.below C (3 : nat)<ept i="1">&lt;/g1&gt;</ept> is a data structure that stores elements of <bpt i="2" x="2">&lt;g2&gt;</bpt>C 0<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>C 1<ept i="3">&lt;/g3&gt;</ept>, and <bpt i="4" x="4">&lt;g4&gt;</bpt>C 2<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165012Z" creationid="tlqk3" creationdate="20220603T164349Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>@Nat.below C (3 : nat)<ept i="1">&lt;/g1&gt;</ept>형은 <bpt i="2" x="2">&lt;g2&gt;</bpt>C 0<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>C 1<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>C 2<ept i="4">&lt;/g4&gt;</ept>의 원소를 저장하는 데이터 구조입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type algebra <bpt i="2" x="2">&lt;g2&gt;</bpt>β → γ<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>α → β<ept i="3">&lt;/g3&gt;</ept> means it is a requirement
that the type of the output of the second function must match the
type of the input to the first function - which makes sense, otherwise
the two functions would not be composable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144512Z" creationid="tlqk35" creationdate="20220321T144512Z">
        <seg> <bpt i="2" x="2">&lt;g2&gt;</bpt>β → γ<ept i="2">&lt;/g2&gt;</ept> 와 <bpt i="3" x="3">&lt;g3&gt;</bpt>α → β<ept i="3">&lt;/g3&gt;</ept>의 유형 대수는 두 번째 함수의 출력 유형이 첫 번째 함수의 입력 유형과 반드시 일치해야 한다는 요구를 같습니다. 이렇지 않다면 두 함수는 합성될 수 없을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The type of <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept> is now <bpt i="2" x="2">&lt;g2&gt;</bpt>∀ {p q : Prop}, p → q → p<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161439Z" creationid="tlqk35" creationdate="20220321T161439Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept>의 유형은 이제 <bpt i="2" x="2">&lt;g2&gt;</bpt>∀ {p q : Prop}, p → q → p<ept i="2">&lt;/g2&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The types in a <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> tactic can be omitted, so you can write <bpt i="2" x="2">&lt;g2&gt;</bpt>have
hp := h.left<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>have hqr := h.right<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143959Z" creationid="tlqk35" creationdate="20220524T143959Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> 전략에서 유형은 생략될 수 있습니다. 그래서 여러분은  <bpt i="2" x="2">&lt;g2&gt;</bpt>have
hp := h.left<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>have hqr := h.right<ept i="3">&lt;/g3&gt;</ept>을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The typing rules forces us to write <bpt i="8" x="8">&lt;g8&gt;</bpt>f a<ept i="8">&lt;/g8&gt;</ept> for the
first argument, but this term is neither a variable nor a constructor
application, and plays no role in the pattern-matching definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T144852Z" creationid="tlqk3" creationdate="20220604T144852Z">
        <seg>입력 규칙은 우리가 첫 인수에 대해 <bpt i="8" x="8">&lt;g8&gt;</bpt>f a<ept i="8">&lt;/g8&gt;</ept>로 쓰도록 합니다. 그러나 이 항은 변수도 생성자 적용도 아닙니다. 그리고 패턴 매칭 정의에서 어떤 역할도 하지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The unicode symbol <bpt i="8" x="8">&lt;g8&gt;</bpt>×<ept i="8">&lt;/g8&gt;</ept> for the Cartesian product
is entered as <bpt i="9" x="9">&lt;g9&gt;</bpt>\times<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140531Z" creationid="tlqk35" creationdate="20220321T140531Z">
        <seg>카테시안 곱을 나타내는 유니코드 기호 <bpt i="8" x="8">&lt;g8&gt;</bpt>×<ept i="8">&lt;/g8&gt;</ept>는 <bpt i="9" x="9">&lt;g9&gt;</bpt>\times<ept i="9">&lt;/g9&gt;</ept>을 입력하여 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The universal quantifier, <bpt i="1" x="1">&lt;g1&gt;</bpt>∀ x : α, p x<ept i="1">&lt;/g1&gt;</ept> is supposed to denote the
assertion that "for every <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>p x<ept i="3">&lt;/g3&gt;</ept>" holds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172839Z" creationid="tlqk35" creationdate="20220321T172839Z">
        <seg>전칭 한정기호 <bpt i="1" x="1">&lt;g1&gt;</bpt>∀ x : α, p x<ept i="1">&lt;/g1&gt;</ept> 은 "모든 <bpt i="2" x="2">&lt;g2&gt;</bpt>x : α<ept i="2">&lt;/g2&gt;</ept>에 대해  <bpt i="3" x="3">&lt;g3&gt;</bpt>p x<ept i="3">&lt;/g3&gt;</ept>"가 성립한다는 주장을 가리켜야 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The use of course-of-values recursion is one of the techniques the equation compiler uses to justify to
the Lean kernel that a function terminates.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165021Z" creationid="tlqk3" creationdate="20220603T164834Z">
        <seg>course-of-values 재귀의 사용은 방정식 컴파일러가 함수를 끝내는 린 커널을 정당화하는데 사용하는 한 기법입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The use of underscores for wildcards is
common in functional programming languages, and so Lean adopts that
notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T163403Z" creationid="tlqk3" creationdate="20220529T163403Z">
        <seg>와일드카드에 대한 밑줄 문자의 사용은 함수형 프로그래밍 언어에서 흔합니다. 그래서 린은 이 표기를 채택합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>The variable <bpt i="5" x="5">&lt;g5&gt;</bpt>C<ept i="5">&lt;/g5&gt;</ept>
represents the motive of the recursive definition: for each element
<bpt i="6" x="6">&lt;g6&gt;</bpt>x : α<ept i="6">&lt;/g6&gt;</ept>, we would like to construct an element of <bpt i="7" x="7">&lt;g7&gt;</bpt>C x<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165547Z" creationid="tlqk3" creationdate="20220603T165547Z">
        <seg>변수 <bpt i="5" x="5">&lt;g5&gt;</bpt>C<ept i="5">&lt;/g5&gt;</ept>는 재귀적 정의의 동기를 나타냅니다. 각 원소 <bpt i="6" x="6">&lt;g6&gt;</bpt>x : α<ept i="6">&lt;/g6&gt;</ept>에 대하여 우리는 <bpt i="7" x="7">&lt;g7&gt;</bpt>C x<ept i="7">&lt;/g7&gt;</ept>의 원소를 생성하고자 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then
<bpt i="6" x="6">&lt;g6&gt;</bpt>(x : α) → β<ept i="6">&lt;/g6&gt;</ept> is an element of <bpt i="7" x="7">&lt;g7&gt;</bpt>Sort (imax i j)<ept i="7">&lt;/g7&gt;</ept>, where <bpt i="8" x="8">&lt;g8&gt;</bpt>imax i j<ept i="8">&lt;/g8&gt;</ept> is the
maximum of <bpt i="9" x="9">&lt;g9&gt;</bpt>i<ept i="9">&lt;/g9&gt;</ept> and <bpt i="10" x="10">&lt;g10&gt;</bpt>j<ept i="10">&lt;/g10&gt;</ept> if <bpt i="11" x="11">&lt;g11&gt;</bpt>j<ept i="11">&lt;/g11&gt;</ept> is not 0, and 0 otherwise.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174559Z" creationid="tlqk35" creationdate="20220321T174559Z">
        <seg>그러면 <bpt i="6" x="6">&lt;g6&gt;</bpt>(x : α) → β<ept i="6">&lt;/g6&gt;</ept>은 <bpt i="7" x="7">&lt;g7&gt;</bpt>Sort (imax i j)<ept i="7">&lt;/g7&gt;</ept>의 원소입니다. 여기서 <bpt i="8" x="8">&lt;g8&gt;</bpt>imax i j<ept i="8">&lt;/g8&gt;</ept>는 <bpt i="9" x="9">&lt;g9&gt;</bpt>i<ept i="9">&lt;/g9&gt;</ept>와 <bpt i="10" x="10">&lt;g10&gt;</bpt>j<ept i="10">&lt;/g10&gt;</ept>사이의 최대값이고, <bpt i="11" x="11">&lt;g11&gt;</bpt>j<ept i="11">&lt;/g11&gt;</ept>가 0이 아니고, 이외에는 0입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then <bpt i="3" x="3">&lt;g3&gt;</bpt>th3<ept i="3">&lt;/g3&gt;</ept> combines the two results.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185956Z" creationid="tlqk3" creationdate="20220525T185956Z">
        <seg>그런 뒤 <bpt i="3" x="3">&lt;g3&gt;</bpt>th3<ept i="3">&lt;/g3&gt;</ept>는 이 두 결과를 결합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then for <bpt i="1" x="1">&lt;g1&gt;</bpt>n : Nat<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>m : Nat<ept i="2">&lt;/g2&gt;</ept>, the term <bpt i="3" x="3">&lt;g3&gt;</bpt>Add.add n m<ept i="3">&lt;/g3&gt;</ept> triggers typeclass resolution with the goal
of <bpt i="4" x="4">&lt;g4&gt;</bpt>Add Nat<ept i="4">&lt;/g4&gt;</ept>, and typeclass resolution will synthesize the instance above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154807Z" creationid="tlqk3" creationdate="20220604T154807Z">
        <seg>그런 다음 <bpt i="1" x="1">&lt;g1&gt;</bpt>n : Nat<ept i="1">&lt;/g1&gt;</ept> 및 <bpt i="2" x="2">&lt;g2&gt;</bpt>m : Nat<ept i="2">&lt;/g2&gt;</ept>에 대해 항 <bpt i="3" x="3">&lt;g3&gt;</bpt>Add.add n m<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Add Nat<ept i="4">&lt;/g4&gt;</ept>의 목표를 유형 클래스 해결책으로 만듭니다. 그리고 유형 클래스 해결책은 위의 개체를 합성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then for any list <bpt i="1" x="1">&lt;g1&gt;</bpt>xs<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse (mk_symm xs)<ept i="2">&lt;/g2&gt;</ept> is equal to <bpt i="3" x="3">&lt;g3&gt;</bpt>mk_symm xs<ept i="3">&lt;/g3&gt;</ept>,
which can easily be proved by unfolding the definition:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171628Z" creationid="tlqk35" creationdate="20220524T164500Z">
        <seg>그럼 임의의 리스트  <bpt i="1" x="1">&lt;g1&gt;</bpt>xs<ept i="1">&lt;/g1&gt;</ept>에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>reverse (mk_symm xs)<ept i="2">&lt;/g2&gt;</ept>은 <bpt i="3" x="3">&lt;g3&gt;</bpt>mk_symm xs<ept i="3">&lt;/g3&gt;</ept>과 같습니다. 
그리고 이는 정의를 펼쳐보는 것으로 쉽게 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then go back and replace each <bpt i="5" x="5">&lt;g5&gt;</bpt>sorry<ept i="5">&lt;/g5&gt;</ept> with an actual proof,
until no more remain.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170401Z" creationid="tlqk35" creationdate="20220321T170401Z">
        <seg>그리고 다시 뒤로 돌아가 각각의 <bpt i="5" x="5">&lt;g5&gt;</bpt>sorry<ept i="5">&lt;/g5&gt;</ept>가 더 남지 않을 때까지 실제 증명으로 바꾸세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then next applies commutativity to the term
<bpt i="3" x="3">&lt;g3&gt;</bpt>b + c<ept i="3">&lt;/g3&gt;</ept>; without specifying the argument, the tactic would instead rewrite
<bpt i="4" x="4">&lt;g4&gt;</bpt>a + (b + c)<ept i="4">&lt;/g4&gt;</ept> to <bpt i="5" x="5">&lt;g5&gt;</bpt>(b + c) + a<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171948Z" creationid="tlqk35" creationdate="20220524T155631Z">
        <seg>그 뒤 항 <bpt i="3" x="3">&lt;g3&gt;</bpt>b + c<ept i="3">&lt;/g3&gt;</ept>에 교환성을 적용합니다 .
인수의 명시 없이 전략은 <bpt i="4" x="4">&lt;g4&gt;</bpt>a + (b + c)<ept i="4">&lt;/g4&gt;</ept>에서 <bpt i="5" x="5">&lt;g5&gt;</bpt>(b + c) + a<ept i="5">&lt;/g5&gt;</ept>으로 다시 쓸 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then the new hypothesis <bpt i="4" x="4">&lt;g4&gt;</bpt>a = 0<ept i="4">&lt;/g4&gt;</ept> is used to rewrite the goal to <bpt i="5" x="5">&lt;g5&gt;</bpt>f 0 = f 0<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171829Z" creationid="tlqk35" creationdate="20220524T160355Z">
        <seg>그 뒤 새로운 가정 <bpt i="4" x="4">&lt;g4&gt;</bpt>a = 0<ept i="4">&lt;/g4&gt;</ept> 가 목표를 <bpt i="5" x="5">&lt;g5&gt;</bpt>f 0 = f 0<ept i="5">&lt;/g5&gt;</ept>으로 다시 쓰도록 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then the universe level <bpt i="3" x="3">&lt;g3&gt;</bpt>u<ept i="3">&lt;/g3&gt;</ept> is
constrained to satisfy the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T161907Z" creationid="tlqk35" creationdate="20220528T161907Z">
        <seg>그러면 세계 수준 <bpt i="3" x="3">&lt;g3&gt;</bpt>u<ept i="3">&lt;/g3&gt;</ept>는 다음을 만족하도록 제한됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then try proving some
of their basic properties, building on the theorems we have already
proved.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171132Z" creationid="tlqk35" creationdate="20220528T171127Z">
        <seg>그 뒤 그들의 기본 성질 몇 가지를 증명해보세요. 우리가 이미 증명한 정리를 세워보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then use e.g. <bpt i="1" x="1">&lt;g1&gt;</bpt><bpt i="2" x="2">&lt;g2&gt;</bpt>mdbook watch<ept i="2">&lt;/g2&gt;</ept><ept i="1">&lt;/g1&gt;</ept> in the root folder:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172040Z" creationid="tlqk35" creationdate="20220321T172040Z">
        <seg>루트 폴더에서 <bpt i="1" x="1">&lt;g1&gt;</bpt><bpt i="2" x="2">&lt;g2&gt;</bpt>mdbook watch<ept i="2">&lt;/g2&gt;</ept><ept i="1">&lt;/g1&gt;</ept>을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then use the equation
compiler to derive some of their basic properties.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180954Z" creationid="tlqk3" creationdate="20220603T180954Z">
        <seg>그 뒤 방정식 컴파일러를 그들의 기본 성질 몇 가지를 유도하는데 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then we can "cancel" the hypothesis and obtain a proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>Implies p q<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155131Z" creationid="tlqk35" creationdate="20220321T155131Z">
        <seg>그러면 우리는 가정을 "상쇄"하여 <bpt i="3" x="3">&lt;g3&gt;</bpt>Implies p q<ept i="3">&lt;/g3&gt;</ept>의 증명을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then, the second one replaces <bpt i="5" x="5">&lt;g5&gt;</bpt>f 0<ept i="5">&lt;/g5&gt;</ept>
with <bpt i="6" x="6">&lt;g6&gt;</bpt>0<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172103Z" creationid="tlqk35" creationdate="20220524T154206Z">
        <seg>그런 뒤 두 번째 것은 <bpt i="5" x="5">&lt;g5&gt;</bpt>f 0<ept i="5">&lt;/g5&gt;</ept>을 <bpt i="6" x="6">&lt;g6&gt;</bpt>0<ept i="6">&lt;/g6&gt;</ept>으로 대체합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then, we use the command <bpt i="3" x="3">&lt;g3&gt;</bpt>macro_rules<ept i="3">&lt;/g3&gt;</ept> to specify what should
be done when <bpt i="4" x="4">&lt;g4&gt;</bpt>triv<ept i="4">&lt;/g4&gt;</ept> is used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170602Z" creationid="tlqk35" creationdate="20220524T170602Z">
        <seg>그러면 우리는  <bpt i="4" x="4">&lt;g4&gt;</bpt>triv<ept i="4">&lt;/g4&gt;</ept>가 사용될 때 <bpt i="3" x="3">&lt;g3&gt;</bpt>macro_rules<ept i="3">&lt;/g3&gt;</ept> 명령이 
무엇을 해야 하는지 명시하도록 사용할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then, when we write the expression <bpt i="2" x="2">&lt;g2&gt;</bpt>f 7<ept i="2">&lt;/g2&gt;</ept> without further
arguments, it is parsed as <bpt i="3" x="3">&lt;g3&gt;</bpt>f 7 _<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185104Z" creationid="tlqk3" creationdate="20220525T185104Z">
        <seg>그럼, 우리가 표현식 <bpt i="2" x="2">&lt;g2&gt;</bpt>f 7<ept i="2">&lt;/g2&gt;</ept>을 추가 인수없이 슬때, 이는 <bpt i="3" x="3">&lt;g3&gt;</bpt>f 7 _<ept i="3">&lt;/g3&gt;</ept>와 같이 구문 분석 될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Then, you can construct lists of <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> as follows.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185331Z" creationid="tlqk35" creationdate="20220321T152432Z">
        <seg>그럼 여러분은  <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept>의 리스트를 다음과 같이 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Theorem Proving in Lean 4</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171646Z" creationid="tlqk35" creationdate="20220321T170911Z">
        <seg>린4로 하는 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are a few more things to notice here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140641Z" creationid="tlqk35" creationdate="20220321T140641Z">
        <seg>여기서 몇 개 더 짚고가야 할 것이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are a few pragmatic differences between definitions and
theorems, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160855Z" creationid="tlqk35" creationdate="20220321T160855Z">
        <seg>하지만 정의와 정리 사이에 약간의 실용적 차이는 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are a number of ways in which you can query Lean for information
about its current state and the objects and theorems that are
available in the current context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125042Z" creationid="tlqk3" creationdate="20220526T125042Z">
        <seg>여러분이 린에게 그것의 현재 상태와 현재 상황에서 사용할 수 있는 대상과 정리에 대한 정보를 요청하는 여러가지 방법이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are at least two ways of thinking about propositions as
types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155833Z" creationid="tlqk35" creationdate="20220321T155833Z">
        <seg>유형으로써 명제에 대해 생각할 수 있는 최소한 두 가지 방법이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are currently two ways to use Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131811Z" creationid="tlqk35" creationdate="20220321T131811Z">
        <seg>현재 Lean을 사용하는 두 가지 방식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are extra bells and whistles.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164227Z" creationid="tlqk3" creationdate="20220527T164227Z">
        <seg>여기 여분의 종과 호루라기가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are rules that
govern what the eliminator of an inductive type can eliminate <bpt i="1" x="1">&lt;g1&gt;</bpt>to<ept i="1">&lt;/g1&gt;</ept>,
that is, what kinds of types can be the target of a recursor.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152054Z" creationid="tlqk3" creationdate="20220527T151944Z">
        <seg>귀납형의 제거자가 제거할 수 있는 것, 즉 유형의 어느 종류가 재귀자의 대상이 될 수 있는가를 다루는 규칙이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are several
ways to fix this issue, and one way is to use a more precise tool :
the conversion mode.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182439Z" creationid="tlqk3" creationdate="20220604T182439Z">
        <seg>이 문제를 해결하는 방법에는 여러 가지가 있으며 한 가지 방법은 보다 정밀한 도구인 전환 모드를 사용하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are two additional modifiers that are useful.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171530Z" creationid="tlqk35" creationdate="20220524T170029Z">
        <seg>이외 유용한 두 수정자들이 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There are two constructors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154052Z" creationid="tlqk3" creationdate="20220527T154052Z">
        <seg>두 생성자가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is a fine line between brevity and obfuscation, and omitting
information in this way can sometimes make a proof harder to read.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163506Z" creationid="tlqk35" creationdate="20220321T163506Z">
        <seg>간결함과 가독성 사이에 미세찬 차이가 있고 이런 식으로 정보를 생략하는 것은 때때로 증명을 읽기 더 어렵게 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is a long cast of characters here, but the first block we have
already seen: the type, <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, the relation, <bpt i="2" x="2">&lt;g2&gt;</bpt>r<ept i="2">&lt;/g2&gt;</ept>, and the
assumption, <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept>, that <bpt i="4" x="4">&lt;g4&gt;</bpt>r<ept i="4">&lt;/g4&gt;</ept> is well founded.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171011Z" creationid="tlqk3" creationdate="20220603T165459Z">
        <seg>여기 문자의 긴 캐스트가 있지만 우리는 이미 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>α<ept i="1">&lt;/g1&gt;</ept>, 관계 <bpt i="2" x="2">&lt;g2&gt;</bpt>r<ept i="2">&lt;/g2&gt;</ept> 그리고 가정 <bpt i="3" x="3">&lt;g3&gt;</bpt>h<ept i="3">&lt;/g3&gt;</ept>으로 된 첫 블럭을 봤습니다. 여기서 <bpt i="4" x="4">&lt;g4&gt;</bpt>r<ept i="4">&lt;/g4&gt;</ept>은 잘 세워진 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is a small exception to this rule, however, which we
will discuss below, in the section on inductive families.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152109Z" creationid="tlqk3" creationdate="20220527T152622Z">
        <seg>그러나 이 규칙에 우리가 아래에서 논의할 작은 예외가 귀납군의 섹션에 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is a third kind of implicit argument that is denoted with square
brackets, <bpt i="1" x="1">&lt;g1&gt;</bpt>[<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>]<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T190539Z" creationid="tlqk3" creationdate="20220525T190539Z">
        <seg>대괄호 <bpt i="1" x="1">&lt;g1&gt;</bpt>[<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>]<ept i="2">&lt;/g2&gt;</ept>로 표시된 세 번째 종류의 암시적인 매개변수가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is also a <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> tactic, which introduces a new subgoal, just as when writing proof terms:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T143650Z" creationid="tlqk35" creationdate="20220524T143650Z">
        <seg>증명항을 작성할 때처럼 <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> 전략은 새로운 하위목표를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is an exception to this last rule: we are allowed to eliminate
from an inductively defined <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept> to an arbitrary <bpt i="2" x="2">&lt;g2&gt;</bpt>Sort<ept i="2">&lt;/g2&gt;</ept> when
there is only one constructor and each constructor argument is either
in <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept> or an index.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T163129Z" creationid="tlqk35" creationdate="20220528T163129Z">
        <seg>이 마지막 규칙에 예외가 있습니다. 우리는 재귀적으로 정의된 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>에서 임의의 <bpt i="2" x="2">&lt;g2&gt;</bpt>Sort<ept i="2">&lt;/g2&gt;</ept>이르기까지 오직 한 생성자와 각 생성자 인수가 <bpt i="3" x="3">&lt;g3&gt;</bpt>Prop<ept i="3">&lt;/g3&gt;</ept>에 있거나 한 색인으로 있을 때 제거할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>There is only one
anonymous namespace at the root level.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150427Z" creationid="tlqk35" creationdate="20220321T150427Z">
        <seg>root 계층에서만 익명 이름 공간이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thereafter <bpt i="1" x="1">&lt;g1&gt;</bpt>decidable p<ept i="1">&lt;/g1&gt;</ept> has an instance for every <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173818Z" creationid="tlqk3" creationdate="20220604T173818Z">
        <seg>그 후에 <bpt i="1" x="1">&lt;g1&gt;</bpt>decidable p<ept i="1">&lt;/g1&gt;</ept>는 모든 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>에 대해 개체를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These
annotations are essential, for example, when a term occurring in the
left-hand side is neither a variable nor a constructor application,
because these are not suitable targets for pattern matching.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143757Z" creationid="tlqk3" creationdate="20220604T143757Z">
        <seg>이 주석은 필수적입니다. 예를 들어 좌변에서 나타나는 항이 변수도 생성자 적용도 아닐 때, 이들은 패턴 매칭에 적적한 대상이 아니기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These
aspects of Lean are explored in a companion tutorial to this one, <bpt i="2" x="2">&lt;g2&gt;</bpt>Programming in Lean 4<ept i="2">&lt;/g2&gt;</ept>, though computational
aspects of the system will make an appearance here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131657Z" creationid="tlqk35" creationdate="20220321T131657Z">
        <seg>Lean의 이러한 측면은 이 교재의 동반 교재인 <bpt i="2" x="2">&lt;g2&gt;</bpt>Programming in Lean<ept i="2">&lt;/g2&gt;</ept>에서 더 찾아볼 수 있다. 그렇지만 여기에서도 린의 계산적인 측면을 찾아봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These
types vary depending on the first argument, <bpt i="11" x="11">&lt;g11&gt;</bpt>α<ept i="11">&lt;/g11&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151505Z" creationid="tlqk35" creationdate="20220321T151500Z">
        <seg>이 유형은 첫번째 인수 <bpt i="11" x="11">&lt;g11&gt;</bpt>α<ept i="11">&lt;/g11&gt;</ept>에 따라 달라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These angle brackets are obtained by typing <bpt i="1" x="1">&lt;g1&gt;</bpt>\&lt;<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>\&gt;<ept i="2">&lt;/g2&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163322Z" creationid="tlqk35" creationdate="20220321T163322Z">
        <seg>이 꺽긴 괄호는 <bpt i="1" x="1">&lt;g1&gt;</bpt>\&lt;<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>\&gt;<ept i="2">&lt;/g2&gt;</ept>을 각각 치는 것으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These are called "inaccessible patterns" for
that reason.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171552Z" creationid="tlqk3" creationdate="20220529T171552Z">
        <seg>이들은 이런 이유로 "접근할 수 없는 패턴"으로 불립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These are not
supported by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T155106Z" creationid="tlqk35" creationdate="20220528T155106Z">
        <seg>이것들은 린에서 지원되지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These are the left and
right <bpt i="7" x="7">&lt;g7&gt;</bpt>or-introduction<ept i="7">&lt;/g7&gt;</ept> rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163645Z" creationid="tlqk35" creationdate="20220321T163645Z">
        <seg>이들은 왼쪽과 오른쪽 <bpt i="7" x="7">&lt;g7&gt;</bpt>or-도입<ept i="7">&lt;/g7&gt;</ept> 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These are used for type classes, as
explained in <bpt i="3" x="3">&lt;g3&gt;</bpt>Chapter Type Classes<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T190606Z" creationid="tlqk3" creationdate="20220525T190606Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>Chapter Type Classes<ept i="3">&lt;/g3&gt;</ept>에서 설명할 이들은 유형 클래스에 대해서 사용되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These can include ordinary mathematical theorems, as well as claims that pieces of hardware
or software, network protocols, and mechanical and hybrid systems meet their specifications.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131146Z" creationid="tlqk35" creationdate="20220321T131146Z">
        <seg>이 주장들은 평범한 수학적 정리뿐만 아니라 하드웨어와 소프트웨어, 네트워크 프로토콜, 역학적 복합적 시스템이 그들의 명세를 만족하는지에 대한 주장도 포함될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These require classical reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170708Z" creationid="tlqk35" creationdate="20220321T170708Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These require classical reasoning:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170211Z" creationid="tlqk35" creationdate="20220321T170211Z">
        <seg>이것은 고전 추론 규칙이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These tactics can be used on data just as well as propositions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T072519Z" creationid="tlqk35" creationdate="20220522T072519Z">
        <seg>이 전략들은 명제와 마찬가지로 데이터에 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>These variations are equally useful for destructing propositions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181905Z" creationid="tlqk3" creationdate="20220603T181905Z">
        <seg>이 변수들은 명제를 파괴하는데 똑같이 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They
are commonly known as the right and left <bpt i="6" x="6">&lt;g6&gt;</bpt>and-elimination<ept i="6">&lt;/g6&gt;</ept> rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162823Z" creationid="tlqk35" creationdate="20220321T162823Z">
        <seg>이들은 흔히 오른쪽과 왼쪽 <bpt i="6" x="6">&lt;g6&gt;</bpt>and-제거<ept i="6">&lt;/g6&gt;</ept> 규칙으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They all take values in <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162148Z" creationid="tlqk35" creationdate="20220321T162148Z">
        <seg>이들은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>형의 모든 값을 받습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are also known as the <bpt i="4" x="4">&lt;g4&gt;</bpt>minor premises<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155714Z" creationid="tlqk3" creationdate="20220527T155714Z">
        <seg>이들은 <bpt i="4" x="4">&lt;g4&gt;</bpt>사소한 전제<ept i="4">&lt;/g4&gt;</ept>라고도 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are considered "the same" by Lean's type
checker, and Lean does its best to recognize and support these
identifications.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143738Z" creationid="tlqk35" creationdate="20220321T143738Z">
        <seg>이런 것은 린의 유형 검사기가 "같은"것으로 봅니다. 그리고 린은 유형을 인식하고 대조하는데 최선을 다합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are designed to deal
with applicative terms, that is, terms of form <bpt i="2" x="2">&lt;g2&gt;</bpt>s t<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175843Z" creationid="tlqk35" creationdate="20220321T175843Z">
        <seg>이들은 응용 항을 다루기 위해 설계되었습니다. 즉,  <bpt i="2" x="2">&lt;g2&gt;</bpt>s t<ept i="2">&lt;/g2&gt;</ept> 꼴의 항입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They are not meant to be
used directly by the user; rather, the <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept> tactic
is configured to use them when necessary.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173308Z" creationid="tlqk3" creationdate="20220529T173308Z">
        <seg>이들은 사용자로부터 직접 사용되기 위한 것이 아니라 오히려 <bpt i="4" x="4">&lt;g4&gt;</bpt>simp<ept i="4">&lt;/g4&gt;</ept> 전략이 필요할 때 사용되도록 설정됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They can also
include subscripts, which can be entered by typing <bpt i="1" x="1">&lt;g1&gt;</bpt>\_<ept i="1">&lt;/g1&gt;</ept> followed by
the desired subscripted character.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T191212Z" creationid="tlqk3" creationdate="20220525T191212Z">
        <seg>이들은 아래첨자를 넣고자 하는 문자 다음에  <bpt i="1" x="1">&lt;g1&gt;</bpt>\_<ept i="1">&lt;/g1&gt;</ept>을 쳐 넣음으로써 아래첨자도 포함할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They naturally support an incremental style of writing proofs,
in which you decompose a proof and work on goals one step at a time.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184311Z" creationid="tlqk35" creationdate="20220321T184311Z">
        <seg>그들은 증명을 분해하고 한 번에 한 단계씩 목표를 달성하는 점진적인 스타일의 증명을 자연스럽게 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They will be improved over time.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173133Z" creationid="tlqk3" creationdate="20220603T173133Z">
        <seg>그들은 시간이 지나면서 개선될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>They work as follows.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174610Z" creationid="tlqk3" creationdate="20220604T174610Z">
        <seg>이는 다음과 같이 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Things get
much more interesting when the constructors act on elements of the
very type being defined.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T153904Z" creationid="tlqk3" creationdate="20220527T153904Z">
        <seg>생성자가 정의될 바로 그 유형의 원소들에 작용할 때 훨씬 더 흥미롭게 될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think about what is going on here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174007Z" creationid="tlqk35" creationdate="20220321T174007Z">
        <seg>무슨 일이 생긴 건지 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think about what these expressions mean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142638Z" creationid="tlqk35" creationdate="20220321T142638Z">
        <seg>이 표현식의 의미에 대해 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of <bpt i="1" x="1">&lt;g1&gt;</bpt>Type 0<ept i="1">&lt;/g1&gt;</ept> as a universe of "small" or "ordinary" types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141626Z" creationid="tlqk35" creationdate="20220321T141626Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Type 0<ept i="1">&lt;/g1&gt;</ept>는 "작은" 또는 "평범한" 유형들의 세계라고 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of <bpt i="1" x="1">&lt;g1&gt;</bpt>sunday<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>monday<ept i="2">&lt;/g2&gt;</ept>, ... , <bpt i="3" x="3">&lt;g3&gt;</bpt>saturday<ept i="3">&lt;/g3&gt;</ept> as
being distinct elements of <bpt i="4" x="4">&lt;g4&gt;</bpt>Weekday<ept i="4">&lt;/g4&gt;</ept>, with no other distinguishing
properties.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T145728Z" creationid="tlqk3" creationdate="20220526T145728Z">
        <seg>다른 성질을 구별할 것 없이 <bpt i="1" x="1">&lt;g1&gt;</bpt>sunday<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>monday<ept i="2">&lt;/g2&gt;</ept>, ... , <bpt i="3" x="3">&lt;g3&gt;</bpt>saturday<ept i="3">&lt;/g3&gt;</ept>를 <bpt i="4" x="4">&lt;g4&gt;</bpt>Weekday<ept i="4">&lt;/g4&gt;</ept>의 구별되는 원소로서 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of this as saying "split on cases as to whether <bpt i="1" x="1">&lt;g1&gt;</bpt>m + 3 * k<ept i="1">&lt;/g1&gt;</ept> is
zero or the successor of some number." The result is functionally
equivalent to the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170241Z" creationid="tlqk3" creationdate="20220527T170241Z">
        <seg>이것을 "<bpt i="1" x="1">&lt;g1&gt;</bpt>m + 3 * k<ept i="1">&lt;/g1&gt;</ept>이 0이거나 어떤 수의 계승자인지로 경우가 나뉜다"고 생각합시다. 이 결과는 다음과 기능적으로 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Think of this as the function from <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept> to <bpt i="8" x="8">&lt;g8&gt;</bpt>β<ept i="8">&lt;/g8&gt;</ept> which maps
any value <bpt i="9" x="9">&lt;g9&gt;</bpt>x<ept i="9">&lt;/g9&gt;</ept> to the value <bpt i="10" x="10">&lt;g10&gt;</bpt>t<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142516Z" creationid="tlqk35" creationdate="20220321T142516Z">
        <seg>이를  임의의 값 <bpt i="9" x="9">&lt;g9&gt;</bpt>x<ept i="9">&lt;/g9&gt;</ept>에서 값 <bpt i="10" x="10">&lt;g10&gt;</bpt>t<ept i="10">&lt;/g10&gt;</ept>로 대응시키는 <bpt i="7" x="7">&lt;g7&gt;</bpt>α<ept i="7">&lt;/g7&gt;</ept>에서 <bpt i="8" x="8">&lt;g8&gt;</bpt>β<ept i="8">&lt;/g8&gt;</ept>까지의 함수로 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This
form of <bpt i="5" x="5">&lt;g5&gt;</bpt>cases<ept i="5">&lt;/g5&gt;</ept> will <bpt i="6" x="6">&lt;g6&gt;</bpt>not<ept i="6">&lt;/g6&gt;</ept> revert any hypotheses that also mention
the expression in the equation (in this case, <bpt i="7" x="7">&lt;g7&gt;</bpt>m + 3 * k<ept i="7">&lt;/g7&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T170551Z" creationid="tlqk3" creationdate="20220527T170551Z">
        <seg>이 <bpt i="5" x="5">&lt;g5&gt;</bpt>cases<ept i="5">&lt;/g5&gt;</ept>의 형태는 방정식(이 경우 <bpt i="7" x="7">&lt;g7&gt;</bpt>m + 3 * k<ept i="7">&lt;/g7&gt;</ept>)에서 표현식을 언급한 적 있는 어떤 가정도 되돌리지 <bpt i="6" x="6">&lt;g6&gt;</bpt>않을<ept i="6">&lt;/g6&gt;</ept> 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This
is not a trivial affair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181031Z" creationid="tlqk35" creationdate="20220321T181031Z">
        <seg>이것은 명백한 문제가 아닙니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This
is useful for discharging goals not supported by <bpt i="2" x="2">&lt;g2&gt;</bpt>conv<ept i="2">&lt;/g2&gt;</ept> mode, and
applying custom congruence and extensionality lemmas.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T184746Z" creationid="tlqk3" creationdate="20220604T184746Z">
        <seg>이는 <bpt i="2" x="2">&lt;g2&gt;</bpt>conv<ept i="2">&lt;/g2&gt;</ept> 모드에서 지원되지 않는 목표를 실행하고 사용자 정의 합동 및 확장 보조정리를 적용하는 데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This
pattern, deriving an arbitrary fact from contradictory hypotheses, is
quite common, and is represented by <bpt i="3" x="3">&lt;g3&gt;</bpt>absurd<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164500Z" creationid="tlqk35" creationdate="20220321T164500Z">
        <seg>모순적인 가정들로부터 어떤 사실을 얻는 이런 패턴은 꽤 흔하고 <bpt i="3" x="3">&lt;g3&gt;</bpt>absurd<ept i="3">&lt;/g3&gt;</ept>로 표현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This
special case is known as <bpt i="4" x="4">&lt;g4&gt;</bpt>singleton elimination<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T163850Z" creationid="tlqk35" creationdate="20220528T163850Z">
        <seg>이 특별한 경우는 <bpt i="4" x="4">&lt;g4&gt;</bpt>한번에 한 제거(singleton elimination)<ept i="4">&lt;/g4&gt;</ept>로도 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This annotation can also be
written using as <bpt i="6" x="6">&lt;g6&gt;</bpt>⦃y : Nat⦄<ept i="6">&lt;/g6&gt;</ept>, where the unicode brackets are entered
as <bpt i="7" x="7">&lt;g7&gt;</bpt>\{{<ept i="7">&lt;/g7&gt;</ept> and <bpt i="8" x="8">&lt;g8&gt;</bpt>\}}<ept i="8">&lt;/g8&gt;</ept>, respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185427Z" creationid="tlqk3" creationdate="20220525T185427Z">
        <seg>이런 주석은 <bpt i="6" x="6">&lt;g6&gt;</bpt>⦃y : Nat⦄<ept i="6">&lt;/g6&gt;</ept>으로서 사용해 쓸 수도 있습니다. 여기서 유니코드 괄호는 각각 <bpt i="7" x="7">&lt;g7&gt;</bpt>\{{<ept i="7">&lt;/g7&gt;</ept>과 <bpt i="8" x="8">&lt;g8&gt;</bpt>\}}<ept i="8">&lt;/g8&gt;</ept>으로 쳐서 입력될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This approach is more robust than using <bpt i="1" x="1">&lt;g1&gt;</bpt>by assumption<ept i="1">&lt;/g1&gt;</ept>, because the
type of the assumption that needs to be inferred is given
explicitly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183641Z" creationid="tlqk35" creationdate="20220321T183641Z">
        <seg>추론될 필요가 있는 가정의 유형은 명백하게 주어져야 하므로 이런 접근법은 <bpt i="1" x="1">&lt;g1&gt;</bpt>by assumption<ept i="1">&lt;/g1&gt;</ept>을 사용하는 것보다 더 견고합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This approach would provide us with a reasonable way of building assertions and proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155149Z" creationid="tlqk35" creationdate="20220321T155149Z">
        <seg>이런 접근은 주장과 증명을 만드는 합리적인 방법을 우리에게 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This book is designed to teach you to develop and verify proofs in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132009Z" creationid="tlqk35" creationdate="20220321T132009Z">
        <seg>이 책은 Lean에서 증명을 검증하고 세울 수 있도록 당신을 가르치게끔 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This can be helpful in
indicating the separate proofs of multiple subgoals introduced by a
tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144940Z" creationid="tlqk35" creationdate="20220524T144940Z">
        <seg>이는 전략에 의해 생긴 다수의 하위 목표를의 증명을 나누는 것을 지칭하는데 유용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This causes class inference to chain through instances recursively, backtracking when necessary, in a Prolog-like search.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161229Z" creationid="tlqk3" creationdate="20220604T161229Z">
        <seg>Prolog 같은 탐색에서 필요할 때 역추적하는데 개체를 통한 클래스 추론이 재귀적으로 연결되게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have a matching
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144154Z" creationid="tlqk35" creationdate="20220321T144154Z">
        <seg>이것은 당신의 의도를 명확히 만들고 Lean은 정의의 우변에 일치하는 유형이 아닌 경우 에러를 표시할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This definition is inconvenient to work with, however.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T170351Z" creationid="tlqk35" creationdate="20220528T165954Z">
        <seg>이그러나  정의는 작업하기에 불편합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This definition of <bpt i="1" x="1">&lt;g1&gt;</bpt>ident<ept i="1">&lt;/g1&gt;</ept> here has the same effect as the one
above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153405Z" creationid="tlqk35" creationdate="20220321T153405Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>ident<ept i="1">&lt;/g1&gt;</ept>의 이 정의는 여기서 위의 것과 같이 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This does not look very different from an ordinary pattern matching
definition, but the point is that a <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> can be used anywhere in
an expression, and with arbitrary arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T183000Z" creationid="tlqk3" creationdate="20220603T183000Z">
        <seg>이것은 평범한 패턴 매칭 정의와 아주 달라보이지 않지만 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>가 임의의 인수로 표현식의 어디서든 사용될 수 있다는 점이 다릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example is similar to the previous one, but now an input to
<bpt i="1" x="1">&lt;g1&gt;</bpt>sum_example<ept i="1">&lt;/g1&gt;</ept> is implicitly either of the form <bpt i="2" x="2">&lt;g2&gt;</bpt>inl n<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>inr n<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160524Z" creationid="tlqk3" creationdate="20220526T155207Z">
        <seg>이 예제는 이전의 것과 닮았습니다. 하지만 <bpt i="1" x="1">&lt;g1&gt;</bpt>sum_example<ept i="1">&lt;/g1&gt;</ept>의 입력이 이제 암시적으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>inl n<ept i="2">&lt;/g2&gt;</ept>이나 <bpt i="3" x="3">&lt;g3&gt;</bpt>inr n<ept i="3">&lt;/g3&gt;</ept>의 꼴 둘 중의 하나입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This example simultaneously introduces the inductive type, <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod<ept i="1">&lt;/g1&gt;</ept>,
its constructor, <bpt i="2" x="2">&lt;g2&gt;</bpt>mk<ept i="2">&lt;/g2&gt;</ept>, the usual eliminators (<bpt i="3" x="3">&lt;g3&gt;</bpt>rec<ept i="3">&lt;/g3&gt;</ept> and
<bpt i="4" x="4">&lt;g4&gt;</bpt>recOn<ept i="4">&lt;/g4&gt;</ept>), as well as the projections, <bpt i="5" x="5">&lt;g5&gt;</bpt>fst<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>snd<ept i="6">&lt;/g6&gt;</ept>, as
defined above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152041Z" creationid="tlqk3" creationdate="20220526T161853Z">
        <seg>이 예제는 동시에 귀납형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prod<ept i="1">&lt;/g1&gt;</ept>과 그것의 생성자 <bpt i="2" x="2">&lt;g2&gt;</bpt>mk<ept i="2">&lt;/g2&gt;</ept>, 평범한 제거자 (<bpt i="3" x="3">&lt;g3&gt;</bpt>rec<ept i="3">&lt;/g3&gt;</ept>과
<bpt i="4" x="4">&lt;g4&gt;</bpt>recOn<ept i="4">&lt;/g4&gt;</ept>) 뿐만 아니라 위에서 정의한 대로 투영 <bpt i="5" x="5">&lt;g5&gt;</bpt>fst<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>snd<ept i="6">&lt;/g6&gt;</ept>을 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This explains the
type annotation of the function <bpt i="5" x="5">&lt;g5&gt;</bpt>List<ept i="5">&lt;/g5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141932Z" creationid="tlqk35" creationdate="20220321T141932Z">
        <seg>이는 <bpt i="5" x="5">&lt;g5&gt;</bpt>List<ept i="5">&lt;/g5&gt;</ept>함수의 유형 표기를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This feature
allows us to simulate a form of <bpt i="2" x="2">&lt;g2&gt;</bpt>inheritance<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180648Z" creationid="tlqk35" creationdate="20220528T180648Z">
        <seg>이 기능은 우리가 <bpt i="2" x="2">&lt;g2&gt;</bpt>상속(inheritance)<ept i="2">&lt;/g2&gt;</ept>의 형태를 모사하도록 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This feature of the framework is so important that the library defines a notation <bpt i="1" x="1">&lt;g1&gt;</bpt>rfl<ept i="1">&lt;/g1&gt;</ept> for <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.refl _<ept i="2">&lt;/g2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T185425Z" creationid="tlqk35" creationdate="20220321T175649Z">
        <seg>프레임워크의 이 특징은 너무 중요해서 라이브러리가 <bpt i="2" x="2">&lt;g2&gt;</bpt>Eq.refl _<ept i="2">&lt;/g2&gt;</ept>에 대한 기호 <bpt i="1" x="1">&lt;g1&gt;</bpt>rfl<ept i="1">&lt;/g1&gt;</ept>을 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This function is used by the <bpt i="3" x="3">&lt;g3&gt;</bpt>#eval<ept i="3">&lt;/g3&gt;</ept> command to display <bpt i="4" x="4">&lt;g4&gt;</bpt>Weekday<ept i="4">&lt;/g4&gt;</ept> objects.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T150918Z" creationid="tlqk3" creationdate="20220526T150918Z">
        <seg>이 함수는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Weekday<ept i="4">&lt;/g4&gt;</ept>  대상을 표시하도록 <bpt i="3" x="3">&lt;g3&gt;</bpt>#eval<ept i="3">&lt;/g3&gt;</ept> 명령으로 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This gives you a way of creating pairs of natural
numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141135Z" creationid="tlqk35" creationdate="20220321T141135Z">
        <seg>이는 여러분에게 자연수의 쌍을 만들 수 있는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This gives you a way of extracting
its two components.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141215Z" creationid="tlqk35" creationdate="20220321T141215Z">
        <seg>이는 여러분에게 순서쌍의 두 성분을 추출하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This guarantees that Lean will favor other instances and fall back on
<bpt i="1" x="1">&lt;g1&gt;</bpt>propDecidable<ept i="1">&lt;/g1&gt;</ept> only after other attempts to infer decidability have
failed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174346Z" creationid="tlqk3" creationdate="20220604T174346Z">
        <seg>이렇게 하면 린이 다른 개체를 선호하고 결정가능성을 추론하려는 다른 시도가 실패한 후에만 <bpt i="1" x="1">&lt;g1&gt;</bpt>propDecidable<ept i="1">&lt;/g1&gt;</ept>으로 후퇴함을 보장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This instructs Lean's elaborator to use the value
<bpt i="4" x="4">&lt;g4&gt;</bpt>T<ept i="4">&lt;/g4&gt;</ept> as the type of <bpt i="5" x="5">&lt;g5&gt;</bpt>e<ept i="5">&lt;/g5&gt;</ept> when trying to resolve implicit
arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153538Z" creationid="tlqk35" creationdate="20220321T153538Z">
        <seg>이것은 린의 협력기가 암시적 인수를 해결하려고 시도할 때 <bpt i="5" x="5">&lt;g5&gt;</bpt>e<ept i="5">&lt;/g5&gt;</ept>의 유형으로 <bpt i="4" x="4">&lt;g4&gt;</bpt>T<ept i="4">&lt;/g4&gt;</ept>값을 사용하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is
followed by nested case splits on the next two arguments, and in each
case the equation compiler rules out the cases are not compatible with
the first pattern.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145940Z" creationid="tlqk3" creationdate="20220604T145940Z">
        <seg>이것은 다음 두 인수에 대한 중첩된 경우 분할을 따르고 각 경우에서 방정식 컴파일러는 첫 번째 패턴과 적합하지 않은 경우를 배제합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is
known as an "implicit argument."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152804Z" creationid="tlqk35" creationdate="20220321T152804Z">
        <seg>이것은 "암시적 인자"라고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152741Z" creationid="tlqk35" creationdate="20220321T152741Z">
        <seg>이는 의존 유형론의 핵심 특징입니다. 항은 많은 정보를 전달하고 종종 그 정보의 몇은  맥락으로부터 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a good place to introduce another device Lean offers to help
structure long proofs, namely, the <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> construct, which
introduces an auxiliary subgoal in a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165101Z" creationid="tlqk35" creationdate="20220321T165101Z">
        <seg>이곳은 린이 긴 증명을 구조화하도록 돕는 또다른 장치를 도입하기에 적절합니다. 주로  <bpt i="1" x="1">&lt;g1&gt;</bpt>have<ept i="1">&lt;/g1&gt;</ept> 생성자인데 이는 증명의 보조적인 세부목표를 도입합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a good place to mention another inductive type, denoted
<bpt i="1" x="1">&lt;g1&gt;</bpt>{x : α // p}<ept i="1">&lt;/g1&gt;</ept>, which is sort of a hybrid between
<bpt i="2" x="2">&lt;g2&gt;</bpt>∃ x : α, P<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>Σ x : α, P<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152123Z" creationid="tlqk3" creationdate="20220527T153355Z">
        <seg>여기서 또 다른 귀납형 <bpt i="2" x="2">&lt;g2&gt;</bpt>∃ x : α, P<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>Σ x : α, P<ept i="3">&lt;/g3&gt;</ept>이 섞인 <bpt i="1" x="1">&lt;g1&gt;</bpt>{x : α // p}<ept i="1">&lt;/g1&gt;</ept>으로 나타낸 귀납형을 얘기하기 좋은 곳 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is a notoriously inefficient way of
computing the fibonacci function, however, with an execution time that
is exponential in <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T163724Z" creationid="tlqk3" creationdate="20220603T163724Z">
        <seg>이것은 계산 시간이 <bpt i="7" x="7">&lt;g7&gt;</bpt>n<ept i="7">&lt;/g7&gt;</ept>에 대해 지수적인 피보나치 함수를 계산하는 악명높게 비효율적인 방식이지만</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is an instance of a <bpt i="1" x="1">&lt;g1&gt;</bpt>dependent function type<ept i="1">&lt;/g1&gt;</ept>, or <bpt i="2" x="2">&lt;g2&gt;</bpt>dependent
arrow type<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151554Z" creationid="tlqk35" creationdate="20220321T151554Z">
        <seg>이것은 <bpt i="1" x="1">&lt;g1&gt;</bpt>의존적 함수 유형<ept i="1">&lt;/g1&gt;</ept> 또는 <bpt i="2" x="2">&lt;g2&gt;</bpt>의존적 방향 유형<ept i="2">&lt;/g2&gt;</ept>의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is consistent with
the understanding that if <bpt i="4" x="4">&lt;g4&gt;</bpt>p : Prop<ept i="4">&lt;/g4&gt;</ept>, an element <bpt i="5" x="5">&lt;g5&gt;</bpt>hp : p<ept i="5">&lt;/g5&gt;</ept> carries
no data.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T152520Z" creationid="tlqk3" creationdate="20220527T152520Z">
        <seg>이것은 <bpt i="4" x="4">&lt;g4&gt;</bpt>p : Prop<ept i="4">&lt;/g4&gt;</ept>이면 원소 <bpt i="5" x="5">&lt;g5&gt;</bpt>hp : p<ept i="5">&lt;/g5&gt;</ept>는 아무 데이터도 나르지 않는다는 것의 이해와 일관됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is done by putting the arguments in
curly braces, as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153159Z" creationid="tlqk35" creationdate="20220321T153159Z">
        <seg>이것은 다음과 같이 인수를 중괄호 안에 두는 것으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is especially useful when the resulting goals can be finished off
in a uniform way, or, at least, when it is possible to make progress
on all of them uniformly.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T150429Z" creationid="tlqk35" creationdate="20220524T150429Z">
        <seg>이는 특히 출력되는 목표가 균일한 방식으로 마무리 될 때 혹은 적어도 
출력목표가 모두를 균일한 방식으로 진전을 만드는게 가능할 때 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is essentially just alternative notation for the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>
construct above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182820Z" creationid="tlqk35" creationdate="20220321T182820Z">
        <seg>이것은 본질적으로 위의 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 생성을 위한 대체 기호일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is illustrated in the
following example, in which we set the option <bpt i="10" x="10">&lt;g10&gt;</bpt>pp.explicit<ept i="10">&lt;/g10&gt;</ept> to true
to ask Lean's pretty-printer to show the implicit arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181146Z" creationid="tlqk35" creationdate="20220321T181146Z">
        <seg>이것은 다음 예제에서 보여주고 있습니다. 여기서 암시적 인자를 보여주는데 린의 깔끔한 출력을 사용하도록 <bpt i="10" x="10">&lt;g10&gt;</bpt>pp.explicit<ept i="10">&lt;/g10&gt;</ept> 옵션을 참으로 설정하였습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is known as <bpt i="5" x="5">&lt;g5&gt;</bpt>proof irrelevance,<ept i="5">&lt;/g5&gt;</ept> and is
consistent with the interpretation in the last paragraph.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160256Z" creationid="tlqk35" creationdate="20220321T160256Z">
        <seg>이것은 <bpt i="5" x="5">&lt;g5&gt;</bpt>증명 무연관<ept i="5">&lt;/g5&gt;</ept>으로 알려져 있고 이것은 마지막 문단에서 해석과 일관성이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is known as a <bpt i="1" x="1">&lt;g1&gt;</bpt>nested<ept i="1">&lt;/g1&gt;</ept> inductive type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152407Z" creationid="tlqk35" creationdate="20220528T170330Z">
        <seg>이것은 <bpt i="1" x="1">&lt;g1&gt;</bpt>중첩된(nested)<ept i="1">&lt;/g1&gt;</ept> 귀납형으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is necessary because these types are part
of the Lean "prelude" that is automatically imported when the system
is started.)</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T152225Z" creationid="tlqk3" creationdate="20220526T152225Z">
        <seg>이것은 이들 유형이 시스템이 시작할 때 자동적으로 불러와지는 린 "서막"의 일부이기 때문에 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is often used for names like <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.rec<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.recOn<ept i="2">&lt;/g2&gt;</ept>, to prevent
overloading of common names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180844Z" creationid="tlqk35" creationdate="20220524T180844Z">
        <seg>흔한 이름들의 과부하를 막기 위해 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.rec<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>Nat.recOn<ept i="2">&lt;/g2&gt;</ept> 같은 이름들에 종종 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is often useful as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163536Z" creationid="tlqk35" creationdate="20220321T163536Z">
        <seg>이것도 또한 종종 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is particularly important when we have implemented only the instance
<bpt i="5" x="5">&lt;g5&gt;</bpt>HMul α α α<ept i="5">&lt;/g5&gt;</ept>, and did not implement <bpt i="6" x="6">&lt;g6&gt;</bpt>HMul Nat α α<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170048Z" creationid="tlqk3" creationdate="20220604T170048Z">
        <seg>이것은 우리가 개체 <bpt i="5" x="5">&lt;g5&gt;</bpt>HMul α α α<ept i="5">&lt;/g5&gt;</ept>만 구현하고 <bpt i="6" x="6">&lt;g6&gt;</bpt>HMul Nat α α<ept i="6">&lt;/g6&gt;</ept>을 구현하지 않았을 때 특히 중요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is similar to the way
that computer scientists occasionally blur the distinction between
syntax and semantics by saying, at times, that a program "computes" a
certain function, and at other times speaking as though the program
"is" the function in question.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160449Z" creationid="tlqk35" creationdate="20220321T160449Z">
        <seg>이것은 컴퓨터 과학자들이 때때로 프로그램이 특정 함수를 "계산"한다고 말함으로써 문법과 의미론의 구분을 모호하게 하는 방식과 유사합니다. 그리고 다른 때에는 프로그램이 문제의 함수인 것처럼 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the approach followed in the Calculus of Constructions, and
hence in Lean as well.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155654Z" creationid="tlqk35" creationdate="20220321T155654Z">
        <seg>이는 직관주의적 계산법에 따른 접근법입니다. 그리고 이는 린에서도 마찬가지 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the elimination rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173854Z" creationid="tlqk35" creationdate="20220321T173854Z">
        <seg>이것은 제거 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is the introduction rule.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173809Z" creationid="tlqk35" creationdate="20220321T173809Z">
        <seg>이것은 도입 규칙입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is tricky; you will have to define an auxiliary function.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181617Z" creationid="tlqk3" creationdate="20220603T181617Z">
        <seg>이것은 교활해서 여러분은 부가함수를 정의해야만 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This is why the numeral
<bpt i="9" x="9">&lt;g9&gt;</bpt>2<ept i="9">&lt;/g9&gt;</ept> has type <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat<ept i="10">&lt;/g10&gt;</ept> when the expected type is not known.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165601Z" creationid="tlqk3" creationdate="20220604T165601Z">
        <seg>이것이 기대되는 유형을 모를 때 수치값 <bpt i="9" x="9">&lt;g9&gt;</bpt>2<ept i="9">&lt;/g9&gt;</ept>가 <bpt i="10" x="10">&lt;g10&gt;</bpt>Nat<ept i="10">&lt;/g10&gt;</ept>형이 되는 이유입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This kind of instance is
only active when you are inside of the namespace or open the namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170910Z" creationid="tlqk3" creationdate="20220604T170910Z">
        <seg>이런 종류의 개체는 여러분이 이름공간 안에 있거나 이름공간을 개방했을 때에만 활동적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This looks exactly like the definition of the constant function in the
last chapter, the only difference being that the arguments are
elements of <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept> rather than <bpt i="2" x="2">&lt;g2&gt;</bpt>Type<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160711Z" creationid="tlqk35" creationdate="20220321T160711Z">
        <seg>이는 지난 장에서 상수함수의 정의와 완전히 동일하게 보입니다. 유일한 차이는 인수는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>의 원소 보다는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Type<ept i="2">&lt;/g2&gt;</ept>의 원소라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This makes the first argument to <bpt i="1" x="1">&lt;g1&gt;</bpt>ident<ept i="1">&lt;/g1&gt;</ept> implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153306Z" creationid="tlqk35" creationdate="20220321T153306Z">
        <seg>이 첫 인수는 <bpt i="1" x="1">&lt;g1&gt;</bpt>ident<ept i="1">&lt;/g1&gt;</ept>를 암시적으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This manual is generated by <bpt i="1" x="1">&lt;g1&gt;</bpt>mdBook<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171705Z" creationid="tlqk35" creationdate="20220321T171705Z">
        <seg>이 메뉴얼은 <bpt i="1" x="1">&lt;g1&gt;</bpt>mdBook<ept i="1">&lt;/g1&gt;</ept>으로 생성되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This may often
be too restrictive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164708Z" creationid="tlqk3" creationdate="20220604T164708Z">
        <seg>이것은 종종 너무 제한적일 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means <bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept> is a function that takes any two functions as input
arguments, so long as those functions each take only one input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144440Z" creationid="tlqk35" creationdate="20220321T144440Z">
        <seg>이는 <bpt i="1" x="1">&lt;g1&gt;</bpt>compose<ept i="1">&lt;/g1&gt;</ept>가 하나의 입력만 받는 함수인 경우에만 임의의 두 함수를 입력 인수로 받는 함수임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means <bpt i="3" x="3">&lt;g3&gt;</bpt>compose<ept i="3">&lt;/g3&gt;</ept> can compose just about any 2 functions
so long as they each take one parameter, and so long as the type of
output of the second matches the input of the first.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144642Z" creationid="tlqk35" creationdate="20220321T144642Z">
        <seg>이는 <bpt i="3" x="3">&lt;g3&gt;</bpt>compose<ept i="3">&lt;/g3&gt;</ept>가 그들이 입력받는 두 함수 각각이 한 매개변수만 받고 두번째 함수의 출력 유형이 첫번째 함수의 입력 유형과 같은 한 합성할 수 있다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means simply that any argument
to the constructor in which it occurs is a dependent arrow type in which the
inductive type under definition occurs only as the resulting type,
where the indices are given in terms of constants and previous
arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152212Z" creationid="tlqk35" creationdate="20220528T160716Z">
        <seg>이 의미는 단순히 그것이 발생하는 생성자에서 임의의 인자가 귀납형이 정의 하에서 결과적인 유형으로써만 일어나는 의존 화살표 유형임을 의미합니다. 여기서 색인은 상수와 이전의 인수에 대해서 제시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that the system maintains an internal ordering
of terms, and only applies the identity if doing so decreases the
order.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171733Z" creationid="tlqk35" creationdate="20220524T162624Z">
        <seg>이는 시스템이 항들의 내부적인 순서를 유지한다는 의미일 뿐만 아니라 
만약 무한루프가 유발된다면 항등식들의 순위를 줄이도록 적용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This means that whenever you write <bpt i="7" x="7">&lt;g7&gt;</bpt>t<ept i="7">&lt;/g7&gt;</ept>, a placeholder, or
"hole," is inserted, so that <bpt i="8" x="8">&lt;g8&gt;</bpt>t<ept i="8">&lt;/g8&gt;</ept> is replaced by <bpt i="9" x="9">&lt;g9&gt;</bpt>@t _<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T184623Z" creationid="tlqk3" creationdate="20220525T184623Z">
        <seg>이는 우리가 <bpt i="7" x="7">&lt;g7&gt;</bpt>t<ept i="7">&lt;/g7&gt;</ept>를 쓰는 언제든지 자리차지자 혹은 "구멍"이 삽입되고 <bpt i="8" x="8">&lt;g8&gt;</bpt>t<ept i="8">&lt;/g8&gt;</ept>는 <bpt i="9" x="9">&lt;g9&gt;</bpt>@t _<ept i="9">&lt;/g9&gt;</ept>로 대체됨을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This might look more familiar to you if you know how functions work in
other programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143905Z" creationid="tlqk35" creationdate="20220321T143905Z">
        <seg>다른 프로그래밍언어에서 함수가 어떻게 동작하는지 안다면 이게 여러분에게 더 친숙하게 보일지 모르겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This mode allows to travel inside assumptions and
goals, even inside function abstractions and dependent arrows, to apply rewriting or
simplifying steps.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T182024Z" creationid="tlqk3" creationdate="20220604T182024Z">
        <seg>이 모드를 사용하면 가정과 목표 속과 심지어 함수 추상화 및 종속 화살표 내부를 이동하여 다시쓰기 또는 단순화 단계를 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides
a quick and convenient way to begin experimenting with the system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131839Z" creationid="tlqk35" creationdate="20220321T131839Z">
        <seg>이는 실험적으로 시스템을 시작하는데 편리하고 빠른 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides a compact way of unpacking hypotheses that make use of logical connectives.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T161750Z" creationid="tlqk3" creationdate="20220529T161750Z">
        <seg>이것은 논리연결사가 사용된 가정을 펼치는 간소한 방식을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides a convenient way of accessing functions without opening
a namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163410Z" creationid="tlqk35" creationdate="20220321T163410Z">
        <seg>이는 이름공간을 열지 않고 함수에 접근하는 편리한 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This provides a convenient way of accessing the fields
of a structure.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174414Z" creationid="tlqk35" creationdate="20220528T174414Z">
        <seg>이것은 구조체의 필드에 접근하는 편리한 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This reflects the interpretation of <bpt i="18" x="18">&lt;g18&gt;</bpt>Prop<ept i="18">&lt;/g18&gt;</ept> as the type
of propositions rather than data, and it is what makes <bpt i="19" x="19">&lt;g19&gt;</bpt>Prop<ept i="19">&lt;/g19&gt;</ept>
<bpt i="20" x="20">&lt;g20&gt;</bpt>impredicative<ept i="20">&lt;/g20&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175109Z" creationid="tlqk35" creationdate="20220321T175109Z">
        <seg>이것은 데이터보다는 명제의 유형으로써 <bpt i="18" x="18">&lt;g18&gt;</bpt>Prop<ept i="18">&lt;/g18&gt;</ept>의 해석을 반영했습니다. 그리고 이것이 <bpt i="19" x="19">&lt;g19&gt;</bpt>Prop<ept i="19">&lt;/g19&gt;</ept>을 <bpt i="20" x="20">&lt;g20&gt;</bpt>impredicative<ept i="20">&lt;/g20&gt;</ept>하게 만드는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This rule is sometimes called <bpt i="3" x="3">&lt;g3&gt;</bpt>ex falso<ept i="3">&lt;/g3&gt;</ept> (short for <bpt i="4" x="4">&lt;g4&gt;</bpt>ex
falso sequitur quodlibet<ept i="4">&lt;/g4&gt;</ept>), or the <bpt i="5" x="5">&lt;g5&gt;</bpt>principle of explosion<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164428Z" creationid="tlqk35" creationdate="20220321T164428Z">
        <seg>이 규칙은 때때로 <bpt i="3" x="3">&lt;g3&gt;</bpt>ex falso<ept i="3">&lt;/g3&gt;</ept> (라틴어 <bpt i="4" x="4">&lt;g4&gt;</bpt>ex falso sequitur quodlibet<ept i="4">&lt;/g4&gt;</ept>을 줄인 것), 또는 <bpt i="5" x="5">&lt;g5&gt;</bpt>폭발의 원리(principle of explosion)<ept i="5">&lt;/g5&gt;</ept>라고 불립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This section provides additional information for those
interested in the axiomatic foundations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T155229Z" creationid="tlqk35" creationdate="20220528T155229Z">
        <seg>이 섹션은 공리적 기초에 대해 흥미로워하는 이들을 위한 추가 정보를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This sets a very high standard: every rule of inference and every step of a
calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and
rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131444Z" creationid="tlqk35" creationdate="20220321T131444Z">
        <seg>이것은 아주 높은 기준을 설정합니다. 모든 추론 규칙과 계산의 모든 계산 과정은 선행된(기초 공리와 규칙으로 거슬러 내려가는) 정의와 정리에 호소하여 정당화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This simple
device is extremely useful when it comes to structuring long proofs,
since we can use intermediate <bpt i="7" x="7">&lt;g7&gt;</bpt>have<ept i="7">&lt;/g7&gt;</ept>'s as stepping stones leading to
the final goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165215Z" creationid="tlqk35" creationdate="20220321T165215Z">
        <seg>이 단순한 장치는 긴 증명을 구조화 해야 할 때 아주 유용합니다. 왜냐하면 우리는 간간히 <bpt i="7" x="7">&lt;g7&gt;</bpt>have<ept i="7">&lt;/g7&gt;</ept>를 최종 목표로 이끄는 주춧돌로써 쓰기 때문입다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This tells Lean to use the <bpt i="1" x="1">&lt;g1&gt;</bpt>assumption<ept i="1">&lt;/g1&gt;</ept> tactic, which, in turn,
proves the goal by finding a suitable hypothesis in the local
context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183420Z" creationid="tlqk35" creationdate="20220321T183420Z">
        <seg>이것은 린에게 <bpt i="1" x="1">&lt;g1&gt;</bpt>assumption<ept i="1">&lt;/g1&gt;</ept> 전략을 사용하라고 말합니다. 따라서 이 전략은 현재 상황판에서 적절한 가정을 찾아 목표를 증명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This tutorial describes the current version of Lean, known as Lean 4.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131956Z" creationid="tlqk35" creationdate="20220321T131956Z">
        <seg>이 튜토리얼은 린의 현재 버전(린 4)를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This tutorial is an open access project maintained on Github.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134813Z" creationid="tlqk35" creationdate="20220321T134813Z">
        <seg>이 튜토리얼은 깃허브로 관리되어 누구나 접근할 수 있는 프로젝트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This type depends on <bpt i="8" x="8">&lt;g8&gt;</bpt>two<ept i="8">&lt;/g8&gt;</ept> parameters: the type of the
elements in the vector (<bpt i="9" x="9">&lt;g9&gt;</bpt>α : Type<ept i="9">&lt;/g9&gt;</ept>) and the length of the vector
<bpt i="10" x="10">&lt;g10&gt;</bpt>n : Nat<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150957Z" creationid="tlqk35" creationdate="20220321T150957Z">
        <seg>이 유형은 <bpt i="8" x="8">&lt;g8&gt;</bpt>두<ept i="8">&lt;/g8&gt;</ept> 매개변수에 의존합니다. 하나는 벡터의 원소의 유형 (<bpt i="9" x="9">&lt;g9&gt;</bpt>α : Type<ept i="9">&lt;/g9&gt;</ept>)이고 또 다른 하나는 벡터의 길이<bpt i="10" x="10">&lt;g10&gt;</bpt>n : Nat<ept i="10">&lt;/g10&gt;</ept>입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This underscore is
known as a <bpt i="1" x="1">&lt;g1&gt;</bpt>wildcard pattern<ept i="1">&lt;/g1&gt;</ept>, or an <bpt i="2" x="2">&lt;g2&gt;</bpt>anonymous variable<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164641Z" creationid="tlqk3" creationdate="20220529T163226Z">
        <seg>이 밑줄 문자는 <bpt i="1" x="1">&lt;g1&gt;</bpt>와일드카드 패턴(wildcard pattern)<ept i="1">&lt;/g1&gt;</ept>혹은 <bpt i="2" x="2">&lt;g2&gt;</bpt>익명 변수(anonymous variable)<ept i="2">&lt;/g2&gt;</ept>로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This version of
<bpt i="3" x="3">&lt;g3&gt;</bpt>add<ept i="3">&lt;/g3&gt;</ept> is the Lean analogue of the Haskell term <bpt i="4" x="4">&lt;g4&gt;</bpt>add :: Add a =&gt; a -&gt; a -&gt; a<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154414Z" creationid="tlqk3" creationdate="20220604T154414Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>add<ept i="3">&lt;/g3&gt;</ept>의 이 버전은 하스켈 항 <bpt i="4" x="4">&lt;g4&gt;</bpt>add :: Add a =&gt; a -&gt; a -&gt; a<ept i="4">&lt;/g4&gt;</ept>의 린 닮은꼴입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>This version of the text assumes you’re using Lean 4.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171351Z" creationid="tlqk35" creationdate="20220321T171351Z">
        <seg>이 버전의 책은 여러분이 Lean 4를 사용한다고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Those not inclined to this ideology can view it, rather, as a simple
coding trick.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155921Z" creationid="tlqk35" creationdate="20220321T155921Z">
        <seg>이 이데올로기에 편향되지 않은 사람들은 꽤나 단순한 코딩 트릭으로 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Throughout the text you will find examples of Lean code like the one below:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134728Z" creationid="tlqk35" creationdate="20220321T134728Z">
        <seg>이 교재에서 여러분은 아래와 같은 린 코드 예제를 보게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus all theorems in the library
that rely on decidability assumptions are freely available when you
want to reason classically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173904Z" creationid="tlqk3" creationdate="20220604T173904Z">
        <seg>따라서 결정가능성 가정에 의존하는 라이브러리 속 모든 정리는 여러분이 고전적으로 추론하는 것을 원할 때 자유롭게 이용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus both of the following
proofs of <bpt i="5" x="5">&lt;g5&gt;</bpt>zero_add<ept i="5">&lt;/g5&gt;</ept> work:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173354Z" creationid="tlqk3" creationdate="20220529T173354Z">
        <seg>따라서 <bpt i="5" x="5">&lt;g5&gt;</bpt>zero_add<ept i="5">&lt;/g5&gt;</ept>의 다음 증명들은 모두 작동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus if the application of
theorem <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept> to a single goal produces four subgoals, one would
expect the proof to look like this:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T145553Z" creationid="tlqk35" creationdate="20220524T145553Z">
        <seg>따라서 <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept> 정리를 한 목표에 적용하여 네 개의 하위 목표를 만들려고 한다면 
누군가는 이 같은 증명을 기대할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus namespaces
give you a way to manage names in your working environment.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150500Z" creationid="tlqk35" creationdate="20220321T150500Z">
        <seg>따라서 이름공간은 당신의 작업 환경 속에 이름을 관리하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus the
proof term above could be written more concisely:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164020Z" creationid="tlqk35" creationdate="20220321T164020Z">
        <seg>따라서 위의 증명 항을 더 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus the string <bpt i="7" x="7">&lt;g7&gt;</bpt>a + b + c<ept i="7">&lt;/g7&gt;</ept> cannot be parsed as the equivalent of
<bpt i="8" x="8">&lt;g8&gt;</bpt>a + (b + c)<ept i="8">&lt;/g8&gt;</ept> because the right-hand side operand of an <bpt i="9" x="9">&lt;g9&gt;</bpt>infixl<ept i="9">&lt;/g9&gt;</ept> notation
has precedence one greater than the notation itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122944Z" creationid="tlqk3" creationdate="20220526T122944Z">
        <seg>따라서 문자열 <bpt i="7" x="7">&lt;g7&gt;</bpt>a + b + c<ept i="7">&lt;/g7&gt;</ept>는 <bpt i="8" x="8">&lt;g8&gt;</bpt>a + (b + c)<ept i="8">&lt;/g8&gt;</ept>와 동등한 것으로 분석될 수 없습니다. 왜냐하면 <bpt i="9" x="9">&lt;g9&gt;</bpt>infixl<ept i="9">&lt;/g9&gt;</ept>표기의 우변의 피연산자가 그 자체의 표기보다 하나 큰 우선순위를 갖기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus the term is equivalent to <bpt i="6" x="6">&lt;g6&gt;</bpt>a ~ (b ~ c)<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123651Z" creationid="tlqk3" creationdate="20220526T123651Z">
        <seg>따라서 항은 <bpt i="6" x="6">&lt;g6&gt;</bpt>a ~ (b ~ c)<ept i="6">&lt;/g6&gt;</ept>과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus we can carry out definitions by cases on decidable predicates on
the natural numbers:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173246Z" creationid="tlqk3" creationdate="20220604T173246Z">
        <seg>따라서 우리는 자연수에 대해 결정가능 술어에 대한 각 경우에 대해 정의를 이끌어 냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus we can think of an element <bpt i="8" x="8">&lt;g8&gt;</bpt>f<ept i="8">&lt;/g8&gt;</ept> of the
type <bpt i="9" x="9">&lt;g9&gt;</bpt>α → Option β<ept i="9">&lt;/g9&gt;</ept> as being a partial function from <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept> to <bpt i="11" x="11">&lt;g11&gt;</bpt>β<ept i="11">&lt;/g11&gt;</ept>:
for every <bpt i="12" x="12">&lt;g12&gt;</bpt>a : α<ept i="12">&lt;/g12&gt;</ept>, <bpt i="13" x="13">&lt;g13&gt;</bpt>f a<ept i="13">&lt;/g13&gt;</ept> either returns <bpt i="14" x="14">&lt;g14&gt;</bpt>none<ept i="14">&lt;/g14&gt;</ept>, indicating the
<bpt i="15" x="15">&lt;g15&gt;</bpt>f a<ept i="15">&lt;/g15&gt;</ept> is "undefined", or <bpt i="16" x="16">&lt;g16&gt;</bpt>some b<ept i="16">&lt;/g16&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T150624Z" creationid="tlqk3" creationdate="20220527T150624Z">
        <seg>따라서 우리는 <bpt i="9" x="9">&lt;g9&gt;</bpt>α → Option β<ept i="9">&lt;/g9&gt;</ept>형의 원소 <bpt i="8" x="8">&lt;g8&gt;</bpt>f<ept i="8">&lt;/g8&gt;</ept>를 모든 <bpt i="12" x="12">&lt;g12&gt;</bpt>a : α<ept i="12">&lt;/g12&gt;</ept>에 대한 <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>에서 <bpt i="11" x="11">&lt;g11&gt;</bpt>β<ept i="11">&lt;/g11&gt;</ept>까지의 부분함수인 것으로 생각할 수 있습니다. <bpt i="13" x="13">&lt;g13&gt;</bpt>f a<ept i="13">&lt;/g13&gt;</ept> <bpt i="15" x="15">&lt;g15&gt;</bpt>f a<ept i="15">&lt;/g15&gt;</ept>가 "정의되지 않음"을 가리키는 <bpt i="14" x="14">&lt;g14&gt;</bpt>none<ept i="14">&lt;/g14&gt;</ept>을 반환하거나 <bpt i="16" x="16">&lt;g16&gt;</bpt>some b<ept i="16">&lt;/g16&gt;</ept>을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus you can
view <bpt i="9" x="9">&lt;g9&gt;</bpt>Nat.add<ept i="9">&lt;/g9&gt;</ept> as a function that takes a natural number and returns
another function that takes a natural number and returns a natural
number.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140823Z" creationid="tlqk35" creationdate="20220321T140823Z">
        <seg>따라서 여러분은 <bpt i="9" x="9">&lt;g9&gt;</bpt>Nat.add<ept i="9">&lt;/g9&gt;</ept>은 자연수를 받아 자연수를 받고 자연수를 반환하는 또 다른 함수를 반환하는 함수로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, Lean 4
implements a new feature, <bpt i="2" x="2">&lt;g2&gt;</bpt>discriminant refinement<ept i="2">&lt;/g2&gt;</ept>, which includes
these extra discriminants automatically for us.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151209Z" creationid="tlqk3" creationdate="20220604T151209Z">
        <seg>따라서 린4에서 별도의 구별자를 자동적으로 포함시켜주는 새로운 기능 <bpt i="2" x="2">&lt;g2&gt;</bpt>discriminant refinement<ept i="2">&lt;/g2&gt;</ept>을 구현했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, all four of these definitions have the same net effect.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182726Z" creationid="tlqk3" creationdate="20220603T182726Z">
        <seg>따라서 이 모든 네 정의들은 동일한 알짜 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, for example, we can specialize the example from the previous section to the equality relation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175602Z" creationid="tlqk35" creationdate="20220321T175602Z">
        <seg>따라서, 우리는 이전 섹션에서 동등 관계까지의 예를 특수화 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, the standard library assigns a low priority to
the <bpt i="4" x="4">&lt;g4&gt;</bpt>propDecidable<ept i="4">&lt;/g4&gt;</ept> instance.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T174053Z" creationid="tlqk3" creationdate="20220604T174053Z">
        <seg>따라서 표준 라이브러리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>propDecidable<ept i="4">&lt;/g4&gt;</ept> 개체에 낮은 우선 순위를 할당합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, type class synthesis only starts after these two types are known.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164649Z" creationid="tlqk3" creationdate="20220604T164649Z">
        <seg>따라서 유형 클래스 합성은 이 두 유형이 알려진 뒤에야 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, you can
use the <bpt i="1" x="1">&lt;g1&gt;</bpt>local<ept i="1">&lt;/g1&gt;</ept> modifier to indicate that they only have effect until
the current <bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>namespace<ept i="3">&lt;/g3&gt;</ept> is closed, or until the end
of the current file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170416Z" creationid="tlqk3" creationdate="20220604T170416Z">
        <seg>따라서 여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>local<ept i="1">&lt;/g1&gt;</ept> 수정자로 그들이 오직 현재 닫힌<bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept>이나 <bpt i="3" x="3">&lt;g3&gt;</bpt>namespace<ept i="3">&lt;/g3&gt;</ept>까지만 혹은 현재 파일의 끝까지만 유효함을 나타내는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Thus, you can disable it using
the command <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option autoImplicit false<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134943Z" creationid="tlqk3" creationdate="20220526T134943Z">
        <seg>따라서 여러분은 이것을 <bpt i="1" x="1">&lt;g1&gt;</bpt>set_option autoImplicit false<ept i="1">&lt;/g1&gt;</ept> 명령을 써서 해제할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To
define the function <bpt i="9" x="9">&lt;g9&gt;</bpt>inverse<ept i="9">&lt;/g9&gt;</ept> below, we <bpt i="10" x="10">&lt;g10&gt;</bpt>have to<ept i="10">&lt;/g10&gt;</ept> mark <bpt i="11" x="11">&lt;g11&gt;</bpt>f a<ept i="11">&lt;/g11&gt;</ept>
inaccessible.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T144951Z" creationid="tlqk3" creationdate="20220604T144951Z">
        <seg>아래에서 함수 <bpt i="9" x="9">&lt;g9&gt;</bpt>inverse<ept i="9">&lt;/g9&gt;</ept>를 정의하려면 우리는 <bpt i="11" x="11">&lt;g11&gt;</bpt>f a<ept i="11">&lt;/g11&gt;</ept>를 접근 불가한 것으로 표시<bpt i="10" x="10">&lt;g10&gt;</bpt>해야만<ept i="10">&lt;/g10&gt;</ept> 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To <bpt i="2" x="2">&lt;g2&gt;</bpt>prove<ept i="2">&lt;/g2&gt;</ept> that
assertion, we need to exhibit a term <bpt i="3" x="3">&lt;g3&gt;</bpt>t : p<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160530Z" creationid="tlqk35" creationdate="20220321T160530Z">
        <seg>주장을 <bpt i="2" x="2">&lt;g2&gt;</bpt>증명<ept i="2">&lt;/g2&gt;</ept>하는 것은 <bpt i="3" x="3">&lt;g3&gt;</bpt>t : p<ept i="3">&lt;/g3&gt;</ept>의 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To build this manual, first install the fork via</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172002Z" creationid="tlqk35" creationdate="20220321T172002Z">
        <seg>이 메뉴얼을 생성하려면 fork를 다음을 거쳐 설치해야합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To define a function on <bpt i="4" x="4">&lt;g4&gt;</bpt>Prod α β<ept i="4">&lt;/g4&gt;</ept>, we
can assume the input is of the form <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept>, and we have to
specify the output, in terms of <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>b<ept i="7">&lt;/g7&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153210Z" creationid="tlqk3" creationdate="20220526T153210Z">
        <seg> <bpt i="4" x="4">&lt;g4&gt;</bpt>Prod α β<ept i="4">&lt;/g4&gt;</ept>에서 함수를 정의하기 위해서 우리는 입력의 형태가 <bpt i="5" x="5">&lt;g5&gt;</bpt>Prod.mk a b<ept i="5">&lt;/g5&gt;</ept>이라 가정할 수 있습니다. 그리고 <bpt i="6" x="6">&lt;g6&gt;</bpt>a<ept i="6">&lt;/g6&gt;</ept>와 <bpt i="7" x="7">&lt;g7&gt;</bpt>b<ept i="7">&lt;/g7&gt;</ept>에 대해 출력을 명시해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To define a function on <bpt i="5" x="5">&lt;g5&gt;</bpt>Sum α β<ept i="5">&lt;/g5&gt;</ept>, we have to
handle two cases: either the input is of the form <bpt i="6" x="6">&lt;g6&gt;</bpt>inl a<ept i="6">&lt;/g6&gt;</ept>, in which
case we have to specify an output value in terms of <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept>, or the
input is of the form <bpt i="8" x="8">&lt;g8&gt;</bpt>inr b<ept i="8">&lt;/g8&gt;</ept>, in which case we have to specify an
output value in terms of <bpt i="9" x="9">&lt;g9&gt;</bpt>b<ept i="9">&lt;/g9&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T155038Z" creationid="tlqk3" creationdate="20220526T155038Z">
        <seg><bpt i="5" x="5">&lt;g5&gt;</bpt>Sum α β<ept i="5">&lt;/g5&gt;</ept>에 함수를 정의하기 위해서 우리는 두 경우를 다뤄야 합니다. 입력이 <bpt i="6" x="6">&lt;g6&gt;</bpt>inl a<ept i="6">&lt;/g6&gt;</ept>의 꼴인 경우 우리는 출력값을 <bpt i="7" x="7">&lt;g7&gt;</bpt>a<ept i="7">&lt;/g7&gt;</ept>에 대해 나타내야 하고 혹은 입력이 <bpt i="8" x="8">&lt;g8&gt;</bpt>inr b<ept i="8">&lt;/g8&gt;</ept>꼴인 경우 우리는 출력값을 <bpt i="9" x="9">&lt;g9&gt;</bpt>b<ept i="9">&lt;/g9&gt;</ept>에 대해 나타내야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To define polymorphic constants, Lean allows you to
declare universe variables explicitly using the <bpt i="1" x="1">&lt;g1&gt;</bpt>universe<ept i="1">&lt;/g1&gt;</ept> command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142059Z" creationid="tlqk35" creationdate="20220321T142059Z">
        <seg>다형적인 상수를 정의하기 위해 린은 여러분이 세계 변수를 <bpt i="1" x="1">&lt;g1&gt;</bpt>universe<ept i="1">&lt;/g1&gt;</ept> 명령을 명시적으로 사용하여 선언할 수 있게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To define that function, Lean uses a suitable well-founded measure.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174058Z" creationid="tlqk3" creationdate="20220603T174058Z">
        <seg>이런 함수를 정의하려면 린은 적절히 잘 세워진 척도를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To each proposition <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> we associate a type that is
empty if <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> is false and has a single element, say <bpt i="3" x="3">&lt;g3&gt;</bpt>*<ept i="3">&lt;/g3&gt;</ept>, if <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>
is true.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155951Z" creationid="tlqk35" creationdate="20220321T155951Z">
        <seg>각 명제 <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>에 대해, 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>이 거짓이면 원소가 없고, <bpt i="4" x="4">&lt;g4&gt;</bpt>p<ept i="4">&lt;/g4&gt;</ept>가 참이면 한 원소(예: <bpt i="3" x="3">&lt;g3&gt;</bpt>*<ept i="3">&lt;/g3&gt;</ept>)가 있는 유형을 연관시킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To formally
express a mathematical assertion in the language of dependent type
theory, we need to exhibit a term <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160507Z" creationid="tlqk35" creationdate="20220321T160507Z">
        <seg>의존 유형론의 언어로 수학적 주장을 형식적으로 표현하기 위해 <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept>에 대한 항으로 나타낼 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To get used to using universal quantifiers, you should try some of the
exercises at the end of this section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174413Z" creationid="tlqk35" creationdate="20220321T174413Z">
        <seg>전칭 한정기호 사용에 익숙해지기 위해서 여러분은 이 섹션 끝의 연습문제들을 풀어보아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To handle structural recursion, the equation compiler uses
<bpt i="1" x="1">&lt;g1&gt;</bpt>course-of-values<ept i="1">&lt;/g1&gt;</ept> recursion, using constants <bpt i="2" x="2">&lt;g2&gt;</bpt>below<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>brecOn<ept i="3">&lt;/g3&gt;</ept>
that are automatically generated with each inductively defined
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T164135Z" creationid="tlqk3" creationdate="20220603T164135Z">
        <seg>구조적 재귀를 다루려고 방정식 컴파일러는 각 귀납적으로 정의된 유형으로부터 자동적으로 생성된 상수 <bpt i="2" x="2">&lt;g2&gt;</bpt>below<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>brecOn<ept i="3">&lt;/g3&gt;</ept>을 사용하여 <bpt i="1" x="1">&lt;g1&gt;</bpt>course-of-values<ept i="1">&lt;/g1&gt;</ept>재귀를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To help debug in these situations, Lean enables you to request a
trace of the search:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180419Z" creationid="tlqk3" creationdate="20220604T180419Z">
        <seg>이러한 상황에서 디버그를 돕기 위해 Lean을 사용하면 검색 추적을 요청할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To illustrate the difference, consider the following example, which
shows that a reflexive euclidean relation is both symmetric and
transitive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185734Z" creationid="tlqk3" creationdate="20220525T185734Z">
        <seg>차이를 설명하자면 유클리드 관계의 반사성은 모두 대칭적이고 추이적임을 보이는 다음 예제를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To make <bpt i="4" x="4">&lt;g4&gt;</bpt>dite<ept i="4">&lt;/g4&gt;</ept> more
convenient to use, Lean allows us to write <bpt i="5" x="5">&lt;g5&gt;</bpt>if h : c then t else e<ept i="5">&lt;/g5&gt;</ept>
instead of <bpt i="6" x="6">&lt;g6&gt;</bpt>dite c (λ h : c, t) (λ h : ¬ c, e)<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172832Z" creationid="tlqk3" creationdate="20220604T172832Z">
        <seg><bpt i="4" x="4">&lt;g4&gt;</bpt>dite<ept i="4">&lt;/g4&gt;</ept>를 사용하기 더 편리하게 만들기 위해 린은 우리가 <bpt i="6" x="6">&lt;g6&gt;</bpt>dite c (λ h : c, t) (λ h : ¬ c, e)<ept i="6">&lt;/g6&gt;</ept> 대신 <bpt i="5" x="5">&lt;g5&gt;</bpt>if h : c then t else e<ept i="5">&lt;/g5&gt;</ept>로 쓸 수 있게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To preserve the validity of the previous
goal, the <bpt i="4" x="4">&lt;g4&gt;</bpt>generalize<ept i="4">&lt;/g4&gt;</ept> tactic allows us to record the fact that
<bpt i="5" x="5">&lt;g5&gt;</bpt>3<ept i="5">&lt;/g5&gt;</ept> has been replaced by <bpt i="6" x="6">&lt;g6&gt;</bpt>x<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T065607Z" creationid="tlqk35" creationdate="20220522T065607Z">
        <seg>앞선 목표의 유효성을 보존하기 위해 <bpt i="4" x="4">&lt;g4&gt;</bpt>generalize<ept i="4">&lt;/g4&gt;</ept> 전략은 <bpt i="5" x="5">&lt;g5&gt;</bpt>3<ept i="5">&lt;/g5&gt;</ept>이 
<bpt i="6" x="6">&lt;g6&gt;</bpt>x<ept i="6">&lt;/g6&gt;</ept>로 대체되었음에 대한 사실을 기록하게 해줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To some who take a constructive view of logic and mathematics,
this is a faithful rendering of what it means to be a proposition: a
proposition <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept> represents a sort of data type, namely, a
specification of the type of data that constitutes a proof.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155851Z" creationid="tlqk35" creationdate="20220321T155851Z">
        <seg>논리와 수학에 직관주의적 관점을 갖는 누군가에게 이것은 명제가 되는 것의 의미를 충실하게 표현합니다. 명제 <bpt i="1" x="1">&lt;g1&gt;</bpt>p<ept i="1">&lt;/g1&gt;</ept>은 일종의 데이터 유형을 나타냅니다. 주로 증명을 만드는 데이터 유형의 명세입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start with, we can
avoid writing the term <bpt i="1" x="1">&lt;g1&gt;</bpt>Proof<ept i="1">&lt;/g1&gt;</ept> repeatedly by conflating <bpt i="2" x="2">&lt;g2&gt;</bpt>Proof p<ept i="2">&lt;/g2&gt;</ept>
with <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept> itself.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155247Z" creationid="tlqk35" creationdate="20220321T155247Z">
        <seg>그렇기 위해 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Proof p<ept i="2">&lt;/g2&gt;</ept>를 <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>를 같이 쓰는 것으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>Proof<ept i="1">&lt;/g1&gt;</ept>에 대한 반복적인 사용을 피할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start with, we can use anonymous "have" expressions to introduce an
auxiliary goal without having to label it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183308Z" creationid="tlqk35" creationdate="20220321T183308Z">
        <seg>우선, 우리는 익명 "have" 표현식으로 보조 목표의 이름 없이 도입하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To start with, you will learn the logical system that Lean is
based on, a version of <bpt i="1" x="1">&lt;g1&gt;</bpt>dependent type theory<ept i="1">&lt;/g1&gt;</ept> that is powerful enough to prove almost any conventional mathematical
theorem, and expressive enough to do it in a natural way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132047Z" creationid="tlqk35" creationdate="20220321T132047Z">
        <seg>먼저 여러분은 Lean이 기초하고 있는 논리 체계 즉 거의 모든 기존의 수학적 정리를 증명할 수 있을 만큼 강력하고 그것을 자연스럽게 할 수 있을 만큼 충분히 표현력이 뛰어난 <bpt i="1" x="1">&lt;g1&gt;</bpt>의존유형론<ept i="1">&lt;/g1&gt;</ept> 버전을 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To that end, the string <bpt i="1" x="1">&lt;g1&gt;</bpt>_root_<ept i="1">&lt;/g1&gt;</ept> is an
explicit description of the empty prefix.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180639Z" creationid="tlqk35" creationdate="20220524T180639Z">
        <seg>이 끝에서 문자열 <bpt i="1" x="1">&lt;g1&gt;</bpt>_root_<ept i="1">&lt;/g1&gt;</ept>이 빈 접두사를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To the kernel type
checker, there is no difference between the two.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160850Z" creationid="tlqk35" creationdate="20220321T160850Z">
        <seg>커널 유형 확인기에서 둘 사이의 차이는 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To understand the difficulty, consider what it would take
to define a function <bpt i="8" x="8">&lt;g8&gt;</bpt>tail<ept i="8">&lt;/g8&gt;</ept> which takes a vector
<bpt i="9" x="9">&lt;g9&gt;</bpt>v : vector α (succ n)<ept i="9">&lt;/g9&gt;</ept> and deletes the first element.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175752Z" creationid="tlqk3" creationdate="20220603T175752Z">
        <seg>어려움을 이해하려면 벡터 <bpt i="9" x="9">&lt;g9&gt;</bpt>v : vector α (succ n)<ept i="9">&lt;/g9&gt;</ept>를 받고 첫 번째 원소를 삭제하는 함수 <bpt i="8" x="8">&lt;g8&gt;</bpt>tail<ept i="8">&lt;/g8&gt;</ept>를 정의하는데 무엇이 필요한지 고려해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use Lean effectively you will inevitably need to make use of
definitions and theorems in the library.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130516Z" creationid="tlqk3" creationdate="20220526T130516Z">
        <seg>린을 효과적으로 사용하기 위해서 여러분은 라이브러리의 정의와 정리의 사용이 불가피하게 될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use all the hypotheses present in the local context when
simplifying, we can use the wildcard symbol, <bpt i="1" x="1">&lt;g1&gt;</bpt>*<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171708Z" creationid="tlqk35" creationdate="20220524T163644Z">
        <seg>단순화할 때 지역 상황에 나타난 모든 가정을 사용하기 위해서
우리는 와일드카드 기호 <bpt i="1" x="1">&lt;g1&gt;</bpt>*<ept i="1">&lt;/g1&gt;</ept>를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>To use this
principle, you have to open the classical namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165706Z" creationid="tlqk35" creationdate="20220321T165706Z">
        <seg>이 원리를 사용하기 위해서 여러분은 classical 이름공간을 열어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Too much information can be overwhelming, though, and
Lean's defaults are generally sufficient for ordinary interactions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130421Z" creationid="tlqk3" creationdate="20220526T130421Z">
        <seg>너무 많은 정보에 압도할 수 있지만 린의 기본설정도 평범한 상호작용에 일반적으로 충분합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>True</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162001Z" creationid="tlqk35" creationdate="20220321T162001Z">
        <seg>참</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Try also defining the function <bpt i="1" x="1">&lt;g1&gt;</bpt>length : {α : Type u} → List α → Nat<ept i="1">&lt;/g1&gt;</ept> that returns the length of a list,
and prove that it behaves as expected (for example, <bpt i="2" x="2">&lt;g2&gt;</bpt>length (append as bs) = length as + length bs<ept i="2">&lt;/g2&gt;</ept>).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163455Z" creationid="tlqk3" creationdate="20220527T163455Z">
        <seg>리스트의 길이를 반환하는  함수 <bpt i="1" x="1">&lt;g1&gt;</bpt>length : {α : Type u} → List α → Nat<ept i="1">&lt;/g1&gt;</ept>도 정의해 보세요. 그리고 이것 예상대로 동작하는지 증명하세요. (예를 들어 <bpt i="2" x="2">&lt;g2&gt;</bpt>length (append as bs) = length as + length bs<ept i="2">&lt;/g2&gt;</ept>)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Try defining other operations on the natural numbers, such as
multiplication, the predecessor function (with <bpt i="1" x="1">&lt;g1&gt;</bpt>pred 0 = 0<ept i="1">&lt;/g1&gt;</ept>),
truncated subtraction (with <bpt i="2" x="2">&lt;g2&gt;</bpt>n - m = 0<ept i="2">&lt;/g2&gt;</ept> when <bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept> is greater
than or equal to <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>), and exponentiation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T171042Z" creationid="tlqk35" creationdate="20220528T171042Z">
        <seg>자연수에 대해 곱셈, 선행자 함수 (<bpt i="1" x="1">&lt;g1&gt;</bpt>pred 0 = 0<ept i="1">&lt;/g1&gt;</ept>으로), 절단된 뺄셈( <bpt i="3" x="3">&lt;g3&gt;</bpt>m<ept i="3">&lt;/g3&gt;</ept> 이  <bpt i="4" x="4">&lt;g4&gt;</bpt>n<ept i="4">&lt;/g4&gt;</ept>)보다 크거나 같을 때 <bpt i="2" x="2">&lt;g2&gt;</bpt>n - m = 0<ept i="2">&lt;/g2&gt;</ept>으로)와 거듭제곱 같은 다른 연산을 정의해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Try proving these (one direction of the second of these
requires classical logic):</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183820Z" creationid="tlqk35" creationdate="20220321T183820Z">
        <seg>이것들을 증명해 보세요.(이들 두 번째 예제의 한쪽 방향은 고전논리가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Turning on implicit arguments shows that the elaborator has inferred
the decidability of the proposition <bpt i="1" x="1">&lt;g1&gt;</bpt>x &lt; a ∨ x &gt; b<ept i="1">&lt;/g1&gt;</ept>, simply by
applying appropriate instances.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173546Z" creationid="tlqk3" creationdate="20220604T173546Z">
        <seg>단순히 적절한 개체를 적용함으로써 암시적인 인수을 여는 것은 협력기가 명제 <bpt i="1" x="1">&lt;g1&gt;</bpt>x &lt; a ∨ x &gt; b<ept i="1">&lt;/g1&gt;</ept>의 결정가능성을 추론함을 보일 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two expressions that are equivalent up to
associativity and commutativity are then rewritten to the same
canonical form.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171722Z" creationid="tlqk35" creationdate="20220524T162902Z">
        <seg>그럼 결합성과 교환성에 한해 동등한 두 표현식은 같은 정식 형태로 다시쓰일 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Two more examples of inductive types in the library are the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152048Z" creationid="tlqk3" creationdate="20220527T150000Z">
        <seg>라이브러리에서 귀납형의 둘 이상의 예제가 다음에 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type classes</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152557Z" creationid="tlqk3" creationdate="20220604T152557Z">
        <seg>유형 클래스</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type classes are implemented using attributes in Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170239Z" creationid="tlqk3" creationdate="20220604T170239Z">
        <seg>유형 클래스는 린의 속성을 사용해 구현됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type classes were introduced as a principled way of enabling
ad-hoc polymorphism in functional programming languages.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152812Z" creationid="tlqk3" creationdate="20220604T152812Z">
        <seg>유형 클래스는 함수형 프로그래밍 언어에서 특수 목적(ad-hoc)의 다형성을 활성화하는 원칙적인 방법으로 도입되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Type inference is an important part of Lean:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144052Z" creationid="tlqk35" creationdate="20220321T144052Z">
        <seg>유형 추론은 Lean의 중요한 기능입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Types as objects</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141233Z" creationid="tlqk35" creationdate="20220321T141233Z">
        <seg>대상으로써 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Typically, the expression <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>
will depend on <bpt i="6" x="6">&lt;g6&gt;</bpt>x : α<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T173332Z" creationid="tlqk35" creationdate="20220321T173332Z">
        <seg>일반적으로 표현식 <bpt i="5" x="5">&lt;g5&gt;</bpt>p<ept i="5">&lt;/g5&gt;</ept>는 <bpt i="6" x="6">&lt;g6&gt;</bpt>x : α<ept i="6">&lt;/g6&gt;</ept>에 의존할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Under the hood, this is compiled as a single recursive definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173844Z" creationid="tlqk3" creationdate="20220603T173844Z">
        <seg>후드 아래에서 이것은 단일 재귀적 정의로 컴파일된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unicode</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162031Z" creationid="tlqk35" creationdate="20220321T161850Z">
        <seg>유니코드(Unicode)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unlike <bpt i="3" x="3">&lt;g3&gt;</bpt>section<ept i="3">&lt;/g3&gt;</ept>, namespaces require a name.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150420Z" creationid="tlqk35" creationdate="20220321T150420Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>section<ept i="3">&lt;/g3&gt;</ept>과는 달리, 이름공간은 이름이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Unsurprisingly, it produces exactly the same proof term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T060658Z" creationid="tlqk35" creationdate="20220522T060658Z">
        <seg>놀랄 것 없이, 이것은 정확히 동일한 증명항을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Use tactic combinators to obtain a one line proof of the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171454Z" creationid="tlqk35" creationdate="20220524T171454Z">
        <seg>다음의 한 줄 증명을 얻도록 전략조합자를 사용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Users can disable the implicit lambda feature by using <bpt i="1" x="1">&lt;g1&gt;</bpt>@<ept i="1">&lt;/g1&gt;</ept> or writing
a lambda expression with <bpt i="2" x="2">&lt;g2&gt;</bpt>{}<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>[]<ept i="3">&lt;/g3&gt;</ept> binder annotations.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135627Z" creationid="tlqk3" creationdate="20220526T135627Z">
        <seg>사용자는 <bpt i="1" x="1">&lt;g1&gt;</bpt>@<ept i="1">&lt;/g1&gt;</ept>을 사용하거나 <bpt i="2" x="2">&lt;g2&gt;</bpt>{}<ept i="2">&lt;/g2&gt;</ept> 이나 <bpt i="3" x="3">&lt;g3&gt;</bpt>[]<ept i="3">&lt;/g3&gt;</ept>의 결합 주석으로 람다 표현식을 쓰는 것으로 암시적인 람다 기능을 해제할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Users may also wish to make use of additional
libraries, or develop their own projects across multiple files.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173740Z" creationid="tlqk35" creationdate="20220524T173740Z">
        <seg>사용자는 아마 추가적인 라이브러리의 사용 혹은 다수의 파일에 걸쳐 자신만의 프로젝트를 개발하기를 원할지도 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using a tactic proof, we can be even more concise:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151439Z" creationid="tlqk3" creationdate="20220526T151439Z">
        <seg>심지어 전략 증명을 사용하면 더 간결하게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using inaccessible patterns, we can prompt
the equation compiler to avoid the case split on <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T150443Z" creationid="tlqk3" creationdate="20220604T150443Z">
        <seg>접근 불가한 패턴을 사용하여 우리는 방정식 컴파일러가 <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept>에 대해 경우를 나누는 것을 즉시 막도록 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the Library</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T130428Z" creationid="tlqk3" creationdate="20220526T130428Z">
        <seg>라이브러리 사용하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the Simplifier</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T160612Z" creationid="tlqk35" creationdate="20220524T160612Z">
        <seg>단순화기를 사용하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the auxiliary function <bpt i="3" x="3">&lt;g3&gt;</bpt>simpConst<ept i="3">&lt;/g3&gt;</ept>,
define a function "fuse": to simplify a plus or a times, first
simplify the arguments recursively, and then apply <bpt i="4" x="4">&lt;g4&gt;</bpt>simpConst<ept i="4">&lt;/g4&gt;</ept> to
try to simplify the result.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180419Z" creationid="tlqk3" creationdate="20220603T180419Z">
        <seg>보조 함수 <bpt i="3" x="3">&lt;g3&gt;</bpt>simpConst<ept i="3">&lt;/g3&gt;</ept>를 사용하여 함수 "fuse"를 정의하세요. 더하기와 곱하기를 간단히 하기 위해서 인수를 재귀적으로 단순화하세요. 그 뒤 <bpt i="4" x="4">&lt;g4&gt;</bpt>simpConst<ept i="4">&lt;/g4&gt;</ept>을 결과를 단순화하는데 적용하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the recursor or <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> with <bpt i="2" x="2">&lt;g2&gt;</bpt>h₁ : a = b<ept i="2">&lt;/g2&gt;</ept>, we may assume <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept> are the same,
in which case, <bpt i="5" x="5">&lt;g5&gt;</bpt>p b<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>p a<ept i="6">&lt;/g6&gt;</ept> are the same.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154537Z" creationid="tlqk35" creationdate="20220528T154537Z">
        <seg>재귀자나 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="2" x="2">&lt;g2&gt;</bpt>h₁ : a = b<ept i="2">&lt;/g2&gt;</ept>과 사용하면, 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>a<ept i="3">&lt;/g3&gt;</ept>와 <bpt i="4" x="4">&lt;g4&gt;</bpt>b<ept i="4">&lt;/g4&gt;</ept>가 같다고 가정할 수 있습니다. 그 경우 <bpt i="5" x="5">&lt;g5&gt;</bpt>p b<ept i="5">&lt;/g5&gt;</ept>와 <bpt i="6" x="6">&lt;g6&gt;</bpt>p a<ept i="6">&lt;/g6&gt;</ept>는 동일합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using the various gadgets described in this chapter --- the match
statement, anonymous constructors, and the <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> tactic, we can
write this proof concisely as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183003Z" creationid="tlqk35" creationdate="20220321T183003Z">
        <seg>여기서 설명한 다양한 도구-match 구문, 익명 생성자,  <bpt i="1" x="1">&lt;g1&gt;</bpt>다시쓰기<ept i="1">&lt;/g1&gt;</ept>전략-를 사용하여 다음과 같이 이 증명을 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Using these new features, you can write the other vector functions defined
in the previous sections more compactly as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151546Z" creationid="tlqk3" creationdate="20220604T151546Z">
        <seg>이 새로운 기능을 사용하면 여러분은 이전에 정의한 다른 벡터 함수들을 다음과 같이 더 간결하게 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Values of type <bpt i="1" x="1">&lt;g1&gt;</bpt>Point<ept i="1">&lt;/g1&gt;</ept> are created using <bpt i="2" x="2">&lt;g2&gt;</bpt>Point.mk a b<ept i="2">&lt;/g2&gt;</ept>, and the
fields of a point <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept> are accessed using <bpt i="4" x="4">&lt;g4&gt;</bpt>Point.x p<ept i="4">&lt;/g4&gt;</ept> and
<bpt i="5" x="5">&lt;g5&gt;</bpt>Point.y p<ept i="5">&lt;/g5&gt;</ept> (but <bpt i="6" x="6">&lt;g6&gt;</bpt>p.x<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>p.y<ept i="7">&lt;/g7&gt;</ept> also work, see below).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173857Z" creationid="tlqk35" creationdate="20220528T173857Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Point<ept i="1">&lt;/g1&gt;</ept>형의 값은<bpt i="2" x="2">&lt;g2&gt;</bpt>Point.mk a b<ept i="2">&lt;/g2&gt;</ept>를 사용하여 만들어집니다. 그리고 포인트 <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>의 필드는 <bpt i="4" x="4">&lt;g4&gt;</bpt>Point.x p<ept i="4">&lt;/g4&gt;</ept>와
<bpt i="5" x="5">&lt;g5&gt;</bpt>Point.y p<ept i="5">&lt;/g5&gt;</ept>를 사용해서 접근할 수 있습니다. (그러나 g6&gt;p.x<it pos="end" x="6">&lt;/g6&gt;</it> and <bpt i="7" x="7">&lt;g7&gt;</bpt>p.y<ept i="7">&lt;/g7&gt;</ept>도 동작함, 아래를 참고)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Variables and Sections</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145123Z" creationid="tlqk35" creationdate="20220321T145123Z">
        <seg>변수와 섹션(Variables and Sections)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Variables are only
included in declarations where they are actually used.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175415Z" creationid="tlqk35" creationdate="20220524T175415Z">
        <seg>변수는 오직 그들이 실제로 사용되는 선언에만 포함됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Variables can also be specified as implicit when they are declared with
the <bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept> command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153351Z" creationid="tlqk35" creationdate="20220321T153351Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>variable<ept i="1">&lt;/g1&gt;</ept> 명령으로 선언될 때 변수도 암시적으로 구체화될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We
can make this more precise by looking at the commands the above unfold to:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122256Z" creationid="tlqk3" creationdate="20220526T122256Z">
        <seg>우리는 위의 명령을 다음으로 펼쳐보는 것으로 이를 더 정확하게 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We also encourage you to show that
<bpt i="5" x="5">&lt;g5&gt;</bpt>Bool<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat<ept i="6">&lt;/g6&gt;</ept> are inhabited, that the product of two inhabited
types is inhabited, and that the type of functions to an inhabited
type is inhabited.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151309Z" creationid="tlqk3" creationdate="20220527T151309Z">
        <seg>또 우리는 여러분이 <bpt i="5" x="5">&lt;g5&gt;</bpt>Bool<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat<ept i="6">&lt;/g6&gt;</ept>이 내장되었음을 보이길 권장합니다. 즉, 두 내장된 유형의 곱과 내장된 유형으로의 함수의 유형이 내장되었음을 보이길 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We also leave it to you to determine which are
nonconstructive, and hence require some form of classical reasoning.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183134Z" creationid="tlqk35" creationdate="20220321T183134Z">
        <seg>우리는 또한 어떤 것이 비직관주의적인지 결정하는 것을 여러분에게 맡깁니다. 그러므로 일부는 고전 논리의 형식를 요구합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are
then allowed to use the shorter name when we open the namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151125Z" creationid="tlqk3" creationdate="20220526T151125Z">
        <seg>그럼 우리는 우리가 이름공간을 열었을 때 더 짧은 이름을 사용할 수 있게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are almost done describing the full range of inductive definitions
accepted by Lean.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T152114Z" creationid="tlqk35" creationdate="20220528T152114Z">
        <seg>우리는 거의 린이 허용하는 귀납 정의의 대부분을 설명했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are currently using a
<bpt i="2" x="2">&lt;g2&gt;</bpt>fork<ept i="2">&lt;/g2&gt;</ept> of it for the following additional features:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T171745Z" creationid="tlqk35" creationdate="20220321T171745Z">
        <seg>우리는 현재 다음 부가 기능을 위해 <bpt i="2" x="2">&lt;g2&gt;</bpt>fork<ept i="2">&lt;/g2&gt;</ept>를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan
Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner,
Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey,
Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett for their contributions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134840Z" creationid="tlqk35" creationdate="20220321T134840Z">
        <seg>우리는 Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett에게 그들의 공헌에 대해 감사드립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We are still exploring this feature and analyzing its impact, but the experience so far has been very positive.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135411Z" creationid="tlqk3" creationdate="20220526T135411Z">
        <seg>우리는 여전히 이 기능을 탐색하고 있고, 그것의 영향을 분석합니다. 그러나 지금까지의 경험은 아주 긍정적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can
then go on to define familiar notation in that namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160349Z" creationid="tlqk3" creationdate="20220527T160349Z">
        <seg>그럼 그 이름공간에 친숙한 기호를 정의해 나갈 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can
then read <bpt i="6" x="6">&lt;g6&gt;</bpt>t : p<ept i="6">&lt;/g6&gt;</ept> as the assertion that <bpt i="7" x="7">&lt;g7&gt;</bpt>t<ept i="7">&lt;/g7&gt;</ept> is a proof of <bpt i="8" x="8">&lt;g8&gt;</bpt>p<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155526Z" creationid="tlqk35" creationdate="20220321T155526Z">
        <seg>우리는<bpt i="6" x="6">&lt;g6&gt;</bpt>t : p<ept i="6">&lt;/g6&gt;</ept>를 <bpt i="7" x="7">&lt;g7&gt;</bpt>t<ept i="7">&lt;/g7&gt;</ept>는 <bpt i="8" x="8">&lt;g8&gt;</bpt>p<ept i="8">&lt;/g8&gt;</ept>의 증명이라는 주장으로써 읽을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can
view such inaccessible patterns as "don't care" components of the
patterns.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143832Z" creationid="tlqk3" creationdate="20220604T143832Z">
        <seg>우리는 그런 접속불가한 패턴을 패턴의 "신경쓰지 않는" 성분의 관점으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can <bpt i="1" x="1">&lt;g1&gt;</bpt>extend<ept i="1">&lt;/g1&gt;</ept> existing structures by adding new fields.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T180813Z" creationid="tlqk35" creationdate="20220528T180813Z">
        <seg>우리는 새 필드를 추가하여 존재하는 구조체를<bpt i="1" x="1">&lt;g1&gt;</bpt>확장<ept i="1">&lt;/g1&gt;</ept>할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can achieve exactly that using <bpt i="5" x="5">&lt;g5&gt;</bpt>default instances<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165011Z" creationid="tlqk3" creationdate="20220604T165011Z">
        <seg>우리는 정확히 이를 <bpt i="5" x="5">&lt;g5&gt;</bpt>default instances<ept i="5">&lt;/g5&gt;</ept>으로 달성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also
think of such a type as a "record" or a "structure".</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T161556Z" creationid="tlqk3" creationdate="20220526T161556Z">
        <seg>우리는 그런 유형으로써 "레코드" 혹은 "구조체"를 생각해볼 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also ask Lean to fill in the proof by writing <bpt i="1" x="1">&lt;g1&gt;</bpt>‹p›<ept i="1">&lt;/g1&gt;</ept>, where
<bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept> is the proposition whose proof we want Lean to find in the
context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183449Z" creationid="tlqk35" creationdate="20220321T183449Z">
        <seg>또 우린 린에게 <bpt i="1" x="1">&lt;g1&gt;</bpt>‹p›<ept i="1">&lt;/g1&gt;</ept>라고 써서 증명 속을 채우도록 린에게 요청할수 있습니다. 여기서 <bpt i="2" x="2">&lt;g2&gt;</bpt>p<ept i="2">&lt;/g2&gt;</ept>는 명제이고, 그것의 증명은 현재 상황에서 린이 찾기 바라는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also separate constructors using a
comma instead of <bpt i="4" x="4">&lt;g4&gt;</bpt>|<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T143018Z" creationid="tlqk3" creationdate="20220526T143018Z">
        <seg>또 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>|<ept i="4">&lt;/g4&gt;</ept> 대신 콤마를 사용해 생성자를 나눌 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also use the projection notation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175615Z" creationid="tlqk35" creationdate="20220321T175615Z">
        <seg>또 우리는 투영 기호(인덱싱 기호)를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also use the type <bpt i="1" x="1">&lt;g1&gt;</bpt>Option α<ept i="1">&lt;/g1&gt;</ept> to simulate incomplete patterns.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165857Z" creationid="tlqk3" creationdate="20220529T165857Z">
        <seg>우리는 불완전한 패턴을 모사하려고 <bpt i="1" x="1">&lt;g1&gt;</bpt>Option α<ept i="1">&lt;/g1&gt;</ept>형을 사용할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can also use this device in function
definitions:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153258Z" creationid="tlqk35" creationdate="20220321T153258Z">
        <seg>우리는 함수 정의에서도 이 기능을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can annotate the types used in the match
for greater clarity:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182644Z" creationid="tlqk35" creationdate="20220321T182644Z">
        <seg>우리는 더 명확함을 위해 match에서 사용되는 유형을 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can declare one
explicitly:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180201Z" creationid="tlqk3" creationdate="20220604T180201Z">
        <seg>여러분은 명시적으로 이를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can define functions from <bpt i="1" x="1">&lt;g1&gt;</bpt>Weekday<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151200Z" creationid="tlqk3" creationdate="20220526T151200Z">
        <seg>우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Weekday<ept i="1">&lt;/g1&gt;</ept>에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>까지 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can even use the match statement to decompose the conjunction at the same time:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182705Z" creationid="tlqk35" creationdate="20220321T182705Z">
        <seg>심지어 우리는 match 문장을 분해하는 동시에 결합하기 위해 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can make the output easier to read by telling Lean not to insert
the implicit arguments (which are displayed here as metavariables).</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T175534Z" creationid="tlqk35" creationdate="20220321T175534Z">
        <seg>우리는 린에게 암시적인 인자를 삽입하지 말라 함으로써 출력을 더 쉽게 읽어들이도록 만들 수 있습니다.(메타변수로서 나타난 인자입니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can now prove <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∧ q → q ∧ p<ept i="1">&lt;/g1&gt;</ept> with the following proof term.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T162843Z" creationid="tlqk35" creationdate="20220321T162843Z">
        <seg>이제 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>p ∧ q → q ∧ p<ept i="1">&lt;/g1&gt;</ept>를 따르는 증명 항으로 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can now use this theorem to prove new results:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171620Z" creationid="tlqk35" creationdate="20220524T164538Z">
        <seg>우리는 이 정리로 새로운 결과를 증명하는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can prevent the shorter alias from being created by using the <bpt i="1" x="1">&lt;g1&gt;</bpt>protected<ept i="1">&lt;/g1&gt;</ept> keyword:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180742Z" creationid="tlqk35" creationdate="20220524T180742Z">
        <seg>우리느 더 짤은 별명이 생기는 것을 <bpt i="1" x="1">&lt;g1&gt;</bpt>protected<ept i="1">&lt;/g1&gt;</ept>  키워드를 사용하여 막을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can read
this as the assertion "for every pair of propositions <bpt i="3" x="3">&lt;g3&gt;</bpt>p q<ept i="3">&lt;/g3&gt;</ept>, we have
<bpt i="4" x="4">&lt;g4&gt;</bpt>p → q → p<ept i="4">&lt;/g4&gt;</ept>." For example, we can move all parameters to the right
of the colon:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161457Z" creationid="tlqk35" creationdate="20220321T161457Z">
        <seg>우리는 이를 "모든 명제쌍  <bpt i="3" x="3">&lt;g3&gt;</bpt>p q<ept i="3">&lt;/g3&gt;</ept>에 대해 <bpt i="4" x="4">&lt;g4&gt;</bpt>p → q → p<ept i="4">&lt;/g4&gt;</ept>이다."라고 주장한다고 읽을 수 있다. 예를 들어, 우리는 모든 매개변수들을 콜론의 오른쪽으로 옮길 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can refer to the last
expression introduced in this way using the keyword <bpt i="1" x="1">&lt;g1&gt;</bpt>this<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183322Z" creationid="tlqk35" creationdate="20220321T183322Z">
        <seg>이렇게 도입된 마지막 표현식을 키워드 <bpt i="1" x="1">&lt;g1&gt;</bpt> this<ept i="1">&lt;/g1&gt;</ept>를 사용하여 참조할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can simulate
the arbitrary value approach using the <bpt i="2" x="2">&lt;g2&gt;</bpt>Inhabited<ept i="2">&lt;/g2&gt;</ept> type
class.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165405Z" creationid="tlqk3" creationdate="20220529T165405Z">
        <seg>우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Inhabited<ept i="2">&lt;/g2&gt;</ept> 유형 클래스를 사용하여 임의값 접근법을 모사할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can then define any function <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept> with an "inverse"
which takes anything in the image of <bpt i="7" x="7">&lt;g7&gt;</bpt>f<ept i="7">&lt;/g7&gt;</ept> to an element that is
mapped to it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T144753Z" creationid="tlqk3" creationdate="20220604T144753Z">
        <seg>그런 다음 <bpt i="7" x="7">&lt;g7&gt;</bpt>f<ept i="7">&lt;/g7&gt;</ept>의 이미지에서 매핑된 요소로 가져오는 "역"함수가 있는 임의의 함수 <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept>를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can then use a mutual recursive definition to count the number of constants occurring in a term, as well as the number occurring in a list of terms.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175133Z" creationid="tlqk3" creationdate="20220603T175133Z">
        <seg>그럼 우리는 상호적으로 재귀적인 정의를 항의 리스트에서 나타나는 수 뿐만 아니라 항 속의 상수의 수를 세는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can therefore
rewrite the sample proof above conveniently as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163453Z" creationid="tlqk35" creationdate="20220321T163453Z">
        <seg>우리는 다음과 같이 위의 예시 증명을 간단히 줄여 쓸  수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can use an element <bpt i="2" x="2">&lt;g2&gt;</bpt>h : Eq a b<ept i="2">&lt;/g2&gt;</ept> to cast an element
<bpt i="3" x="3">&lt;g3&gt;</bpt>t' : p a<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>p b<ept i="4">&lt;/g4&gt;</ept> even when <bpt i="5" x="5">&lt;g5&gt;</bpt>p a<ept i="5">&lt;/g5&gt;</ept> and <bpt i="6" x="6">&lt;g6&gt;</bpt>p b<ept i="6">&lt;/g6&gt;</ept> are arbitrary types,
because the cast does not produce new data; it only reinterprets the
data we already have.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T164229Z" creationid="tlqk35" creationdate="20220528T164229Z">
        <seg>우리는 원소 <bpt i="2" x="2">&lt;g2&gt;</bpt>h : Eq a b<ept i="2">&lt;/g2&gt;</ept>를 심지어 <bpt i="5" x="5">&lt;g5&gt;</bpt>p a<ept i="5">&lt;/g5&gt;</ept>과 <bpt i="6" x="6">&lt;g6&gt;</bpt>p b<ept i="6">&lt;/g6&gt;</ept>가 임의의 유형일 때에도 원소 <bpt i="3" x="3">&lt;g3&gt;</bpt>t' : p a<ept i="3">&lt;/g3&gt;</ept>에서 <bpt i="4" x="4">&lt;g4&gt;</bpt>p b<ept i="4">&lt;/g4&gt;</ept>로 변환하는데 사용할 수 있습니다. 왜냐하면 변환은 새로운 데이터를 만들지 않고 이미 가진 데이터를 재해석하기만 하기 때문입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can use the anonymous constructor notation <bpt i="1" x="1">&lt;g1&gt;</bpt>⟨t, h⟩<ept i="1">&lt;/g1&gt;</ept> for
<bpt i="2" x="2">&lt;g2&gt;</bpt>Exists.intro t h<ept i="2">&lt;/g2&gt;</ept>, when the type is clear from the context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180943Z" creationid="tlqk35" creationdate="20220321T180943Z">
        <seg>우리는 맥락으로부터 형이 명백한 경우 익명 생성자 기호 <bpt i="1" x="1">&lt;g1&gt;</bpt>⟨t, h⟩<ept i="1">&lt;/g1&gt;</ept>을 <bpt i="2" x="2">&lt;g2&gt;</bpt>Exists.intro t h<ept i="2">&lt;/g2&gt;</ept>에 대해 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can use the anonymous constructor notation to construct a proof of
<bpt i="1" x="1">&lt;g1&gt;</bpt>p ↔ q<ept i="1">&lt;/g1&gt;</ept> from proofs of the forward and backward directions, and we
can also use <bpt i="2" x="2">&lt;g2&gt;</bpt>.<ept i="2">&lt;/g2&gt;</ept> notation with <bpt i="3" x="3">&lt;g3&gt;</bpt>mp<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>mpr<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T164841Z" creationid="tlqk35" creationdate="20220321T164841Z">
        <seg>우리는 앞과 뒷방향 증명으로부터 <bpt i="1" x="1">&lt;g1&gt;</bpt>p ↔ q<ept i="1">&lt;/g1&gt;</ept>의 증명을 구성하기 위해 익명 생성자 표기를 사용할 수 있습니다. 그리고 우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>.<ept i="2">&lt;/g2&gt;</ept>와  <bpt i="3" x="3">&lt;g3&gt;</bpt>mp<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>mpr<ept i="4">&lt;/g4&gt;</ept>을 사용한 표기를 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can use this to
define the two projections for <bpt i="8" x="8">&lt;g8&gt;</bpt>Prod<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T153257Z" creationid="tlqk3" creationdate="20220526T153257Z">
        <seg>우리는 이것을 <bpt i="8" x="8">&lt;g8&gt;</bpt>Prod<ept i="8">&lt;/g8&gt;</ept>에 대한 두 투영(projection)이라고 정의하는데 사용할 수있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We can view <bpt i="1" x="1">&lt;g1&gt;</bpt>Exists.intro<ept i="1">&lt;/g1&gt;</ept> as an information-hiding operation, since
it hides the witness to the body of the assertion.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T181200Z" creationid="tlqk35" creationdate="20220321T181200Z">
        <seg>주장의 몸체의 발견을 감추기 때문에 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Exists.intro<ept i="1">&lt;/g1&gt;</ept>을 정보 감추기 연산으로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We close this section with one last tactic that is designed to
facilitate working with inductive types, namely, the <bpt i="1" x="1">&lt;g1&gt;</bpt>injection<ept i="1">&lt;/g1&gt;</ept>
tactic.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172649Z" creationid="tlqk3" creationdate="20220527T172649Z">
        <seg> 귀납형과 동작하는 걸 가능하도록 설계된 즉, <bpt i="1" x="1">&lt;g1&gt;</bpt>injection<ept i="1">&lt;/g1&gt;</ept> 전략으로 우리는 이 장을 이 마지막을 마칩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could implement <bpt i="4" x="4">&lt;g4&gt;</bpt>double<ept i="4">&lt;/g4&gt;</ept> by</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153337Z" creationid="tlqk3" creationdate="20220604T153337Z">
        <seg>우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>double<ept i="4">&lt;/g4&gt;</ept>을 아래와 같이 구현할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could render this as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155138Z" creationid="tlqk35" creationdate="20220321T155138Z">
        <seg>이를 다음과 같이 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could represent this as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T155008Z" creationid="tlqk35" creationdate="20220321T155008Z">
        <seg>이를 다음과 같이 나타낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We could then introduce, for each element <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept>, another type
<bpt i="2" x="2">&lt;g2&gt;</bpt>Proof p<ept i="2">&lt;/g2&gt;</ept>, for the type of proofs of <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T154913Z" creationid="tlqk35" creationdate="20220321T154913Z">
        <seg>그러면 우리는 각각의 원소 <bpt i="1" x="1">&lt;g1&gt;</bpt>p : Prop<ept i="1">&lt;/g1&gt;</ept>와 또 다른 유형인 <bpt i="2" x="2">&lt;g2&gt;</bpt>Proof p<ept i="2">&lt;/g2&gt;</ept>을 <bpt i="3" x="3">&lt;g3&gt;</bpt>p<ept i="3">&lt;/g3&gt;</ept>의 증명 유형으로 가져올 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We describe some of them here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T163709Z" creationid="tlqk3" creationdate="20220527T163709Z">
        <seg>여기서 우리는 이들 중 몇 가지를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We encourage you to try it, using <bpt i="3" x="3">&lt;g3&gt;</bpt>recOn<ept i="3">&lt;/g3&gt;</ept>,
<bpt i="4" x="4">&lt;g4&gt;</bpt>casesOn<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>noConfusion<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T184219Z" creationid="tlqk3" creationdate="20220603T184219Z">
        <seg>우리는 여러분이 이를 <bpt i="3" x="3">&lt;g3&gt;</bpt>recOn<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>casesOn<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="5" x="5">&lt;g5&gt;</bpt>noConfusion<ept i="5">&lt;/g5&gt;</ept>을 사용해 시도해보길 권합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We first observe that it
would be easy to implement an ad-hoc polymorphic function (such as addition) if the
function simply took the type-specific implementation of addition as an argument
and then called that implementation on the remaining arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T153106Z" creationid="tlqk3" creationdate="20220604T153106Z">
        <seg>우리는 먼저 함수가 단순히 덧셈의 특정 유형에 대한 구현을 덧셈의 인수로 취한 다음 나머지 인수에 대해 그 구현을 호출하면 임시 다형적 함수(덧셈 같은)를 구현하는 것이 쉽다는 것을 관찰했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have
chosen a nontraditional name here only to avoid a clash of names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153335Z" creationid="tlqk35" creationdate="20220321T153335Z">
        <seg>우리는 여기서 이름의 충돌을 방지하기 위해 비관습적인 이름을 선택할 뿐이었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have already discussed the dependent product type <bpt i="1" x="1">&lt;g1&gt;</bpt>Sigma<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145925Z" creationid="tlqk3" creationdate="20220527T145925Z">
        <seg>우리는 이미 의존 곱 유형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Sigma<ept i="1">&lt;/g1&gt;</ept>에 대해 얘기했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have already seen singleton elimination at play in applications of
<bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.rec<ept i="1">&lt;/g1&gt;</ept>, the eliminator for the inductively defined equality
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T164009Z" creationid="tlqk35" creationdate="20220528T164009Z">
        <seg>우리는 재귀적으로 정의된 동등 유형에 대한 제거자인<bpt i="1" x="1">&lt;g1&gt;</bpt>Eq.rec<ept i="1">&lt;/g1&gt;</ept>의 활용에서 한번에 하나씩 제거되는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have been using constructors to create elements of a structure
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T181910Z" creationid="tlqk35" creationdate="20220528T181910Z">
        <seg>우리는 구조체 형의 원소를 생성하는데 생성자를 사용했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have described inductive types and their syntax through
examples.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152151Z" creationid="tlqk35" creationdate="20220528T155146Z">
        <seg>우리는 귀납형과 그들의 문법을 예제를 통해 설명했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have seen that Lean's formal foundation includes basic types,
<bpt i="1" x="1">&lt;g1&gt;</bpt>Prop, Type 0, Type 1, Type 2, ...<ept i="1">&lt;/g1&gt;</ept>, and allows for the formation of
dependent function types, <bpt i="2" x="2">&lt;g2&gt;</bpt>(x : α) → β<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T141800Z" creationid="tlqk3" creationdate="20220526T141800Z">
        <seg>우리는 린의 형식적인 기초가 기본형 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop, Type 0, Type 1, Type 2, ...<ept i="1">&lt;/g1&gt;</ept>을 포합하고 의존 함수형 <bpt i="2" x="2">&lt;g2&gt;</bpt>(x : α) → β<ept i="2">&lt;/g2&gt;</ept>의 형성을 가능하게 함을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have seen that Lean's foundational system includes inductive
types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152418Z" creationid="tlqk35" creationdate="20220528T172149Z">
        <seg>우리는 귀납형을 포함해 린의 기초적인 체계를 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have seen that keywords like <bpt i="1" x="1">&lt;g1&gt;</bpt>fun<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept>, and <bpt i="3" x="3">&lt;g3&gt;</bpt>show<ept i="3">&lt;/g3&gt;</ept> make
it possible to write formal proof terms that mirror the structure of
informal mathematical proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183255Z" creationid="tlqk35" creationdate="20220321T183255Z">
        <seg>우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>fun<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>have<ept i="2">&lt;/g2&gt;</ept>,<bpt i="3" x="3">&lt;g3&gt;</bpt>show<ept i="3">&lt;/g3&gt;</ept>와 같은 키워드가 비형식적인 수학적 증명의 구조를 반영하는 형식적 증명 용어를 쓸 수 있게 만든 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have seen that the <bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> recursor can
be used to define functions and prove theorems by cases, according to
the constructors involved in an inductively defined type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T160841Z" creationid="tlqk3" creationdate="20220529T160841Z">
        <seg>재귀적으로 정의된 유형에 연관된 생성자를 따라 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>casesOn<ept i="1">&lt;/g1&gt;</ept> 재귀자가 함수를 정의하고 경우를 나눠 정리를 증명하는데 사용될 수 있음을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have seen that the constructor to an inductive type takes
<bpt i="1" x="1">&lt;g1&gt;</bpt>parameters<ept i="1">&lt;/g1&gt;</ept> --- intuitively, the arguments that remain fixed
throughout the inductive construction --- and <bpt i="2" x="2">&lt;g2&gt;</bpt>indices<ept i="2">&lt;/g2&gt;</ept>, the arguments
parameterizing the family of types that is simultaneously under
construction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152158Z" creationid="tlqk35" creationdate="20220528T155749Z">
        <seg>우리는 귀납형에서 생성자는 <bpt i="1" x="1">&lt;g1&gt;</bpt>매개변수(parameters)<ept i="1">&lt;/g1&gt;</ept>-- 직관적으로 재귀 생성 동안 고정된 상태로 남는 인수 --와 동시에 생성중인 유형의 군을 매개변수화하는 인수 <bpt i="2" x="2">&lt;g2&gt;</bpt>indices<ept i="2">&lt;/g2&gt;</ept>를 받는 것을 보았습니다.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have to
provide the equation compiler with evidence that the recursive call is
decreasing, which we do here with a <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T172727Z" creationid="tlqk3" creationdate="20220603T172727Z">
        <seg>우리는 방정식 컴파일러에게 재귀호출이 감소한다는 증거를 주어야 합니다. 여기서 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept>로 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have used <bpt i="1" x="1">&lt;g1&gt;</bpt>.<ept i="1">&lt;/g1&gt;</ept> to create nested tactic blocks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T144734Z" creationid="tlqk35" creationdate="20220524T144734Z">
        <seg>우리는 중첩된 전략 블럭을 만드는데 <bpt i="1" x="1">&lt;g1&gt;</bpt>.<ept i="1">&lt;/g1&gt;</ept>를 사용해왔습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We have, moreover, noted that it is a remarkable fact that it
is possible to construct a substantial edifice of mathematics based on
nothing more than the type universes, dependent arrow types, and inductive types;
everything else follows from those.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152423Z" creationid="tlqk35" creationdate="20220528T172353Z">
        <seg>게다가 우리는 유형 세계, 의존 화살표 유형, 귀납형과 이들로부터 따라나온 모든 것 외에는 기반하지 않는 수학의 엄청난 구조물을 세울 수 있는 가능성을 발견한 사실은 주목할만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We need to use the fact that the inductive type is generated by these constructors to know that the zero is not odd, and that the latter two implications reverse.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T174723Z" creationid="tlqk3" creationdate="20220603T174723Z">
        <seg>우리는 귀납형이 0은 홀수가 아니다는 것, 그리고 후자는 두 함의의 역이라는 것이 생성자들에 의해 만들어졌다는 사실을 이용할 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We now consider two generalizations of inductive types that are often
useful, which Lean supports by "compiling" them down to the more
primitive kinds of inductive types described above.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152323Z" creationid="tlqk35" creationdate="20220528T164633Z">
        <seg>이제 우리는 귀납형의 종종 유용한 두 가지 일반화를 고려했습니다. 린은 이들을 위에서 설명한 유도형의 더 기초적인 종류로 "컴파일"해나감으로써 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We often need an arbitrary element of a given type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T155151Z" creationid="tlqk3" creationdate="20220604T155151Z">
        <seg>우린 종종 주어진 유형의 임의의 원소를 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We often put the <bpt i="1" x="1">&lt;g1&gt;</bpt>by<ept i="1">&lt;/g1&gt;</ept> keyword on the preceding line, and write the
example above as</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184607Z" creationid="tlqk35" creationdate="20220321T184607Z">
        <seg>우리는 종종 <bpt i="1" x="1">&lt;g1&gt;</bpt>by<ept i="1">&lt;/g1&gt;</ept> 키워드를 앞줄에 놓고 위의 예를 다음과 같이 작성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We recommend running the examples and experimenting with the code on your own as you work through the chapters
that follow.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134950Z" creationid="tlqk35" creationdate="20220321T134950Z">
        <seg>우리는 여러분이 장을 따라 공부하면서 스스로 예제를 실행해보고 코드를 실험해보는 것을 추천합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We recommend skimming this section to get a sense of Lean's
features, and then returning to it as necessary.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173334Z" creationid="tlqk35" creationdate="20220524T173334Z">
        <seg>우리는 린의 특징에 대한 감을 얻도록 건너뛰고 읽어보는 것을 추천합니다. 그리고 필요하다면 다시 여기로 돌아오세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We recommend you only use this command to diagnose problems.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170630Z" creationid="tlqk3" creationdate="20220604T170630Z">
        <seg>우리는 이 명령을 여러분이 문제를 진단하는 데에만 사용하는 것을 권장합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We saw in <bpt i="3" x="3">&lt;g3&gt;</bpt>Namespaces<ept i="3">&lt;/g3&gt;</ept> that Lean provides
mechanisms for working with hierarchical names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T175653Z" creationid="tlqk35" creationdate="20220524T175653Z">
        <seg>우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>Namespaces<ept i="3">&lt;/g3&gt;</ept>에서 린이 계층적인 이름으로 작업하는 메커니즘을 제공하는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We say
it is "focusing" on the selected goal.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061457Z" creationid="tlqk35" creationdate="20220522T061457Z">
        <seg>우리는 이를 선택한 목표에 "초점을 맞췄다"고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We say the numerals <bpt i="5" x="5">&lt;g5&gt;</bpt>2<ept i="5">&lt;/g5&gt;</ept> occurring in the elaborated terms are <bpt i="6" x="6">&lt;g6&gt;</bpt>raw<ept i="6">&lt;/g6&gt;</ept> natural numbers.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162750Z" creationid="tlqk3" creationdate="20220604T162750Z">
        <seg>동화된 항에서 나타나는 수치값 <bpt i="5" x="5">&lt;g5&gt;</bpt>2<ept i="5">&lt;/g5&gt;</ept>가 <bpt i="6" x="6">&lt;g6&gt;</bpt>생<ept i="6">&lt;/g6&gt;</ept> 자연수라고 말합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We start with <bpt i="1" x="1">&lt;g1&gt;</bpt>zero : Nat<ept i="1">&lt;/g1&gt;</ept>; it takes
no arguments, so we have it from the start.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T154138Z" creationid="tlqk3" creationdate="20220527T154138Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>zero : Nat<ept i="1">&lt;/g1&gt;</ept>으로 시작합니다. 이것은 아무 인수를 받지 않습니다. 그래서 우리는 시작부터 이것을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will also
consider slight generalizations of the scheme above, to mutually
defined inductive types, and so-called <bpt i="1" x="1">&lt;g1&gt;</bpt>inductive families<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151825Z" creationid="tlqk3" creationdate="20220526T143938Z">
        <seg>우리는 귀납형과 일명 귀납군을 동시에 정의하도록 위의 계획의 약간의 일반화를 고려할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184316Z" creationid="tlqk35" creationdate="20220321T184316Z">
        <seg>우리는 전략의 연쇄로 이뤄진 증명을 "전략 스타일" 증명으로 설명할 것이고, 우리가  "항 스타일" 증명이라고 부를 것이고 이제까지 보았던 증명 항를 작성하는 방법과 대조할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will discuss variations of <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept> in the next chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180620Z" creationid="tlqk35" creationdate="20220321T180620Z">
        <seg>다음 장에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>rw<ept i="1">&lt;/g1&gt;</ept>와 <bpt i="2" x="2">&lt;g2&gt;</bpt>simp<ept i="2">&lt;/g2&gt;</ept>의 변형을 다룰 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will explain how the <bpt i="1" x="1">&lt;g1&gt;</bpt>instance<ept i="1">&lt;/g1&gt;</ept> command works in
<bpt i="2" x="2">&lt;g2&gt;</bpt>Chapter Type Classes<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160708Z" creationid="tlqk3" creationdate="20220527T160708Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>유형 클래스 장<ept i="2">&lt;/g2&gt;</ept>에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>instance<ept i="1">&lt;/g1&gt;</ept> 명령이 어떻게 동작하는지 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will fill this gap in the next
chapter, which introduces the notion of an <bpt i="1" x="1">&lt;g1&gt;</bpt>inductive data type<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172929Z" creationid="tlqk35" creationdate="20220524T172929Z">
        <seg>우리는 다음 장에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>inductive data type<ept i="1">&lt;/g1&gt;</ept>의 개념을 도입하여 이 간극을 메울 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will learn about writing such macros below.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T122426Z" creationid="tlqk3" creationdate="20220526T122426Z">
        <seg>우리는 아래에서 그런 매크로를 쓰는 법에 대해 배울 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will learn more about the <bpt i="2" x="2">&lt;g2&gt;</bpt>assumption<ept i="2">&lt;/g2&gt;</ept> tactic in the
next chapter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183427Z" creationid="tlqk35" creationdate="20220321T183427Z">
        <seg>다음 장에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>assumption<ept i="2">&lt;/g2&gt;</ept> 전략에 대해 더 배울 예정입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will provide a number of examples of inductive types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151807Z" creationid="tlqk3" creationdate="20220526T143616Z">
        <seg>우리는 다수의 귀납형의 예제를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see below that the arguments of the constructors can include
objects of type <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept>, subject to a certain "positivity" constraint,
which guarantees that elements of <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept> are built from the bottom
up.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T143354Z" creationid="tlqk3" creationdate="20220526T143354Z">
        <seg>우리는 아래에서 생성자의 인자가 <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept> 형의 대상을 특정 <bpt i="2" x="2">&lt;g2&gt;</bpt>Foo<ept i="2">&lt;/g2&gt;</ept>의 원소가 상향식으로 만들어졌음을 보장하는 "긍정성" 제약을 조건으로 하여 포함할 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Induction and Recursion<ept i="1">&lt;/g1&gt;</ept> that all these variations are
instances of a more general pattern-matching construct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T182909Z" creationid="tlqk35" creationdate="20220321T182909Z">
        <seg> <bpt i="1" x="1">&lt;g1&gt;</bpt>유도와 재귀<ept i="1">&lt;/g1&gt;</ept>에서 더 일반적인 패턴-매칭 생성 개체들의 모든 변형을 볼 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Structures and Records<ept i="1">&lt;/g1&gt;</ept> that certain
types in Lean are <bpt i="2" x="2">&lt;g2&gt;</bpt>structures<ept i="2">&lt;/g2&gt;</ept>, which is to say, the type is defined
with a single canonical <bpt i="3" x="3">&lt;g3&gt;</bpt>constructor<ept i="3">&lt;/g3&gt;</ept> which builds an element of the
type from a sequence of suitable arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163058Z" creationid="tlqk35" creationdate="20220321T163058Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>구조체와 레코드 장<ept i="1">&lt;/g1&gt;</ept>에서 보겠지만 린의 어떤 유형은 <bpt i="2" x="2">&lt;g2&gt;</bpt>구조체<ept i="2">&lt;/g2&gt;</ept>입니다. 그 말은 유형이 하나의 적절한 인수의 배열로부터 유형의 원소를 만드는 정식 <bpt i="3" x="3">&lt;g3&gt;</bpt>생성자<ept i="3">&lt;/g3&gt;</ept>로 정의된다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see in <bpt i="6" x="6">&lt;g6&gt;</bpt>Chapter Inductive Types<ept i="6">&lt;/g6&gt;</ept>
and <bpt i="7" x="7">&lt;g7&gt;</bpt>Chapter Structures and Records<ept i="7">&lt;/g7&gt;</ept>
that defining structures and inductive data types in Lean generates
associated operations, and these are stored in
a namespace with the same name as the type under definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T132747Z" creationid="tlqk3" creationdate="20220526T132747Z">
        <seg>우리는 <bpt i="6" x="6">&lt;g6&gt;</bpt>Chapter Inductive Types<ept i="6">&lt;/g6&gt;</ept>와  <bpt i="7" x="7">&lt;g7&gt;</bpt>Chapter Structures and Records<ept i="7">&lt;/g7&gt;</ept>에서 린에서 구조체와 유도 데이터 형을 정의하는 것은 연관된 연산을 생성함을 볼 예정입니다. 그리고 이들은 정의에 대해 유형으로써 같은 이름으로 이름공간에 저장됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see later that there <bpt i="1" x="1">&lt;g1&gt;</bpt>are<ept i="1">&lt;/g1&gt;</ept> situations in constructive logic
where principles like excluded middle and double-negation elimination
are permissible, and Lean supports the use of classical reasoning in
such contexts without relying on excluded middle.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170037Z" creationid="tlqk35" creationdate="20220321T170037Z">
        <seg>우리는 나중에 <bpt i="1" x="1">&lt;g1&gt;</bpt>배중률과 이중 부정 제거와 같은 원칙이 허용되는 직관주의적 논리 <ept i="1">&lt;/g1&gt;</ept> 상황이 있음을 나중에 보게 될 것입니다. 그리고 린은 그런 맥락에서 배중률에 의존하지 않는 고전논리의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will see more examples in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Structures and Records<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145843Z" creationid="tlqk3" creationdate="20220527T145843Z">
        <seg>우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>구조체와 레코드 장<ept i="1">&lt;/g1&gt;</ept>에서 더 많은 예제를 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will start with
some basic examples of inductive types, and work our way up to more
elaborate and complex examples.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151915Z" creationid="tlqk3" creationdate="20220526T145124Z">
        <seg>우리는 귀납형의 몇 가지 기본적인 예제로 시작할 것입니다. 그리고 우리의 작업을 더 정교하고 복잡한 예제로 옮겨갈 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>We will use the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expression to define a function from <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>
to the natural numbers:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T150404Z" creationid="tlqk3" creationdate="20220526T150404Z">
        <seg>우리는 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>로부터 자연수로의 함수를 정의하는데 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식을 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Well-Founded Recursion and Induction</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173659Z" creationid="tlqk3" creationdate="20220529T173659Z">
        <seg>잘 세워진 재귀와 귀납</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What characterizes the examples we consider in this
section is that this is not the case: each constructor relies only on
previously specified types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T160541Z" creationid="tlqk3" creationdate="20220526T155755Z">
        <seg>예제를 특징짓는 것은 이 섹션에서 우리는 이 경우만이 아니라 각 생성자가 이전에 명시된 유형에만 의존한다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What follows are some common identities involving the existential
quantifier.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183122Z" creationid="tlqk35" creationdate="20220321T183122Z">
        <seg>다음은 존재 한정기호를 포함한 몇 가지 흔한 항등식들 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What follows is an example
of an identity from propositional logic that we proved in a previous
chapter, now proved using tactics.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062113Z" creationid="tlqk35" creationdate="20220522T062113Z">
        <seg>다음의 것은 전략을 사용해 증명할 이전 장에서 증명한 명제논리의 항등식의 예시들입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes dependent type theory dependent?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150804Z" creationid="tlqk35" creationdate="20220321T150804Z">
        <seg>무엇이 의존 유형론을 의존적이게 만드는가?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes recursion and
induction possible is that they can also involve recursive calls to
<bpt i="3" x="3">&lt;g3&gt;</bpt>foo<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T171946Z" creationid="tlqk3" creationdate="20220529T171946Z">
        <seg>재귀와 귀납을 가능하게 만드는 것은 이들이 <bpt i="3" x="3">&lt;g3&gt;</bpt>foo<ept i="3">&lt;/g3&gt;</ept>에 대한 재귀적인 호출을 포함할 수 있다는 점 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes simple type theory powerful is that you can build new types
out of others.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135919Z" creationid="tlqk35" creationdate="20220321T135919Z">
        <seg>단순 유형론을 강력하게 만드는 것은 기본형 외의 여러분만의 새로운 유형을 만들 수 있다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes the equation compiler powerful is that it also supports
recursive definitions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170356Z" creationid="tlqk3" creationdate="20220529T170356Z">
        <seg>방정식 컴파일러를 강력하게 만드는 것은 재귀적인 정의를 지원한다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes this a mutual definition is that <bpt i="1" x="1">&lt;g1&gt;</bpt>even<ept i="1">&lt;/g1&gt;</ept> is defined recursively in terms of <bpt i="2" x="2">&lt;g2&gt;</bpt>odd<ept i="2">&lt;/g2&gt;</ept>, while <bpt i="3" x="3">&lt;g3&gt;</bpt>odd<ept i="3">&lt;/g3&gt;</ept> is defined recursively in terms of <bpt i="4" x="4">&lt;g4&gt;</bpt>even<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173758Z" creationid="tlqk3" creationdate="20220603T173758Z">
        <seg>이를 상호적인 정의로 만드는 것은 <bpt i="1" x="1">&lt;g1&gt;</bpt>even<ept i="1">&lt;/g1&gt;</ept>이<bpt i="2" x="2">&lt;g2&gt;</bpt>odd<ept i="2">&lt;/g2&gt;</ept>에 대해 재귀적으로 정의되었고, 한편 <bpt i="3" x="3">&lt;g3&gt;</bpt>odd<ept i="3">&lt;/g3&gt;</ept>는 <bpt i="4" x="4">&lt;g4&gt;</bpt>even<ept i="4">&lt;/g4&gt;</ept>에 대해 재귀적으로 정의되었다는 점이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What makes type class inference powerful is that one can <bpt i="1" x="1">&lt;g1&gt;</bpt>chain<ept i="1">&lt;/g1&gt;</ept> instances.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160923Z" creationid="tlqk3" creationdate="20220604T160923Z">
        <seg>유형 클래스 추론을 강력하게 만드는 것은 <bpt i="1" x="1">&lt;g1&gt;</bpt>chain<ept i="1">&lt;/g1&gt;</ept> 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>What type should <bpt i="2" x="2">&lt;g2&gt;</bpt>cons<ept i="2">&lt;/g2&gt;</ept> have?</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151029Z" creationid="tlqk35" creationdate="20220321T151029Z">
        <seg><bpt i="2" x="2">&lt;g2&gt;</bpt>cons<ept i="2">&lt;/g2&gt;</ept>는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When
Lean starts, it automatically imports the contents of the library
<bpt i="1" x="1">&lt;g1&gt;</bpt>Init<ept i="1">&lt;/g1&gt;</ept> folder, which includes a number of fundamental definitions
and constructions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T173833Z" creationid="tlqk35" creationdate="20220524T173833Z">
        <seg>린이 시작될 때, 이는 자동적으로 라이브러리 <bpt i="1" x="1">&lt;g1&gt;</bpt>Init<ept i="1">&lt;/g1&gt;</ept> 폴더의 내용을 불러옵니다.
여기에는 다수의 기초적인 정의와 구성이 포함되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When <bpt i="7" x="7">&lt;g7&gt;</bpt>β<ept i="7">&lt;/g7&gt;</ept> doesn't
depend on <bpt i="8" x="8">&lt;g8&gt;</bpt>a<ept i="8">&lt;/g8&gt;</ept>, <bpt i="9" x="9">&lt;g9&gt;</bpt>(a : α) → β<ept i="9">&lt;/g9&gt;</ept> is no different from the type
<bpt i="10" x="10">&lt;g10&gt;</bpt>α → β<ept i="10">&lt;/g10&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152016Z" creationid="tlqk35" creationdate="20220321T152016Z">
        <seg> <bpt i="7" x="7">&lt;g7&gt;</bpt>β<ept i="7">&lt;/g7&gt;</ept>가  <bpt i="8" x="8">&lt;g8&gt;</bpt>a<ept i="8">&lt;/g8&gt;</ept>에 의존하지 않을 때, <bpt i="9" x="9">&lt;g9&gt;</bpt>(a : α) → β<ept i="9">&lt;/g9&gt;</ept>는 유형 <bpt i="10" x="10">&lt;g10&gt;</bpt>α → β<ept i="10">&lt;/g10&gt;</ept>유형과 다르지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When Lean processes the header of a declaration,
any unbound identifier is automatically added as an implicit argument <bpt i="3" x="3">&lt;g3&gt;</bpt>if<ept i="3">&lt;/g3&gt;</ept> it is a single lower case or
greek letter.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134650Z" creationid="tlqk3" creationdate="20220526T134650Z">
        <seg>린이 선언의 헤더를 처리할 때 만약 이것이 한 글자의 소문자나 그리스 문자이면 임의의 구속되지 않은 식별자가 자동적으로 암시적인 매개변수로 추가됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a
function takes an argument that can generally be inferred from
context, Lean allows you to specify that this argument should, by
default, be left implicit.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T153145Z" creationid="tlqk35" creationdate="20220321T153145Z">
        <seg>함수가 일반적으로 맥락으로부터 추론할 수 있는 인수를 받을 때, Lean은 여러분이 이런 인수가 암시적이어야 함을 명시하도록 기본적으로 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When a type class has multiple parameters, you can mark some of them as output parameters.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163558Z" creationid="tlqk3" creationdate="20220604T163558Z">
        <seg>유형 클래스가 다수의 매개변수를 가질 때, 여러분은 출력 매개변수로 그들 중 몇을 표시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When an instance is declared, it is
assigned a default priority value.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181626Z" creationid="tlqk3" creationdate="20220604T181626Z">
        <seg>개체가 선언되면 기본 우선 순위 값이 할당됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When combined with the <bpt i="1" x="1">&lt;g1&gt;</bpt>auto bound implicits<ept i="1">&lt;/g1&gt;</ept> feature, you can simplify
the declare further and write:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151419Z" creationid="tlqk3" creationdate="20220604T151419Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>암시적인 자동 결합(auto bound implicits)<ept i="1">&lt;/g1&gt;</ept> 기능과 결합할 때 여러분은 선언을 더 단순화 해 작성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When declared in this way, a variable stays in scope until the end of
the file you are working on.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150021Z" creationid="tlqk35" creationdate="20220321T150021Z">
        <seg>이 방식으로 선언되었을 때, 변수는 여러분이 작업하는 파일 끝까지를 범위로 가질 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When declaring an inductive datatype, you can use <bpt i="1" x="1">&lt;g1&gt;</bpt>deriving Repr<ept i="1">&lt;/g1&gt;</ept> to instruct
Lean to generate a fuction that converts <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept> objects into text.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T150812Z" creationid="tlqk3" creationdate="20220526T150812Z">
        <seg>유도 데이터형을 선언할 때, 여러분은 린에게 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>의 대상을 텍스트로 바꾸는 함수를 생성하라고 지시하도록 <bpt i="1" x="1">&lt;g1&gt;</bpt>deriving Repr<ept i="1">&lt;/g1&gt;</ept>을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When implementing this
definition, the equation compiler starts with a case distinction as to
whether the first argument is <bpt i="2" x="2">&lt;g2&gt;</bpt>0<ept i="2">&lt;/g2&gt;</ept> or of the form <bpt i="3" x="3">&lt;g3&gt;</bpt>n+1<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T145655Z" creationid="tlqk3" creationdate="20220604T145655Z">
        <seg>이 정의를 구현할 때 방정식 컴파일러는 첫 번째 인수가 <bpt i="2" x="2">&lt;g2&gt;</bpt>0<ept i="2">&lt;/g2&gt;</ept>이거나 <bpt i="3" x="3">&lt;g3&gt;</bpt>n+1<ept i="3">&lt;/g3&gt;</ept>의 꼴인지를 구분하도록 경우를 구분하는 것으로 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the equation compiler encounters a recursive definition, it first
tries structural recursion, and only when that fails, does it fall
back on well-founded recursion.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171912Z" creationid="tlqk3" creationdate="20220603T171912Z">
        <seg>방정식 컴파일러가 재귀적 정의를 만날 때, 는 처음 구조적 재귀를 시도하고 그게 실패했을 때 잘 세워진 재귀로 대체됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the goal can be inferred, we can also ask Lean instead to fill in
the proof by writing <bpt i="1" x="1">&lt;g1&gt;</bpt>by assumption<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183356Z" creationid="tlqk35" creationdate="20220321T183356Z">
        <seg>목표가 추론될 수 있을 때, 우리는 <bpt i="1" x="1">&lt;g1&gt;</bpt>by assumption<ept i="1">&lt;/g1&gt;</ept>을 써 증명을 채우는 대신 린에게 물어볼 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the inductive type is specified to land in <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>, there are no
constraints on the universe levels of the constructor arguments.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152300Z" creationid="tlqk35" creationdate="20220528T162358Z">
        <seg>귀납형이 <bpt i="1" x="1">&lt;g1&gt;</bpt>Prop<ept i="1">&lt;/g1&gt;</ept>에서 머무른다고 명시되어 있을 때, 생성자 인수의 세계 수준에 대한 제한이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the section is closed, the variables go out of scope, and cannot
be referenced any more.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150059Z" creationid="tlqk35" creationdate="20220321T150059Z">
        <seg>섹션이 닫히게 될 때, 변수들은 범위를 벗어나게 됩니다. 그리고 구분된 메모리 외에 아무것도 없게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When the value of <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept> depends on <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept> (as does, for
example, the expression <bpt i="5" x="5">&lt;g5&gt;</bpt>β a<ept i="5">&lt;/g5&gt;</ept> in the previous paragraph),
<bpt i="6" x="6">&lt;g6&gt;</bpt>(a : α) → β<ept i="6">&lt;/g6&gt;</ept> denotes a dependent function type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T151941Z" creationid="tlqk35" creationdate="20220321T151941Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept>의 값이 <bpt i="4" x="4">&lt;g4&gt;</bpt>a<ept i="4">&lt;/g4&gt;</ept>에 의존할 때(예를 들어 앞 단락에서 식 <bpt i="5" x="5">&lt;g5&gt;</bpt>β a<ept i="5">&lt;/g5&gt;</ept>처럼), <bpt i="6" x="6">&lt;g6&gt;</bpt>(a : α) → β<ept i="6">&lt;/g6&gt;</ept>는 의존적 함수 유형을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When they don't, the latter is always
available as a backup.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173241Z" creationid="tlqk3" creationdate="20220603T173241Z">
        <seg>그들이 동작하지 않을 때 후자는 백업으로 항상 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When they work, they provide a
much more convenient way of defining functions than using
<bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept> manually.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173220Z" creationid="tlqk3" creationdate="20220603T173220Z">
        <seg>그들이 동작할 때, 그들은 수동적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>WellFounded.fix<ept i="1">&lt;/g1&gt;</ept>를 사용하는 것보다 함수를 정의하는 훨씬 더 편리한 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we define a structure using this command, Lean
automatically generates all the projection functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173227Z" creationid="tlqk35" creationdate="20220528T173227Z">
        <seg>우리가 이 명령을 사용해 구조체를 정의할 때, 린은 자동적으로 모든 투영함수를 생성합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we generalize <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept> in such a way, we can then apply it to
different pairs of propositions, to obtain different instances of the
general theorem.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T161654Z" creationid="tlqk35" creationdate="20220321T161654Z">
        <seg>우리가 <bpt i="1" x="1">&lt;g1&gt;</bpt>t1<ept i="1">&lt;/g1&gt;</ept>을 그런 식으로 일반화할 때, 그럼 우리는 일반 정리의 다른 예를 얻기 위해 다른 명제쌍에 대해서도 적용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we instantiate <bpt i="1" x="1">&lt;g1&gt;</bpt>trans_r<ept i="1">&lt;/g1&gt;</ept> at
the values <bpt i="2" x="2">&lt;g2&gt;</bpt>a b c<ept i="2">&lt;/g2&gt;</ept>, we end up with a proof of <bpt i="3" x="3">&lt;g3&gt;</bpt>r a b → r b c → r a c<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T174035Z" creationid="tlqk35" creationdate="20220321T174035Z">
        <seg>우리가  <bpt i="1" x="1">&lt;g1&gt;</bpt>trans_r<ept i="1">&lt;/g1&gt;</ept>을 값 <bpt i="2" x="2">&lt;g2&gt;</bpt>a b c<ept i="2">&lt;/g2&gt;</ept>에 대해 개체화할 때, 우리는 <bpt i="3" x="3">&lt;g3&gt;</bpt>r a b → r b c → r a c<ept i="3">&lt;/g3&gt;</ept>의 증명을 갖게됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When we open a namespace, an
identifier may be ambiguous.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180409Z" creationid="tlqk35" creationdate="20220524T180312Z">
        <seg>우리가 이름공간을 열때, 식별자는 모호하다고 할 지 모릅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When writing programs or formalizing mathematics, it is not uncommon
to define structures containing many fields.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T173114Z" creationid="tlqk35" creationdate="20220528T173114Z">
        <seg>프로그램을 작성하거나 수학을 공식화할 때 만은 필드를 포함한 구조체를 정의하는 것은 흔합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>When you declare that you are working in the namespace <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept>, every
identifier you declare has a full name with prefix "<bpt i="2" x="2">&lt;g2&gt;</bpt>Foo.<ept i="2">&lt;/g2&gt;</ept>".</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150245Z" creationid="tlqk35" creationdate="20220321T150245Z">
        <seg>이름공간 <bpt i="1" x="1">&lt;g1&gt;</bpt>Foo<ept i="1">&lt;/g1&gt;</ept>에서 작업한다고 여러분이 선언할 때 여러분이 선언한 모든 식별자들은 "<bpt i="2" x="2">&lt;g2&gt;</bpt>Foo.<ept i="2">&lt;/g2&gt;</ept>"를 접미사로 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Whereas <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept> is designed as a surgical tool for manipulating a
goal, the simplifier offers a more powerful form of automation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T161512Z" creationid="tlqk35" creationdate="20220524T160620Z">
        <seg>반면 <bpt i="1" x="1">&lt;g1&gt;</bpt>rewrite<ept i="1">&lt;/g1&gt;</ept>는 목표를 조작하기 위한 외과 수술 도구로써 고안되었습다. 
단순화기는 자동화의 더욱 강력한 형태를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>While introducing new notations is a relatively rare feature in
programming languages and sometimes even frowned upon because of its
potential to obscure code, it is an invaluable tool in formalization
for expressing established conventions and notations of the respective
field succinctly in code.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T120711Z" creationid="tlqk3" creationdate="20220526T120711Z">
        <seg>새로운 기호를 도입하는 것은 프로그래밍 언어에서 상대적으로 흔치 않은 특징이고 때떄로는 그것이 잠재적으로 코드를 모호하게 하여 종종 난처하게 함에도 이는 세워진 관행들과 각 분야의 기호를 코드에서 간결하게 표현하는 것에 대한 형식화에 있어서 귀중한 도구입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Wildcards and Overlapping Patterns</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T164617Z" creationid="tlqk3" creationdate="20220529T164617Z">
        <seg>와일드카드와 중복되는 패턴</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With <bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept>, we can write the proof in the last section in a more
natural and perspicuous way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T180707Z" creationid="tlqk35" creationdate="20220321T180707Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>calc<ept i="1">&lt;/g1&gt;</ept>를 통해서 우리는 지난 섹션에서 증명을 더 자연스럽고 안목있는 방식으로 작성할 수 있었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With the analogy, however, the proof we have just constructed
is similar to a function that swaps the elements of a pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T163021Z" creationid="tlqk35" creationdate="20220321T163021Z">
        <seg>하지만 이 비유에도 우리가 막 만든 증명은 순서쌍의 원소를 바꾸는 함수와 비슷합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With the classical axioms, we can prove that every proposition is
decidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173611Z" creationid="tlqk3" creationdate="20220604T173611Z">
        <seg>고전적 공리로 우리는 모든 명제가 결정 가능임을 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With the propositions as types correspondence, logical connectives are
also instances of inductive types, and so we tend to use dot notation
for them as well:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151740Z" creationid="tlqk3" creationdate="20220526T134037Z">
        <seg>유형으로써 명제 대응에서 논리 결합자도 귀납형의 개체들입니다. 그리고 그들에 대해서도 점 표기를 사용하는 경향이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With the three identities mentioned above, this has the effect
that all the parentheses in an expression are associated to the right,
and the expressions are ordered in a canonical (though somewhat
arbitrary) way.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171728Z" creationid="tlqk35" creationdate="20220524T162812Z">
        <seg>세 항등식이 위에서 언급되었는데 이들은 표현식에서 모든 괄호가 오른쪽으로 결합된다는 
효과를 갖고 표현식들은 표준 방식(약간 임의적일지라도)에서 순서화됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With these tactics, an
example from the previous section can be rewritten as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071358Z" creationid="tlqk35" creationdate="20220522T071358Z">
        <seg>이 전략으로 이전 섹션의 예제를 다음과 같이 다시 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this added to the earlier instance declarations, type class instance can infer, for example, a default element of <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat × Bool<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161419Z" creationid="tlqk3" creationdate="20220604T161419Z">
        <seg>더 이전에 개체 선언에 이것을 추가하여 유형 클래스 개체는 예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat × Bool<ept i="1">&lt;/g1&gt;</ept>의 기본 원소를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this annotation, the
expression <bpt i="9" x="9">&lt;g9&gt;</bpt>f 7<ept i="9">&lt;/g9&gt;</ept> would be parsed as is, whereas <bpt i="10" x="10">&lt;g10&gt;</bpt>f 7 3<ept i="10">&lt;/g10&gt;</ept> would be
parsed as <bpt i="11" x="11">&lt;g11&gt;</bpt>f 7 _ 3<ept i="11">&lt;/g11&gt;</ept>, just as it would be with the strong annotation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T185631Z" creationid="tlqk3" creationdate="20220525T185631Z">
        <seg>이 주석으로 표현식 <bpt i="9" x="9">&lt;g9&gt;</bpt>f 7<ept i="9">&lt;/g9&gt;</ept>은 이대로 구문분석 될 수 있습니다. 반면 <bpt i="10" x="10">&lt;g10&gt;</bpt>f 7 3<ept i="10">&lt;/g10&gt;</ept>은 강한 주석을 쓸 때처럼 <bpt i="11" x="11">&lt;g11&gt;</bpt>f 7 _ 3<ept i="11">&lt;/g11&gt;</ept>으로 구문분석될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this definition, one can construct an element of <bpt i="1" x="1">&lt;g1&gt;</bpt>Tree α<ept i="1">&lt;/g1&gt;</ept> by
giving an element of <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> together with a list of subtrees, possibly
empty.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T165745Z" creationid="tlqk35" creationdate="20220528T165745Z">
        <seg>이 정의를 갖고 대게는 빈 하위 트리의 리스트와 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>의 원소를 줌으로써 <bpt i="1" x="1">&lt;g1&gt;</bpt>Tree α<ept i="1">&lt;/g1&gt;</ept>의 원소를 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this feature we can write <bpt i="4" x="4">&lt;g4&gt;</bpt>compose<ept i="4">&lt;/g4&gt;</ept> as</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134711Z" creationid="tlqk3" creationdate="20220526T134711Z">
        <seg>이 기능으로 우리는 <bpt i="4" x="4">&lt;g4&gt;</bpt>compose<ept i="4">&lt;/g4&gt;</ept>를 이와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>With this reduction, there are two ways that a computer can help establish a claim: it can help
find a proof in the first place, and it can help verify that a purported proof is correct.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T131244Z" creationid="tlqk35" creationdate="20220321T131244Z">
        <seg>이러한 축소로부터 컴퓨터가 진술을 만드는데 도움을 주는 두 가지 방법이 있습니다. 처음부터 증명을 찾는 걸 돕는 것과 다른 하나는 제시한 증명이 옳은지 식별하도록 돕게 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Within
the namespace, you can refer to identifiers by their shorter names,
but once you end the namespace, you have to use the longer names.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150359Z" creationid="tlqk35" creationdate="20220321T150359Z">
        <seg>이름공간 안에서 여러분은 식별자들을 그들의 약식 이름으로 부를 수 있습니다. 그러나 한번 이름공간에 끝에 오면 여러분은 더 긴 이름을 사용해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Without classical logic, we cannot prove that every proposition is
decidable.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T172855Z" creationid="tlqk3" creationdate="20220604T172855Z">
        <seg>고전 논리가 없으면 우리는 모든 명제가 결정 가능임을 증명할 수 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Without the equation
compiler, we would need a lot of boilerplate code to define very
simple functions such as <bpt i="5" x="5">&lt;g5&gt;</bpt>map<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>zip<ept i="6">&lt;/g6&gt;</ept>, and <bpt i="7" x="7">&lt;g7&gt;</bpt>unzip<ept i="7">&lt;/g7&gt;</ept> using
recursors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T175627Z" creationid="tlqk3" creationdate="20220603T175627Z">
        <seg>방정식 컴파일러가 없다면 우리는 <bpt i="5" x="5">&lt;g5&gt;</bpt>map<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>zip<ept i="6">&lt;/g6&gt;</ept>과 <bpt i="7" x="7">&lt;g7&gt;</bpt>unzip<ept i="7">&lt;/g7&gt;</ept>같은 아주 단순한 함수를 재귀자를 사용해서 정의하려면 아주 많은 보일러 플레이트 코드가 필요할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Working with Propositions as Types</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160548Z" creationid="tlqk35" creationdate="20220321T160548Z">
        <seg>유형으로써 명제로 작업하기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Write a function that evaluates such an expression, evaluating each <bpt i="1" x="1">&lt;g1&gt;</bpt>var n<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>v n<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180800Z" creationid="tlqk3" creationdate="20220603T180800Z">
        <seg>각 <bpt i="1" x="1">&lt;g1&gt;</bpt>var n<ept i="1">&lt;/g1&gt;</ept>을 <bpt i="2" x="2">&lt;g2&gt;</bpt>v n<ept i="2">&lt;/g2&gt;</ept>으로 계산하는 표현식을 계산하는 함수를 작성하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing <bpt i="1" x="1">&lt;g1&gt;</bpt>suffices hq : q<ept i="1">&lt;/g1&gt;</ept> leaves us with two goals.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T165549Z" creationid="tlqk35" creationdate="20220321T165549Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>suffices hq : q<ept i="1">&lt;/g1&gt;</ept>을 쓰는 것은 우리에게 두 목표를 남깁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Writing <bpt i="3" x="3">&lt;g3&gt;</bpt>simp only<ept i="3">&lt;/g3&gt;</ept> excludes these defaults,
allowing you to use a more explicitly crafted list of
rules.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170248Z" creationid="tlqk35" creationdate="20220524T170248Z">
        <seg><bpt i="3" x="3">&lt;g3&gt;</bpt>simp only<ept i="3">&lt;/g3&gt;</ept>를 쓰는 것은 여러분이 더 명시적으로 규칙 리스트를 
만들어 사용하도록 하여 이런 기본설정을 배제합니다,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>Yet again, the proofs can be compressed:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T164153Z" creationid="tlqk3" creationdate="20220527T162643Z">
        <seg>그러나 다시 이 증명은 간단히 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You
can then invoke this function using:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143957Z" creationid="tlqk35" creationdate="20220321T143957Z">
        <seg>여러분은 이 함수를 다음과 같이 불러낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You
have already seen a nice example of this: the type <bpt i="1" x="1">&lt;g1&gt;</bpt>List α<ept i="1">&lt;/g1&gt;</ept> depends
on the argument <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>, and this dependence is what distinguishes
<bpt i="3" x="3">&lt;g3&gt;</bpt>List Nat<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>List Bool<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150838Z" creationid="tlqk35" creationdate="20220321T150838Z">
        <seg>여러분은 이것에 대한 멋진 예제를 보았습니다. 유형  <bpt i="1" x="1">&lt;g1&gt;</bpt>List α<ept i="1">&lt;/g1&gt;</ept> 는 인수 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>에 의존합니다. 여기서  <bpt i="3" x="3">&lt;g3&gt;</bpt>List Nat<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>List Bool<ept i="4">&lt;/g4&gt;</ept>을 구분하는 것은 이 의존입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You
will see an example of this in a moment.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062825Z" creationid="tlqk35" creationdate="20220522T062806Z">
        <seg>어느 때에 여러분은 이에 대한 예를 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You are encouraged to experiment with similar examples in the exercises below.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T165407Z" creationid="tlqk3" creationdate="20220603T165407Z">
        <seg>여러분은 아래 연습에서 비슷한 예제로 실험해보길 권유합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You are now familiar with the fundamentals of dependent type theory,
both as a language for defining mathematical objects and a language
for constructing proofs.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172752Z" creationid="tlqk35" creationdate="20220524T172752Z">
        <seg>정의한 수학적 대상과 증명을 만드는 언어 모두로써 여러분은 이제 기초적인 의존 유형론에 친숙합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can
achieve that by marking it as a simplification rule when the theorem
is defined:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171604Z" creationid="tlqk35" creationdate="20220524T164802Z">
        <seg>여러분은 그것을 정리가 정의되었을 때 단순화 규칙으로 
표시함으로써 달성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can
enter these particular ones with <bpt i="13" x="13">&lt;g13&gt;</bpt>\a<ept i="13">&lt;/g13&gt;</ept>, <bpt i="14" x="14">&lt;g14&gt;</bpt>\b<ept i="14">&lt;/g14&gt;</ept>, and <bpt i="15" x="15">&lt;g15&gt;</bpt>\g<ept i="15">&lt;/g15&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140633Z" creationid="tlqk35" creationdate="20220321T140633Z">
        <seg>여러분은 이들 중 특정한 것은 <bpt i="13" x="13">&lt;g13&gt;</bpt>\a<ept i="13">&lt;/g13&gt;</ept>, <bpt i="14" x="14">&lt;g14&gt;</bpt>\b<ept i="14">&lt;/g14&gt;</ept>과 <bpt i="15" x="15">&lt;g15&gt;</bpt>\g<ept i="15">&lt;/g15&gt;</ept>으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can
then construct a proof by incrementally filling in these placeholders.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170510Z" creationid="tlqk35" creationdate="20220321T170510Z">
        <seg>그럼 여러분은 이 자리 차지자들을 점차 재우는 것으로 증명을 구성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can
use the command <bpt i="1" x="1">&lt;g1&gt;</bpt>#eval<ept i="1">&lt;/g1&gt;</ept> to execute expressions, and it is the
preferred way of testing your functions.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143808Z" creationid="tlqk35" creationdate="20220321T143808Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>#eval<ept i="1">&lt;/g1&gt;</ept> 명령을 사용해 식을 실행할 수 있습니다. 그리고 이것은 당신의 함수를 시험하는 선호되는 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can "combine" <bpt i="1" x="1">&lt;g1&gt;</bpt>intro h<ept i="1">&lt;/g1&gt;</ept> with <bpt i="2" x="2">&lt;g2&gt;</bpt>match h ...<ept i="2">&lt;/g2&gt;</ept> and write the previous examples as follows</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142341Z" creationid="tlqk35" creationdate="20220524T142341Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>intro h<ept i="1">&lt;/g1&gt;</ept>에  <bpt i="2" x="2">&lt;g2&gt;</bpt>match h ...<ept i="2">&lt;/g2&gt;</ept>을 "결합"할 수 있고 이전 예제를 다음과 같이 썼습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also avoid the parentheses around field
names if you add a line break between each field.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T174133Z" creationid="tlqk35" creationdate="20220528T174133Z">
        <seg>여러분이 각 필드 사이에 줄 바꿈 문자를 추가하면 여러분은 필드 이름 주위에 괄호를 쓰지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also declare new constants for types:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141350Z" creationid="tlqk35" creationdate="20220321T141350Z">
        <seg>여러분은 유형들에 대해 새 상수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also declare scoped instances in namespaces.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170759Z" creationid="tlqk3" creationdate="20220604T170759Z">
        <seg>여러분은 이름공간에서 범위가 지정된 개체를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also define <bpt i="1" x="1">&lt;g1&gt;</bpt>subst<ept i="1">&lt;/g1&gt;</ept> using <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220528T154304Z" creationid="tlqk35" creationdate="20220528T154304Z">
        <seg>여러분도 <bpt i="2" x="2">&lt;g2&gt;</bpt>match<ept i="2">&lt;/g2&gt;</ept>을 사용해 <bpt i="1" x="1">&lt;g1&gt;</bpt>subst<ept i="1">&lt;/g1&gt;</ept>을 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also define a function that takes another function as input.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144405Z" creationid="tlqk35" creationdate="20220321T144405Z">
        <seg>여러분은 또 다른 함수를 입력으로 받는 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also introduce auxiliary recursive declarations using <bpt i="1" x="1">&lt;g1&gt;</bpt>where<ept i="1">&lt;/g1&gt;</ept> clause after your definition.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182452Z" creationid="tlqk3" creationdate="20220603T182452Z">
        <seg>여러분도 부가적인 재귀 선언을 여러분의 정의 뒤에 <bpt i="1" x="1">&lt;g1&gt;</bpt>where<ept i="1">&lt;/g1&gt;</ept> 절을 사용해서 도입할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also limit the search using the following options:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180641Z" creationid="tlqk3" creationdate="20220604T180641Z">
        <seg>다음 옵션을 사용하여 검색을 제한할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also pass types as parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143154Z" creationid="tlqk35" creationdate="20220321T143154Z">
        <seg>여러분은 매개변수로 유형도 전달할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also provide multiple alternatives like in the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062637Z" creationid="tlqk35" creationdate="20220522T062637Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 표현식에서처럼 여러 가지 변형들을 제공할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also revert multiple elements of the context at once:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064409Z" creationid="tlqk35" creationdate="20220522T064409Z">
        <seg>여러분은 맥락 속 다수의 요소들을 한번에 되돌려 놓을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also temporarily disable an instance using the <bpt i="1" x="1">&lt;g1&gt;</bpt>attribute<ept i="1">&lt;/g1&gt;</ept> command
until the current <bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>namespace<ept i="3">&lt;/g3&gt;</ept> is closed, or until the end
of the current file.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T170531Z" creationid="tlqk3" creationdate="20220604T170531Z">
        <seg>여러분은 일시적으로 <bpt i="1" x="1">&lt;g1&gt;</bpt>attribute<ept i="1">&lt;/g1&gt;</ept> 명령으로 현재 닫힌 <bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept>이나 <bpt i="3" x="3">&lt;g3&gt;</bpt>namespace<ept i="3">&lt;/g3&gt;</ept>까지 혹은 현재 파일의 끝까지 개체를 사용 해제 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> with an arbitrary expression.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T165651Z" creationid="tlqk3" creationdate="20220527T165651Z">
        <seg>여러분은 임의의 표현식에 <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept>를 사용할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept> in tactic mode and for creating proofs by induction.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T182401Z" creationid="tlqk3" creationdate="20220603T182401Z">
        <seg>여러분도 전략 모드에서 귀납법으로 증명을 만들 때에 <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept>을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> in tactic blocks.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T142250Z" creationid="tlqk35" creationdate="20220524T142250Z">
        <seg>여러분은 전략 블록에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use a (unstructured) <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> without the <bpt i="2" x="2">&lt;g2&gt;</bpt>with<ept i="2">&lt;/g2&gt;</ept> and a tactic
for each alternative.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070650Z" creationid="tlqk35" creationdate="20220522T070650Z">
        <seg>여러분은 (비구조화된)<bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept>를 각각의 변형과 전략에 대해 <bpt i="2" x="2">&lt;g2&gt;</bpt>with<ept i="2">&lt;/g2&gt;</ept> 없이 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the
ASCII alternative <bpt i="5" x="5">&lt;g5&gt;</bpt>-&gt;<ept i="5">&lt;/g5&gt;</ept>, so the expressions <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat -&gt; Nat<ept i="6">&lt;/g6&gt;</ept> and <bpt i="7" x="7">&lt;g7&gt;</bpt>Nat →
Nat<ept i="7">&lt;/g7&gt;</ept> mean the same thing.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140458Z" creationid="tlqk35" creationdate="20220321T140458Z">
        <seg>여러분은 ASCII 대체 표현으로 <bpt i="5" x="5">&lt;g5&gt;</bpt>-&gt;<ept i="5">&lt;/g5&gt;</ept>을 사용할 수 있습니다. 그래서 표현식 <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat -&gt; Nat<ept i="6">&lt;/g6&gt;</ept>과 <bpt i="7" x="7">&lt;g7&gt;</bpt>Nat → Nat<ept i="7">&lt;/g7&gt;</ept>은 같은 식을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the <bpt i="1" x="1">&lt;g1&gt;</bpt>rename_i<ept i="1">&lt;/g1&gt;</ept> tactic to rename the most recent inaccessible names in your context.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T063523Z" creationid="tlqk35" creationdate="20220522T063523Z">
        <seg>혹은 <bpt i="1" x="1">&lt;g1&gt;</bpt>rename_i<ept i="1">&lt;/g1&gt;</ept> 전략으로 여러분의 상황에 가장 최근에 접속불가한 이름을 바꿀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the ascii equivalent, <bpt i="5" x="5">&lt;g5&gt;</bpt>&lt;-<ept i="5">&lt;/g5&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T172014Z" creationid="tlqk35" creationdate="20220524T155130Z">
        <seg>여러분은 아스키 등가 <bpt i="5" x="5">&lt;g5&gt;</bpt>&lt;-<ept i="5">&lt;/g5&gt;</ept>를 사용하는데 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the auxiliary definition <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstanceAs<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T180055Z" creationid="tlqk3" creationdate="20220604T180055Z">
        <seg>여러분은 부가 정의 <bpt i="1" x="1">&lt;g1&gt;</bpt>inferInstanceAs<ept i="1">&lt;/g1&gt;</ept>도 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also use the combinator <bpt i="1" x="1">&lt;g1&gt;</bpt>tac1 &lt;;&gt; tac2<ept i="1">&lt;/g1&gt;</ept> to apply <bpt i="2" x="2">&lt;g2&gt;</bpt>tac2<ept i="2">&lt;/g2&gt;</ept> to each
subgoal produced by tactic <bpt i="3" x="3">&lt;g3&gt;</bpt>tac1<ept i="3">&lt;/g3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T070932Z" creationid="tlqk35" creationdate="20220522T070932Z">
        <seg>또 여러분은 조합자  <bpt i="1" x="1">&lt;g1&gt;</bpt>tac1 &lt;;&gt; tac2<ept i="1">&lt;/g1&gt;</ept>를 각각의 하위 목표가 만든
 <bpt i="2" x="2">&lt;g2&gt;</bpt>tac2<ept i="2">&lt;/g2&gt;</ept>에 <bpt i="3" x="3">&lt;g3&gt;</bpt>tac1<ept i="3">&lt;/g3&gt;</ept>의 전략을 적용하여 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can also write the example above using <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T173558Z" creationid="tlqk3" creationdate="20220529T173558Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept>를 사용해 위의 예제를 쓸 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can assign other priorities
when defining an instance.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181650Z" creationid="tlqk3" creationdate="20220604T181650Z">
        <seg>개체를 정의할 때 다른 우선 순위를 할당할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can avoid the <bpt i="1" x="1">&lt;g1&gt;</bpt>universe<ept i="1">&lt;/g1&gt;</ept> command by providing the universe parameters when defining <bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T134439Z" creationid="tlqk3" creationdate="20220526T134439Z">
        <seg>여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>compose<ept i="2">&lt;/g2&gt;</ept>를 정의할 때 세계 매개변수를 제공하여 <bpt i="1" x="1">&lt;g1&gt;</bpt>universe<ept i="1">&lt;/g1&gt;</ept> 명령을 피할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can avoid the parentheses if you add a line break between each field.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T145600Z" creationid="tlqk3" creationdate="20220527T145600Z">
        <seg>여러분은 각 필드 사이에 줄바꿈 문자를 추가하면 괄호를 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can avoid the universe command by providing the universe parameters when defining F.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142112Z" creationid="tlqk35" creationdate="20220321T142112Z">
        <seg>여러분은 F를 정의할 때 universe 매개변수를 제공하는 것으로 universe 명령을 쓰지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can change the order that type classes instances are tried by
assigning them a <bpt i="1" x="1">&lt;g1&gt;</bpt>priority<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T181553Z" creationid="tlqk3" creationdate="20220604T181553Z">
        <seg>유형 클래스 개체에 <bpt i="1" x="1">&lt;g1&gt;</bpt>우선순위<ept i="1">&lt;/g1&gt;</ept>를 할당하여 그들이 시도되는 순서를 변경할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can check that this definition of <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept> satisfies the same
definitional identities as before.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T165148Z" creationid="tlqk3" creationdate="20220529T165148Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>foo<ept i="1">&lt;/g1&gt;</ept>의 정의가 이전처럼 같은 정의 항등식을 만족하는 것을 확인할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can combine multiple assignments by chaining <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> statements:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144834Z" creationid="tlqk35" creationdate="20220321T144834Z">
        <seg>여러분은 다수의 할당을 <bpt i="1" x="1">&lt;g1&gt;</bpt>let<ept i="1">&lt;/g1&gt;</ept> 구문으로 연결함으로써 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can combine the unstructured <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> tactic with the <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>.<ept i="3">&lt;/g3&gt;</ept> notation.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T071028Z" creationid="tlqk35" creationdate="20220522T071028Z">
        <seg>여러분은 비구조화된 <bpt i="1" x="1">&lt;g1&gt;</bpt>cases<ept i="1">&lt;/g1&gt;</ept> 전략을  <bpt i="2" x="2">&lt;g2&gt;</bpt>case<ept i="2">&lt;/g2&gt;</ept>와 <bpt i="3" x="3">&lt;g3&gt;</bpt>.<ept i="3">&lt;/g3&gt;</ept> 기호와 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can declare a subterm inaccessible by writing
<bpt i="2" x="2">&lt;g2&gt;</bpt>.(t)<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T143857Z" creationid="tlqk3" creationdate="20220604T143857Z">
        <seg>여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>.(t)<ept i="2">&lt;/g2&gt;</ept>와 같이 작성하여 접근불가한 부분항을 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can declare variables of any type, not just <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept> itself:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T145206Z" creationid="tlqk35" creationdate="20220321T145206Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept> 그 자체뿐만 아니라 임의의 유형의 변수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can define default instances with higher
priority to override the builtin ones.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T165720Z" creationid="tlqk3" creationdate="20220604T165720Z">
        <seg>여러분은 내장된 것보다 우세하여 더 높은 우선순위를 갖는 기본 개체를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can define local recursive declarations using the <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept> keyword.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T181948Z" creationid="tlqk3" creationdate="20220603T181948Z">
        <seg>여러분은 지역적으로 재귀 선언을 <bpt i="1" x="1">&lt;g1&gt;</bpt>let rec<ept i="1">&lt;/g1&gt;</ept> 키워드를 사용해 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can enter the unicode
arrow <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept> by typing <bpt i="2" x="2">&lt;g2&gt;</bpt>\to<ept i="2">&lt;/g2&gt;</ept> or <bpt i="3" x="3">&lt;g3&gt;</bpt>\r<ept i="3">&lt;/g3&gt;</ept> or <bpt i="4" x="4">&lt;g4&gt;</bpt>\-&gt;<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140358Z" creationid="tlqk35" creationdate="20220321T140358Z">
        <seg>여러분은 유니코드 화살표 <bpt i="1" x="1">&lt;g1&gt;</bpt>→<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="2" x="2">&lt;g2&gt;</bpt>\to<ept i="2">&lt;/g2&gt;</ept>을 치거나 or <bpt i="3" x="3">&lt;g3&gt;</bpt>\r<ept i="3">&lt;/g3&gt;</ept>또는 <bpt i="4" x="4">&lt;g4&gt;</bpt>\-&gt;<ept i="4">&lt;/g4&gt;</ept>으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can evaluate a lambda function by passing the required parameters:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142224Z" creationid="tlqk35" creationdate="20220321T142224Z">
        <seg>여러분은 필요한 매개변수를 람다 함수에 넘겨줌으로써 값을 평가할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can get a sense of how it works by looking at the types of
<bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.below<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat.brecOn<ept i="5">&lt;/g5&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T164255Z" creationid="tlqk3" creationdate="20220603T164255Z">
        <seg>여러분은 <bpt i="4" x="4">&lt;g4&gt;</bpt>Nat.below<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="5" x="5">&lt;g5&gt;</bpt>Nat.brecOn<ept i="5">&lt;/g5&gt;</ept>의 유형을 봄으로써 이것이 어떻게 동작하는지에 대해 감을 얻을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can import the classical axioms and make the generic
instance of decidability available by opening the <bpt i="1" x="1">&lt;g1&gt;</bpt>Classical<ept i="1">&lt;/g1&gt;</ept> namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T173723Z" creationid="tlqk3" creationdate="20220604T173723Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Classical<ept i="1">&lt;/g1&gt;</ept>  이름공간을 여는 것으로 여러분은 고전적 공리를 불러올 수 있고 결정가능성의 일반적 개체를 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can input the raw natural number <bpt i="7" x="7">&lt;g7&gt;</bpt>2<ept i="7">&lt;/g7&gt;</ept> using the macro <bpt i="8" x="8">&lt;g8&gt;</bpt>nat_lit 2<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162833Z" creationid="tlqk3" creationdate="20220604T162833Z">
        <seg>여러분은 생 자연수 <bpt i="7" x="7">&lt;g7&gt;</bpt>2<ept i="7">&lt;/g7&gt;</ept>를 매크로 <bpt i="8" x="8">&lt;g8&gt;</bpt>nat_lit 2<ept i="8">&lt;/g8&gt;</ept>을 사용해 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can omit <bpt i="1" x="1">&lt;g1&gt;</bpt>: Weekday<ept i="1">&lt;/g1&gt;</ept> when declaring the <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept> inductive type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151932Z" creationid="tlqk3" creationdate="20220526T145402Z">
        <seg>여러분은  귀납형 <bpt i="2" x="2">&lt;g2&gt;</bpt>Weekday<ept i="2">&lt;/g2&gt;</ept>를 선언할 때 <bpt i="1" x="1">&lt;g1&gt;</bpt>: Weekday<ept i="1">&lt;/g1&gt;</ept>을 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can omit the type declarations when Lean has enough information to
infer it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144044Z" creationid="tlqk35" creationdate="20220321T144044Z">
        <seg>Lean이 유형을 추론하기에 충분한 정보를 갖고있을 때 여러분은 유형 선언을 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can only <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept> an element of the local context, that is, a
local variable or hypothesis.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T064550Z" creationid="tlqk35" creationdate="20220522T064550Z">
        <seg>여러분은 국부적인 상황 속 요소 즉, 지역변수나 가정을 <bpt i="1" x="1">&lt;g1&gt;</bpt>revert<ept i="1">&lt;/g1&gt;</ept> 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can pass functions as parameters and by giving them names <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>
and <bpt i="2" x="2">&lt;g2&gt;</bpt>g<ept i="2">&lt;/g2&gt;</ept> you can then use those functions in the implementation:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143134Z" creationid="tlqk35" creationdate="20220321T143134Z">
        <seg>여러분은 매개변수로 함수의 이름  <bpt i="1" x="1">&lt;g1&gt;</bpt>f<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>g<ept i="2">&lt;/g2&gt;</ept> 을 주는 것으로 함수를 전달할 수 있습니다.  그러면 구현에서 이들 함수를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can probably guess what this one will do.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144354Z" creationid="tlqk35" creationdate="20220321T144354Z">
        <seg>여러분은 이 정의가 아마 뭘 할 지 추측할 수 있을 거예요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can prove the theorem above
in that way:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184540Z" creationid="tlqk35" creationdate="20220321T184540Z">
        <seg>여러분은 위의 정리를 그와 같이 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can prove this by induction on <bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162522Z" creationid="tlqk3" creationdate="20220527T162522Z">
        <seg>여러분은 이것을 <bpt i="2" x="2">&lt;g2&gt;</bpt>m<ept i="2">&lt;/g2&gt;</ept>에 대한 귀납으로 증명할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can provide different expansions, and the tactic
interpreter will try all of them until one succeeds.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170741Z" creationid="tlqk35" creationdate="20220524T170741Z">
        <seg>여러분은 다른 확장을 제공할 수 있다. 그리고 전략 
해석기는 한 개가 성공할 때까지 그들 모두를 시도할 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can see that each one of the expressions above is an object of
type <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141344Z" creationid="tlqk35" creationdate="20220321T141344Z">
        <seg>여러분도 보다시피 위 각각의 표현식은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Type<ept i="1">&lt;/g1&gt;</ept> 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can see the contents of these directories and files using GitHub's
browser interface.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T131400Z" creationid="tlqk3" creationdate="20220526T131400Z">
        <seg>여러분은 깃허브 브라우저 인터페이스로 이 디렉토리와 파일의 내용물을 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can see the correct order
in an editor by placing the cursor on the <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> identifier to see
the documentation string that is associated with it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T165951Z" creationid="tlqk35" creationdate="20220524T165951Z">
        <seg>여려분은 이와 연관된 문서 끈을 보기 위해 <bpt i="3" x="3">&lt;g3&gt;</bpt>simp<ept i="3">&lt;/g3&gt;</ept> 식별자에 커서를 놓아
편집기에서 옳은 순서를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can see the resulting proof term with the <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept> command:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055446Z" creationid="tlqk35" creationdate="20220522T055446Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept> 명령으로 증명항의 결과를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can solve the subgoal <bpt i="1" x="1">&lt;g1&gt;</bpt>right<ept i="1">&lt;/g1&gt;</ept> before <bpt i="2" x="2">&lt;g2&gt;</bpt>left<ept i="2">&lt;/g2&gt;</ept> using the <bpt i="3" x="3">&lt;g3&gt;</bpt>case<ept i="3">&lt;/g3&gt;</ept>
notation</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061342Z" creationid="tlqk35" creationdate="20220522T061342Z">
        <seg>여러분은 <bpt i="3" x="3">&lt;g3&gt;</bpt>case<ept i="3">&lt;/g3&gt;</ept>기호를 사용해서 하위목표 <bpt i="2" x="2">&lt;g2&gt;</bpt>left<ept i="2">&lt;/g2&gt;</ept>보다 먼저 <bpt i="1" x="1">&lt;g1&gt;</bpt>right<ept i="1">&lt;/g1&gt;</ept>을 풀 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can structure your tactics using the
notation <bpt i="6" x="6">&lt;g6&gt;</bpt>case &lt;tag&gt; =&gt; &lt;tactics&gt;<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T061221Z" creationid="tlqk35" creationdate="20220522T061221Z">
        <seg>여러분은 여러분의 전략을 <bpt i="6" x="6">&lt;g6&gt;</bpt>case &lt;tag&gt; =&gt; &lt;tactics&gt;<ept i="6">&lt;/g6&gt;</ept>기호를 사용해 구조화할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can then replace the <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept> in the previous proof with <bpt i="2" x="2">&lt;g2&gt;</bpt>succ_add<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T162623Z" creationid="tlqk3" creationdate="20220527T162623Z">
        <seg>그럼 여러분은 이전 증명에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>sorry<ept i="1">&lt;/g1&gt;</ept>를 <bpt i="2" x="2">&lt;g2&gt;</bpt>succ_add<ept i="2">&lt;/g2&gt;</ept>으로 대체할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can therefore proceed as
though <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>γ<ept i="4">&lt;/g4&gt;</ept>, <bpt i="5" x="5">&lt;g5&gt;</bpt>g<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept>, <bpt i="7" x="7">&lt;g7&gt;</bpt>h<ept i="7">&lt;/g7&gt;</ept>, and <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept> are fixed
objects when you write your definitions, and let Lean abstract the
definitions for you automatically.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150013Z" creationid="tlqk35" creationdate="20220321T150013Z">
        <seg>그러므로 여러분은 여러분의 정의를 작성할 때  <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>, <bpt i="3" x="3">&lt;g3&gt;</bpt>β<ept i="3">&lt;/g3&gt;</ept>, <bpt i="4" x="4">&lt;g4&gt;</bpt>γ<ept i="4">&lt;/g4&gt;</ept>, <bpt i="5" x="5">&lt;g5&gt;</bpt>g<ept i="5">&lt;/g5&gt;</ept>, <bpt i="6" x="6">&lt;g6&gt;</bpt>f<ept i="6">&lt;/g6&gt;</ept>, <bpt i="7" x="7">&lt;g7&gt;</bpt>h<ept i="7">&lt;/g7&gt;</ept>, <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>가 고정된 대상임에도 사용할 수 있습니다. 그리고 lean이 여러분을 위해 자동으로 정의를 축약할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can think of
the inhabitant of <bpt i="10" x="10">&lt;g10&gt;</bpt>p<ept i="10">&lt;/g10&gt;</ept> as being the "fact that <bpt i="11" x="11">&lt;g11&gt;</bpt>p<ept i="11">&lt;/g11&gt;</ept> is true." A
proof of <bpt i="12" x="12">&lt;g12&gt;</bpt>p → q<ept i="12">&lt;/g12&gt;</ept> uses "the fact that <bpt i="13" x="13">&lt;g13&gt;</bpt>p<ept i="13">&lt;/g13&gt;</ept> is true" to obtain "the
fact that <bpt i="14" x="14">&lt;g14&gt;</bpt>q<ept i="14">&lt;/g14&gt;</ept> is true."</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T160148Z" creationid="tlqk35" creationdate="20220321T160148Z">
        <seg><bpt i="10" x="10">&lt;g10&gt;</bpt>p<ept i="10">&lt;/g10&gt;</ept>의 머무름은 "<bpt i="11" x="11">&lt;g11&gt;</bpt>p<ept i="11">&lt;/g11&gt;</ept>가 참이라는 사실"이라 생각할 수 있습니다. <bpt i="12" x="12">&lt;g12&gt;</bpt>p → q<ept i="12">&lt;/g12&gt;</ept>의 증명은 "<bpt i="13" x="13">&lt;g13&gt;</bpt>p<ept i="13">&lt;/g13&gt;</ept>가 참이라는 사실"을 "<bpt i="14" x="14">&lt;g14&gt;</bpt>q<ept i="14">&lt;/g14&gt;</ept>이 참이라는 사실"을 얻기위해 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can type
things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you
type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T134940Z" creationid="tlqk35" creationdate="20220321T134940Z">
        <seg>여러분은 편집기에 무언가를 치거나 예제를 수정할 수 있습니다. 그리고 린은 여러분이 치는 동안 지속적으로 결과를 확인하고 피드백을 제공할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can type these corner quotes using <bpt i="3" x="3">&lt;g3&gt;</bpt>\f&lt;<ept i="3">&lt;/g3&gt;</ept> and <bpt i="4" x="4">&lt;g4&gt;</bpt>\f&gt;<ept i="4">&lt;/g4&gt;</ept>,
respectively.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183500Z" creationid="tlqk35" creationdate="20220321T183500Z">
        <seg>여러분은 이런 인용 꺽쇠를 각각 <bpt i="3" x="3">&lt;g3&gt;</bpt>\f&lt;<ept i="3">&lt;/g3&gt;</ept>과 <bpt i="4" x="4">&lt;g4&gt;</bpt>\f&gt;<ept i="4">&lt;/g4&gt;</ept>을 사용해서 칠 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="3" x="3">&lt;g3&gt;</bpt>match<ept i="3">&lt;/g3&gt;</ept> to provide a proof of the claim for each
constructor:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T151407Z" creationid="tlqk3" creationdate="20220526T151407Z">
        <seg>우리는 각 생성자에 대해 주장의 증명을 제공하기 위해 <bpt i="3" x="3">&lt;g3&gt;</bpt>match<ept i="3">&lt;/g3&gt;</ept>를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use <bpt i="9" x="9">&lt;g9&gt;</bpt>⟨a, b⟩<ept i="9">&lt;/g9&gt;</ept> or <bpt i="10" x="10">&lt;g10&gt;</bpt>Sigma.mk a b<ept i="10">&lt;/g10&gt;</ept> to create a
dependent pair.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T152318Z" creationid="tlqk35" creationdate="20220321T152318Z">
        <seg>여러분은 <bpt i="9" x="9">&lt;g9&gt;</bpt>⟨a, b⟩<ept i="9">&lt;/g9&gt;</ept> 또는 <bpt i="10" x="10">&lt;g10&gt;</bpt>Sigma.mk a b<ept i="10">&lt;/g10&gt;</ept>를 종속적 쌍을 만드는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use a numeral (e.g., <bpt i="1" x="1">&lt;g1&gt;</bpt>2<ept i="1">&lt;/g1&gt;</ept>) to denote an element of any type that implements
the type class <bpt i="2" x="2">&lt;g2&gt;</bpt>OfNat<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162337Z" creationid="tlqk3" creationdate="20220604T162337Z">
        <seg>여러분은 수치값(예를 들어 <bpt i="1" x="1">&lt;g1&gt;</bpt>2<ept i="1">&lt;/g1&gt;</ept>)을 유형클래스 <bpt i="2" x="2">&lt;g2&gt;</bpt>OfNat<ept i="2">&lt;/g2&gt;</ept>을 구현하는 임의의 유형의 원소를 표시하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use it to introduce several variables:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T062237Z" creationid="tlqk35" creationdate="20220522T062237Z">
        <seg>여러분은 몇 개의 변수들을 도입하는데 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use other more interesting expressions inside a <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept>:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T144344Z" creationid="tlqk35" creationdate="20220321T144344Z">
        <seg>여러분은 다른 더 흥미로운 식을 <bpt i="1" x="1">&lt;g1&gt;</bpt>def<ept i="1">&lt;/g1&gt;</ept> 안에 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use our new scalar array multiplication instance on arrays of type <bpt i="1" x="1">&lt;g1&gt;</bpt>Array β<ept i="1">&lt;/g1&gt;</ept>
with a scalar of type <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept> whenever you have an instance <bpt i="3" x="3">&lt;g3&gt;</bpt>HMul α β γ<ept i="3">&lt;/g3&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T164444Z" creationid="tlqk3" creationdate="20220604T164444Z">
        <seg>여러분은 <bpt i="3" x="3">&lt;g3&gt;</bpt>HMul α β γ<ept i="3">&lt;/g3&gt;</ept> 개체를 갖는 언제든지 우리의 새 스칼라 배열 곱셈 개체를 유형 <bpt i="2" x="2">&lt;g2&gt;</bpt>α<ept i="2">&lt;/g2&gt;</ept>의 스칼라와 <bpt i="1" x="1">&lt;g1&gt;</bpt>Array β<ept i="1">&lt;/g1&gt;</ept>형의 배열에 대해 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> notation in tactics too:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T172314Z" creationid="tlqk3" creationdate="20220527T172314Z">
        <seg>여러분은 전략에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>match<ept i="1">&lt;/g1&gt;</ept> 기호도 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the command <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept> to inspect how simple <bpt i="2" x="2">&lt;g2&gt;</bpt>inferInstance<ept i="2">&lt;/g2&gt;</ept> is.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T161816Z" creationid="tlqk3" creationdate="20220604T161816Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>#print<ept i="1">&lt;/g1&gt;</ept> 명령으로 <bpt i="2" x="2">&lt;g2&gt;</bpt>inferInstance<ept i="2">&lt;/g2&gt;</ept>가 얼마나 단순한지 검사할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the command <bpt i="1" x="1">&lt;g1&gt;</bpt>export<ept i="1">&lt;/g1&gt;</ept> to create the alias <bpt i="2" x="2">&lt;g2&gt;</bpt>default<ept i="2">&lt;/g2&gt;</ept> for <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited.default<ept i="3">&lt;/g3&gt;</ept></seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T160544Z" creationid="tlqk3" creationdate="20220604T160544Z">
        <seg>여러분은 g1&gt;export<it pos="end" x="1">&lt;/g1&gt;</it> 명령으로 <bpt i="3" x="3">&lt;g3&gt;</bpt>Inhabited.default<ept i="3">&lt;/g3&gt;</ept>에 대한 <bpt i="2" x="2">&lt;g2&gt;</bpt>기본<ept i="2">&lt;/g2&gt;</ept> 별명을 만들 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can use the command <bpt i="1" x="1">&lt;g1&gt;</bpt>open scoped &lt;namespace&gt;<ept i="1">&lt;/g1&gt;</ept> to activate scoped attributes but will
not "open" the names from the namespace.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T171041Z" creationid="tlqk3" creationdate="20220604T171041Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>open scoped &lt;namespace&gt;<ept i="1">&lt;/g1&gt;</ept> 명령으로 범위가 지정된 속정을 활성화할 수 있습니다. 그러나 이름공간으로부터 이름들을 "개방"하지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can view an element of
the type <bpt i="2" x="2">&lt;g2&gt;</bpt>ImageOf f b<ept i="2">&lt;/g2&gt;</ept> as evidence that <bpt i="3" x="3">&lt;g3&gt;</bpt>b<ept i="3">&lt;/g3&gt;</ept> is in the image of
<bpt i="4" x="4">&lt;g4&gt;</bpt>f<ept i="4">&lt;/g4&gt;</ept>, whereby the constructor <bpt i="5" x="5">&lt;g5&gt;</bpt>imf<ept i="5">&lt;/g5&gt;</ept> is used to build such
evidence.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T144235Z" creationid="tlqk3" creationdate="20220604T144235Z">
        <seg>여러분은 <bpt i="2" x="2">&lt;g2&gt;</bpt>ImageOf f b<ept i="2">&lt;/g2&gt;</ept>형 원소를 <bpt i="3" x="3">&lt;g3&gt;</bpt>b<ept i="3">&lt;/g3&gt;</ept>가 <bpt i="4" x="4">&lt;g4&gt;</bpt>f<ept i="4">&lt;/g4&gt;</ept>의 이미지에 있다는 증거로 볼 수 있습니다. 이로써 생성자 <bpt i="5" x="5">&lt;g5&gt;</bpt>imf<ept i="5">&lt;/g5&gt;</ept>는 그런 증거를 만드는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can view the parameter of the type class <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited<ept i="1">&lt;/g1&gt;</ept> as an <bpt i="2" x="2">&lt;g2&gt;</bpt>input<ept i="2">&lt;/g2&gt;</ept> value for the type class synthesizer.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T163519Z" creationid="tlqk3" creationdate="20220604T163519Z">
        <seg>여러분은 유형 클래스 합성기에 대한 <bpt i="2" x="2">&lt;g2&gt;</bpt>입력<ept i="2">&lt;/g2&gt;</ept>값으로써 유형 클래스 <bpt i="1" x="1">&lt;g1&gt;</bpt>Inhabited<ept i="1">&lt;/g1&gt;</ept>의 매개변수를 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can write <bpt i="1" x="1">&lt;g1&gt;</bpt>#print sub2<ept i="1">&lt;/g1&gt;</ept> to see how the function was compiled to
recursors.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T162607Z" creationid="tlqk3" creationdate="20220529T162607Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>#print sub2<ept i="1">&lt;/g1&gt;</ept>를 써 어떻게 함수가 재귀자로부터 컴파일되었는지 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can write a tactic script incrementally.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220522T055516Z" creationid="tlqk35" creationdate="20220522T055516Z">
        <seg>여러분은 점진적으로 전략 스크립트를 쓸 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can write this goal as follows:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T184440Z" creationid="tlqk35" creationdate="20220321T184440Z">
        <seg>여러분은 이 목표를 다음과 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You can, in general, leave off the
type annotation and let Lean infer it for you.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T142754Z" creationid="tlqk35" creationdate="20220321T142754Z">
        <seg>일반적으로 여러분도 유형 표기를 빼고 린에게 유형을 추론하게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You do not have to indent the lines within a section.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T150121Z" creationid="tlqk35" creationdate="20220321T150121Z">
        <seg>섹션 안에서 줄에 들여쓰기를 하거나 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have actually come up against one of the most subtle aspects of
Lean's typing system.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141553Z" creationid="tlqk35" creationdate="20220321T141553Z">
        <seg>여러분은 린의 유형화 시스템의 가장 미묘한 면 중 하나를 마주쳤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have already seen the
introduction rules for an inductive type: they are just the
constructors that are specified in the definition of the type.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151848Z" creationid="tlqk3" creationdate="20220526T144511Z">
        <seg>여러분은 귀납형에 대한 도입규칙을 이미 봤었습니다. 그들은 그저 유형의 정의에서 명시된 생성자들일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have already seen two of the
most common ones, <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>#eval<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T125134Z" creationid="tlqk3" creationdate="20220526T125134Z">
        <seg>여러분은 가장 흔한 것 중 두 개인 <bpt i="1" x="1">&lt;g1&gt;</bpt>#check<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>#eval<ept i="2">&lt;/g2&gt;</ept>를 봤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have seen that if you have <bpt i="1" x="1">&lt;g1&gt;</bpt>m : Nat<ept i="1">&lt;/g1&gt;</ept> and <bpt i="2" x="2">&lt;g2&gt;</bpt>n : Nat<ept i="2">&lt;/g2&gt;</ept>, then
<bpt i="3" x="3">&lt;g3&gt;</bpt>(m, n)<ept i="3">&lt;/g3&gt;</ept> denotes the ordered pair of <bpt i="4" x="4">&lt;g4&gt;</bpt>m<ept i="4">&lt;/g4&gt;</ept> and <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept> which is of
type <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat × Nat<ept i="6">&lt;/g6&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T141120Z" creationid="tlqk35" creationdate="20220321T141120Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>m : Nat<ept i="1">&lt;/g1&gt;</ept>과  <bpt i="2" x="2">&lt;g2&gt;</bpt>n : Nat<ept i="2">&lt;/g2&gt;</ept>이면, <bpt i="3" x="3">&lt;g3&gt;</bpt>(m, n)<ept i="3">&lt;/g3&gt;</ept>은 <bpt i="6" x="6">&lt;g6&gt;</bpt>Nat × Nat<ept i="6">&lt;/g6&gt;</ept>유형인 <bpt i="4" x="4">&lt;g4&gt;</bpt>m<ept i="4">&lt;/g4&gt;</ept>과 <bpt i="5" x="5">&lt;g5&gt;</bpt>n<ept i="5">&lt;/g5&gt;</ept>의 순서쌍을 가리킨다는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You have to remember that the second
argument to <bpt i="5" x="5">&lt;g5&gt;</bpt>div.F<ept i="5">&lt;/g5&gt;</ept>, the recipe for the recursion, is a function
that is supposed to return the divide by <bpt i="6" x="6">&lt;g6&gt;</bpt>y<ept i="6">&lt;/g6&gt;</ept> function for all values
<bpt i="7" x="7">&lt;g7&gt;</bpt>x₁<ept i="7">&lt;/g7&gt;</ept> smaller than <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T171543Z" creationid="tlqk3" creationdate="20220603T171543Z">
        <seg>여러분은 재귀를 위한 요리법인 <bpt i="5" x="5">&lt;g5&gt;</bpt>div.F<ept i="5">&lt;/g5&gt;</ept>의 두 번째 인수가 <bpt i="8" x="8">&lt;g8&gt;</bpt>x<ept i="8">&lt;/g8&gt;</ept>보다 작은 모든 <bpt i="7" x="7">&lt;g7&gt;</bpt>x₁<ept i="7">&lt;/g7&gt;</ept>값에 대한 <bpt i="6" x="6">&lt;g6&gt;</bpt>y<ept i="6">&lt;/g6&gt;</ept> 함수로 나눠진 것을 반환하기로 한 함수임을 기억해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You implement the instance
for your own types and use chaining to convert complex values into strings.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T162011Z" creationid="tlqk3" creationdate="20220604T162011Z">
        <seg>여러분은 여러분의 유형을 위한 개체를 구현하고 문자열로 복잡한 값에서 문자열로 연결하기를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You may
also provide the value for an implicit parameter when Lean failed to
infer it.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T140846Z" creationid="tlqk3" creationdate="20220526T140846Z">
        <seg>여러분은 린이 그것에 대해 추론을 실패했을 때 암시적인 매개변수에 대한 값을 제공할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You saw in <bpt i="1" x="1">&lt;g1&gt;</bpt>Variables and Sections<ept i="1">&lt;/g1&gt;</ept> that the
<bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept> command makes it possible not only to group together
elements of a theory that go together, but also to declare variables
that are inserted as arguments to theorems and definitions, as
necessary.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174919Z" creationid="tlqk35" creationdate="20220524T174919Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>Variables and Sections<ept i="1">&lt;/g1&gt;</ept>에서 <bpt i="2" x="2">&lt;g2&gt;</bpt>section<ept i="2">&lt;/g2&gt;</ept> 명령으로 필요하다면
함께 할 이론의 요소를 한데 묶을 수 있을 뿐만 아니라 정리와 정의에 인수로 삽입될 변수를 선언할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should also try to understand why the reverse implication is not derivable in the last example.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183807Z" creationid="tlqk35" creationdate="20220321T183807Z">
        <seg>여러분은 왜 명제의 역이 마지막 예제에서 불가능한지 이해하려고 시도해봐야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should get 47 here.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180544Z" creationid="tlqk3" creationdate="20220603T180544Z">
        <seg>여러분은 여기서 47을 얻어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should think about how these give rise to the introduction and
elimination rules that you have already seen.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T151659Z" creationid="tlqk3" creationdate="20220527T151659Z">
        <seg>여러분은 이것이 어떻게 여러분이 이미 봐온 도입과 제거 규칙을 제공하는지에 대해 생각해봐야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You should try
declaring some constants and type checking some expressions on your
own.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T135902Z" creationid="tlqk35" creationdate="20220321T135902Z">
        <seg>여러분은 스스로 몇몇 상수를 선언하고 몇 가지 식의 유형을 확인해보길 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will generally use lower-case Greek
letters like <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>, <bpt i="11" x="11">&lt;g11&gt;</bpt>β<ept i="11">&lt;/g11&gt;</ept>, and <bpt i="12" x="12">&lt;g12&gt;</bpt>γ<ept i="12">&lt;/g12&gt;</ept> to range over types.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T140558Z" creationid="tlqk35" creationdate="20220321T140558Z">
        <seg>여러분은 유형을 포괄하기 위해  <bpt i="10" x="10">&lt;g10&gt;</bpt>α<ept i="10">&lt;/g10&gt;</ept>, <bpt i="11" x="11">&lt;g11&gt;</bpt>β<ept i="11">&lt;/g11&gt;</ept>, <bpt i="12" x="12">&lt;g12&gt;</bpt>γ<ept i="12">&lt;/g12&gt;</ept>같은 그리스 소문자 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will have no doubt noticed by now that tactics can fail.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T151032Z" creationid="tlqk35" creationdate="20220524T151032Z">
        <seg>여러분은 이제 의심의 여지없이 전략은 실패할 것임을 눈치챌 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will learn various methods to support this in <bpt i="1" x="1">&lt;g1&gt;</bpt>dependent type
theory<ept i="1">&lt;/g1&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T132230Z" creationid="tlqk35" creationdate="20220321T132230Z">
        <seg>여러분은 <bpt i="1" x="1">&lt;g1&gt;</bpt>의존 유형론<ept i="1">&lt;/g1&gt;</ept>에서 이를 지원하는 다양한 방법에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will see in <bpt i="1" x="1">&lt;g1&gt;</bpt>Chapter Inductive Types<ept i="1">&lt;/g1&gt;</ept> that
these tactics are quite general.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T151735Z" creationid="tlqk35" creationdate="20220522T071625Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>귀납형 장<ept i="1">&lt;/g1&gt;</ept>에서 이 전략들은 꽤나 일반적임을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>You will see later how these terms are evaluated.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T143658Z" creationid="tlqk35" creationdate="20220321T143658Z">
        <seg>여러분은 나중에 이 항들이 어떻게 평가되는지 볼 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>apply And.intro &lt;;&gt; triv

-- We now add a (recursive) extension
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T171116Z" creationid="tlqk35" creationdate="20220524T171116Z">
        <seg>apply And.intro &lt;;&gt; triv

-- 이제 우리는 (재귀적인) 확장을 추가합니다.
macro_rules | `(tactic| triv) =&gt; `(tactic| apply And.intro &lt;;&gt; triv)

example (x : α) (h : p) : x = x ∧ p := by</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>creates aliases for <bpt i="1" x="1">&lt;g1&gt;</bpt>succ<ept i="1">&lt;/g1&gt;</ept>, <bpt i="2" x="2">&lt;g2&gt;</bpt>add<ept i="2">&lt;/g2&gt;</ept>, and <bpt i="3" x="3">&lt;g3&gt;</bpt>sub<ept i="3">&lt;/g3&gt;</ept> in the current
namespace, so that whenever the namespace is open, these aliases are
available.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181545Z" creationid="tlqk3" creationdate="20220525T181545Z">
        <seg>이 이름공간이 열리기만 하면 별명을 이용할 수 있도록 현재 이름공간에 <bpt i="1" x="1">&lt;g1&gt;</bpt>succ<ept i="1">&lt;/g1&gt;</ept>과 <bpt i="2" x="2">&lt;g2&gt;</bpt>add<ept i="2">&lt;/g2&gt;</ept>과 <bpt i="3" x="3">&lt;g3&gt;</bpt>sub<ept i="3">&lt;/g3&gt;</ept>에 대한 별명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>creates aliases for everything in the <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> namespace <bpt i="2" x="2">&lt;g2&gt;</bpt>except<ept i="2">&lt;/g2&gt;</ept> the identifiers listed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181149Z" creationid="tlqk3" creationdate="20220525T181149Z">
        <seg>나열된 식별자를 <bpt i="2" x="2">&lt;g2&gt;</bpt>제외한<ept i="2">&lt;/g2&gt;</ept> <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat<ept i="1">&lt;/g1&gt;</ept> 이름공간 속 모든 것에 대한 별명을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>creates aliases for only the identifiers listed.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181029Z" creationid="tlqk3" creationdate="20220525T181029Z">
        <seg>나열된 식별자들만을 위한 별명을 만드세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>creates aliases renaming <bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.mul<ept i="1">&lt;/g1&gt;</ept> to <bpt i="2" x="2">&lt;g2&gt;</bpt>times<ept i="2">&lt;/g2&gt;</ept> and <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.add<ept i="3">&lt;/g3&gt;</ept> to <bpt i="4" x="4">&lt;g4&gt;</bpt>plus<ept i="4">&lt;/g4&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220525T181256Z" creationid="tlqk3" creationdate="20220525T181256Z">
        <seg><bpt i="1" x="1">&lt;g1&gt;</bpt>Nat.mul<ept i="1">&lt;/g1&gt;</ept>을 <bpt i="2" x="2">&lt;g2&gt;</bpt>times<ept i="2">&lt;/g2&gt;</ept> 으로 그리고 <bpt i="3" x="3">&lt;g3&gt;</bpt>Nat.add<ept i="3">&lt;/g3&gt;</ept>을 <bpt i="4" x="4">&lt;g4&gt;</bpt>plus<ept i="4">&lt;/g4&gt;</ept>로 다시 이름지어 별명을 만드세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>error: tactic 'rewrite' failed, did not find instance of the pattern</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183115Z" creationid="tlqk3" creationdate="20220604T183115Z">
        <seg>오류: '다시 쓰기' 전술이 실패했습니다. 패턴의 개체를 찾지 못했습니다.(error: tactic 'rewrite' failed, did not find instance of the pattern)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>fun x =&gt; id1 x

-- In this example, implicit lambda introduction has been disabled
-- because we used the binder annotation `{...}`
def id5 : {α : Type} → α → α :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T135905Z" creationid="tlqk3" creationdate="20220526T135905Z">
        <seg>fun x =&gt; id1 x

-- 이 예제에서 암시적인 람다의 도입은 결합 주석 `{...}`을
-- 사용했기 때문에 해제되었습니다. 
def id5 : {α : Type} → α → α :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>imports the file <bpt i="1" x="1">&lt;g1&gt;</bpt>Bar/Baz/Blah.olean<ept i="1">&lt;/g1&gt;</ept>, where the descriptions are
interpreted relative to the Lean <bpt i="2" x="2">&lt;g2&gt;</bpt>search path<ept i="2">&lt;/g2&gt;</ept>.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T174156Z" creationid="tlqk35" creationdate="20220524T174156Z">
        <seg>린의 파일 <bpt i="2" x="2">&lt;g2&gt;</bpt>search path<ept i="2">&lt;/g2&gt;</ept>에 상대적인 주소로 설명된 곳에서 <bpt i="1" x="1">&lt;g1&gt;</bpt>Bar/Baz/Blah.olean<ept i="1">&lt;/g1&gt;</ept>을 불러옵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>in the target expression</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183124Z" creationid="tlqk3" creationdate="20220604T183124Z">
        <seg>대상 표현식에서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>is treated as a macro, and expands to</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T180127Z" creationid="tlqk35" creationdate="20220524T180054Z">
        <seg>은 매크로로 간주되고 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>mdbook watch --open  # opens the output in `out/` in your default browser</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T172153Z" creationid="tlqk35" creationdate="20220321T172153Z">
        <seg>mdbook watch을 열고 # 여러분의 기본 브라우저에서 `out/`에서 출력을 여세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>mutually recursive definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170453Z" creationid="tlqk3" creationdate="20220529T170448Z">
        <seg>상호적으로 재귀적인 정의</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>nested_and_mutual_recursion:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T173315Z" creationid="tlqk3" creationdate="20220603T173315Z">
        <seg>중접되고 상호적인 재귀</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>notation "‹" p "›" =&gt; show p by assumption</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T183620Z" creationid="tlqk35" creationdate="20220321T183620Z">
        <seg>기호 "‹" p "›" =&gt; 은 가정에 의해 p가 참임을 보입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>open Classical

-- distributivity
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170530Z" creationid="tlqk35" creationdate="20220321T170530Z">
        <seg>open Classical

-- 분배성
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>or just</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183402Z" creationid="tlqk3" creationdate="20220604T183402Z">
        <seg>아니면 그냥</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- an example that requires classical reasoning
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170550Z" creationid="tlqk35" creationdate="20220321T170550Z">
        <seg>show p ∧ (q ∨ r) from ⟨hp, Or.inr hr⟩))

-- 고전 추론을 필요로 하는 예제
example (p q : Prop) : ¬(p ∧ ¬q) → (p → q) :=</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>structurally recursive definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170432Z" creationid="tlqk3" creationdate="20220529T170432Z">
        <seg>구조적으로 재귀적인 정의</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>triv

-- You cannot prove the following theorem using `triv`
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220524T170842Z" creationid="tlqk35" creationdate="20220524T170842Z">
        <seg>triv

-- 여러분은 `triv` 사용해 다음 정리를 증명할 수 없습니다.
-- example (x : α) : x = x := by
--  triv

-- Let's extend `triv`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>variable (p q r : Prop)

-- commutativity of ∧ and ∨
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- associativity of ∧ and ∨
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- distributivity
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- other properties
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk35" changedate="20220321T170650Z" creationid="tlqk35" creationdate="20220321T170650Z">
        <seg>variable (p q r : Prop)

-- ∧과 ∨의 교환성
example : p ∧ q ↔ q ∧ p := sorry
example : p ∨ q ↔ q ∨ p := sorry

-- ∧과 ∨의 결합성
example : (p ∧ q) ∧ r ↔ p ∧ (q ∧ r) := sorry
example : (p ∨ q) ∨ r ↔ p ∨ (q ∨ r) := sorry

-- 분배성
example : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := sorry
example : p ∨ (q ∧ r) ↔ (p ∨ q) ∧ (p ∨ r) := sorry

-- 다른 성질들
example : (p → (q → r)) ↔ (p ∧ q → r) := sorry
example : ((p ∨ q) → r) ↔ (p → r) ∧ (q → r) := sorry
example : ¬(p ∨ q) ↔ ¬p ∧ ¬q := sorry
example : ¬p ∨ ¬q → ¬(p ∧ q) := sorry
example : ¬(p ∧ ¬p) := sorry
example : p ∧ ¬q → ¬(p → q) := sorry
example : ¬p → (p → q) := sorry
example : (¬p ∨ q) → (p → q) := sorry
example : p ∨ False ↔ p := sorry
example : p ∧ False ↔ False := sorry
example : (p → q) → (¬q → ¬p) := sorry</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>well-founded recursive definitions</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220529T170451Z" creationid="tlqk3" creationdate="20220529T170438Z">
        <seg>잘 세워진 재귀적 정의</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>where <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept> is a sequence of data type parameters, <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept> is the
sequence of arguments to the constructors, and <bpt i="3" x="3">&lt;g3&gt;</bpt>p[a, b]<ept i="3">&lt;/g3&gt;</ept> are the
indices, which determine which element of the inductive family the
construction inhabits.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T152521Z" creationid="tlqk35" creationdate="20220528T161227Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>a<ept i="1">&lt;/g1&gt;</ept>는 데이터 유형 매개변수의 나열이고 <bpt i="2" x="2">&lt;g2&gt;</bpt>b<ept i="2">&lt;/g2&gt;</ept>는 생성자에 대한 인수의 나열이고 <bpt i="3" x="3">&lt;g3&gt;</bpt>p[a, b]<ept i="3">&lt;/g3&gt;</ept> 는 귀납군의 어떤 원소가 생성자를 어디에 머무르게 할지 결정하는  색인입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>where <bpt i="1" x="1">&lt;g1&gt;</bpt>intro x<ept i="1">&lt;/g1&gt;</ept> is the navigation command entering inside the <bpt i="2" x="2">&lt;g2&gt;</bpt>fun<ept i="2">&lt;/g2&gt;</ept> binder.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183317Z" creationid="tlqk3" creationdate="20220604T183317Z">
        <seg>여기서 <bpt i="1" x="1">&lt;g1&gt;</bpt>intro x<ept i="1">&lt;/g1&gt;</ept>는 <bpt i="2" x="2">&lt;g2&gt;</bpt>fun<ept i="2">&lt;/g2&gt;</ept> 결합자 내부로 들어가는 탐색 명령입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>where the precedences do not sufficiently determine associativity,
Lean's parser will default to right associativity.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220526T123304Z" creationid="tlqk3" creationdate="20220526T123304Z">
        <seg>여기서 우선순위는 결합성을 결정하기에 충분하지 않아서  린의 구문분석기는 오른쪽 결합성으로 기본설정을 할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>where the square brackets indicate that the argument of type <bpt i="1" x="1">&lt;g1&gt;</bpt>Add a<ept i="1">&lt;/g1&gt;</ept> is <bpt i="2" x="2">&lt;g2&gt;</bpt>instance implicit<ept i="2">&lt;/g2&gt;</ept>,
i.e. that it should be synthesized using typeclass resolution.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T154241Z" creationid="tlqk3" creationdate="20220604T154241Z">
        <seg>여기서 대괄호는 <bpt i="1" x="1">&lt;g1&gt;</bpt>Add a<ept i="1">&lt;/g1&gt;</ept>의 유형이 <bpt i="2" x="2">&lt;g2&gt;</bpt>instance implicit<ept i="2">&lt;/g2&gt;</ept>임을 가리킵니다. 즉, 이것은 유형클래스 해결책을 사용해 합성되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>which is just syntax sugar for</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220604T183711Z" creationid="tlqk3" creationdate="20220604T183711Z">
        <seg>이것은 다음에 대한 문법적 설탕입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>you find the following:</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220527T155255Z" creationid="tlqk3" creationdate="20220527T155255Z">
        <seg>여러분은 다음을 발견합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv xml:lang="en-US">
        <seg>| _ =&gt; 0

-- Try it out.</seg>
      </tuv>
      <tuv xml:lang="ko" changeid="tlqk3" changedate="20220603T180555Z" creationid="tlqk3" creationdate="20220603T180555Z">
        <seg>| _ =&gt; 0

-- 시도해 보세요.</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
