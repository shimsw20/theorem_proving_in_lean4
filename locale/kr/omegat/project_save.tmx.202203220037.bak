<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="OmegaT-4.3.2" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="en-US">
        <seg>"Type theory" gets its name from the fact that every expression has an
associated &lt;g1&gt;type&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135220Z" creationid="tlqk35" creationdate="20220321T135220Z">
        <seg>'유형론'은 그것의 이름을 모든 표현은 연관된 &lt;g1&gt;유형&lt;/g1&gt;을 가지고 있다는 사실로부터 갖게 되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>#check Nat → Nat      -- type the arrow as "\to" or "\r"
#check Nat -&gt; Nat     -- alternative ASCII notation

#check Nat × Nat      -- type the product as "\times"
#check Prod Nat Nat   -- alternative notation

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  --  same type as above

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- a "functional"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140252Z" creationid="tlqk35" creationdate="20220321T140252Z">
        <seg>#check Nat → Nat      --화살표를 쓰기 위해서 "\to"나 "\r"를 치세요.
#check Nat -&gt; Nat     -- ASCII 표기의 대체표현입니다.

#check Nat × Nat      -- 곱하기를 쓰기 위해 "\times"를 치세요.
#check Prod Nat Nat   -- 대체 표현입니다.

#check Nat → Nat → Nat
#check Nat → (Nat → Nat)  -- 위와 같은 유형입니다.

#check Nat × Nat → Nat
#check (Nat → Nat) → Nat -- "범함수"

#check Nat.succ     -- Nat → Nat
#check (0, 1)       -- Nat × Nat
#check Nat.add      -- Nat → Nat → Nat

#check Nat.succ 2   -- Nat
#check Nat.add 3    -- Nat → Nat
#check Nat.add 5 2  -- Nat
#check (5, 9).1     -- Nat
#check (5, 9).2     -- Nat

#eval Nat.succ 2   -- 3
#eval Nat.add 5 2  -- 7
#eval (5, 9).1     -- 5
#eval (5, 9).2     -- 9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     -- λ and fun mean the same thing
#check fun x : Nat =&gt; x + 5     -- Nat inferred
#check λ x : Nat =&gt; x + 5       -- Nat inferred</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142214Z" creationid="tlqk35" creationdate="20220321T142214Z">
        <seg>#check fun (x : Nat) =&gt; x + 5   -- Nat → Nat
#check λ (x : Nat) =&gt; x + 5     --  λ 와 fun 같은 의미를 가집니다.
#check fun x : Nat =&gt; x + 5     --  Nat으로 추론됩니다.
#check λ x : Nat =&gt; x + 5       --  Nat으로 추론됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>(Making sense of the type of this function requires an understanding
of dependent products, which will be explained below.)</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143305Z" creationid="tlqk35" creationdate="20220321T143305Z">
        <seg>(이 함수의 유형들을 이해하는 것은 아래에서 설명할 의존 곱에 대한 이해가 필요합니다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;" is the Boolean and
#check b1 || b2     -- Boolean or
#check true         -- Boolean "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135459Z" creationid="tlqk35" creationdate="20220321T135459Z">
        <seg>-/

#check m            -- output: Nat
#check n
#check n + 0        -- Nat
#check m * (n + 0)  -- Nat
#check b1           -- Bool
#check b1 &amp;&amp; b2     -- "&amp;&amp;"은 불리언 and
#check b1 || b2     -- 불리언 or
#check true         -- 불리언 "true"

/- Evaluate -/

#eval 5 * 4         -- 20
#eval m + 2         -- 3
#eval b1 &amp;&amp; b2      -- false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>-/

def m : Nat := 1       -- m is a natural number
def n : Nat := 0
def b1 : Bool := true  -- b1 is a Boolean
def b2 : Bool := false

/- Check their types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135403Z" creationid="tlqk35" creationdate="20220321T135342Z">
        <seg>-/

def m : Nat := 1       -- m은 자연수입니다.
def n : Nat := 0
def b1 : Bool := true  -- b1은 불리언입니다.
def b2 : Bool := false

/- 그들의 유형을 확인합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>/- Define some constants.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135320Z" creationid="tlqk35" creationdate="20220321T135320Z">
        <seg>/-  몇 가지 상수를 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g1&gt;Automated theorem proving&lt;/g1&gt; focuses on the "finding" aspect.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131300Z" creationid="tlqk35" creationdate="20220321T131300Z">
        <seg>&lt;g1&gt;자동화된 정리 증명&lt;/g1&gt;은 '찾기'에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g1&gt;Formal verification&lt;/g1&gt; involves the use of logical and computational methods to establish claims that are expressed in
precise mathematical terms.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131125Z" creationid="tlqk35" creationdate="20220321T131125Z">
        <seg>&lt;g1&gt;형식 증명&lt;/g1&gt;은 정밀한 수학적 항들로 표현된 주장을 세우는데 논리적이고 계산과학적 방법의 사용을 수반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g1&gt;compose&lt;/g1&gt; also takes a 3rd argument of type &lt;g2&gt;α&lt;/g2&gt; which
it uses to invoke the second function (locally named &lt;g3&gt;f&lt;/g3&gt;) and it
passes the result of that function (which is type &lt;g4&gt;β&lt;/g4&gt;) as input to the
first function (locally named &lt;g5&gt;g&lt;/g5&gt;).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144548Z" creationid="tlqk35" creationdate="20220321T144548Z">
        <seg>&lt;g1&gt;compose&lt;/g1&gt;는 이는 두 번째 함수(지역적으로 &lt;g3&gt;f&lt;/g3&gt;라 하는)을 호출하는데 사용되기도 하는 유형 &lt;g2&gt;α&lt;/g2&gt; 를 세 번째 인수로 받습니다. 그리고 두 번째 합수는 그 함수의 결과(유형 &lt;g4&gt;β&lt;/g4&gt;의)를 첫 번째 함수(지역적으로 &lt;g5&gt;g&lt;/g5&gt;라 하는)의 입력으로 전달합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g1&gt;compose&lt;/g1&gt; is also very general in that it works over any type
&lt;g2&gt;α β γ&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144628Z" creationid="tlqk35" creationdate="20220321T144628Z">
        <seg>&lt;g1&gt;compose&lt;/g1&gt;는 또 아주 일반적이어서 임의의 유형 &lt;g2&gt;α β γ&lt;/g2&gt;에 대해서도 작동합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g1&gt;def&lt;/g1&gt; can take multiple input parameters.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144242Z" creationid="tlqk35" creationdate="20220321T144242Z">
        <seg>&lt;g1&gt;def&lt;/g1&gt;는 다수의 입력 매개변수를 받을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g2&gt;Type 1&lt;/g2&gt; is then a larger universe of types, which contains &lt;g3&gt;Type
0&lt;/g3&gt; as an element, and &lt;g4&gt;Type 2&lt;/g4&gt; is an even larger universe of types,
which contains &lt;g5&gt;Type 1&lt;/g5&gt; as an element.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141659Z" creationid="tlqk35" creationdate="20220321T141659Z">
        <seg>&lt;g2&gt;Type 1&lt;/g2&gt;는  &lt;g3&gt;Type 0&lt;/g3&gt;를 원소로 갖는 유형들의 더 큰 세계이고 &lt;g4&gt;Type 2&lt;/g4&gt;는 &lt;g5&gt;Type 1&lt;/g5&gt;을 원소로 하는 유형들의 더욱 큰 세계입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&lt;g8&gt;Type&lt;/g8&gt; is
an abbreviation for &lt;g9&gt;Type 0&lt;/g9&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141748Z" creationid="tlqk35" creationdate="20220321T141748Z">
        <seg>&lt;g8&gt;Type&lt;/g8&gt;는 &lt;g9&gt;Type 0&lt;/g9&gt;에 대한 약식 표현입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A calculation can be viewed as a proof as well, and these systems,
too, help establish mathematical claims.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131354Z" creationid="tlqk35" creationdate="20220321T131354Z">
        <seg>계산도 증명의 관점으로 볼 수 있으며 이런 시스템들도 수학적 진술을 세우는데 도움을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A first guess might be
&lt;g4&gt;Type → α → list α → list α&lt;/g4&gt;, but, on reflection, this does not make
sense: the &lt;g5&gt;α&lt;/g5&gt; in this expression does not refer to anything,
whereas it should refer to the argument of type &lt;g6&gt;Type&lt;/g6&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151344Z" creationid="tlqk35" creationdate="20220321T151344Z">
        <seg>첫 번째 추측은 &lt;g4&gt;Type → α → list α → list α&lt;/g4&gt;일지 모릅니다. 그러나 생각해보면 이는 말이 되지 않습니다. 이 식에서 &lt;g5&gt;α&lt;/g5&gt;는 어떤 것도 지칭하지 않으므로 &lt;g6&gt;Type&lt;/g6&gt; 유형을 인수로 지칭해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About Lean</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131709Z" creationid="tlqk35" creationdate="20220321T131709Z">
        <seg>린에 대해서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>About this Book</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131959Z" creationid="tlqk35" creationdate="20220321T131959Z">
        <seg>이 책에 대하여</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Acknowledgments</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135000Z" creationid="tlqk35" creationdate="20220321T135000Z">
        <seg>감사의 말</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All that has changed are the braces around &lt;g1&gt;α : Type u&lt;/g1&gt; in the
declaration of the variables.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153209Z" creationid="tlqk35" creationdate="20220321T153209Z">
        <seg>바뀐 것이라곤 변수 선언에서 &lt;g1&gt;α : Type u&lt;/g1&gt; 주위의 괄호뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An expression like &lt;g2&gt;id&lt;/g2&gt; or &lt;g3&gt;List.nil&lt;/g3&gt; is
said to be &lt;g4&gt;polymorphic&lt;/g4&gt;, because it can take on different meanings in
different contexts.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153452Z" creationid="tlqk35" creationdate="20220321T153452Z">
        <seg>다른 맥락에서 다른 의미를 가질 수 있기 때문에 &lt;g2&gt;id&lt;/g2&gt; 나 &lt;g3&gt;List.nil&lt;/g3&gt; 같은 표현식을 &lt;g4&gt;다형적&lt;/g4&gt;이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And, indeed, it does:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143641Z" creationid="tlqk35" creationdate="20220321T143641Z">
        <seg>그리고 당연히 그럽니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any text between &lt;g1&gt;/-&lt;/g1&gt; and &lt;g2&gt;-/&lt;/g2&gt; constitutes a comment block that is
ignored by Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135531Z" creationid="tlqk35" creationdate="20220321T135531Z">
        <seg> &lt;g1&gt;/-&lt;/g1&gt;과 &lt;g2&gt;-/&lt;/g2&gt; 사이의 모든 글은 린에게 무시하라고 가리키는 주석을 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Architectures like SMT ("satisfiability
modulo theories") combine domain-general search methods with domain-specific procedures.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131338Z" creationid="tlqk35" creationdate="20220321T131338Z">
        <seg>SMT(Satisfiability Modulo Theories)같은 구조는 영역-일반 탐색법을 영역-특정 절차와 결합했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As an exercise, try to understand
why the definition of &lt;g12&gt;foo&lt;/g12&gt; below type checks, but the definition of
&lt;g13&gt;bar&lt;/g13&gt; does not.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145104Z" creationid="tlqk35" creationdate="20220321T145104Z">
        <seg>연습으로 아래 유형 확인에서 &lt;g12&gt;foo&lt;/g12&gt;의 정의가 왜 그런지 그러나  &lt;g13&gt;bar&lt;/g13&gt;의 정의는 그렇지 않은지 이해하려고 해 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, the expression &lt;g1&gt;(fun x : Nat =&gt;  x) 1&lt;/g1&gt; has type &lt;g2&gt;Nat&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143602Z" creationid="tlqk35" creationdate="20220321T143602Z">
        <seg>예상했다시피 표현식&lt;g1&gt;(fun x : Nat =&gt; x) 1&lt;/g1&gt; 은 &lt;g2&gt;Nat&lt;/g2&gt; 유형을 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As the example above suggests, you have already seen an example of a function of type
&lt;g1&gt;Type → Type → Type&lt;/g1&gt;, namely, the Cartesian product &lt;g2&gt;Prod&lt;/g2&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141444Z" creationid="tlqk35" creationdate="20220321T141444Z">
        <seg>위 예에서 제안한 것처럼 여러분은 이미 주로 카테시안 곱 &lt;g2&gt;Prod&lt;/g2&gt;에서 &lt;g1&gt;Type → Type → Type&lt;/g1&gt; 유형의 함수의 예를 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Automated reasoning systems strive for power and efficiency, often at the expense of guaranteed soundness.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131401Z" creationid="tlqk35" creationdate="20220321T131401Z">
        <seg>자동화된 추론 시스템은 종종 건전성 보장을 희생해서라도 성능과 효율성을 끌어올리기 위해 애쓰고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because fully detailed axiomatic proofs are so complicated, the challenge of theorem proving is to have the computer
fill in as many of the details as possible.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132211Z" creationid="tlqk35" creationdate="20220321T132211Z">
        <seg>완전히 상세한 공리적 증명은 너무 복잡하기 때문에, 증명 보조기의 문제점은 컴퓨터에 가능한 많이 상세한 것들을 두어야 한다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the constructors are polymorphic over types, we have to insert
the type &lt;g1&gt;Nat&lt;/g1&gt; as an argument repeatedly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152448Z" creationid="tlqk35" creationdate="20220321T152448Z">
        <seg>생성자들이 유형에 대해 다형적이기 때문에, 우리는 유형 &lt;g1&gt;Nat&lt;/g1&gt;를 인수로써 반복적으로 삽입해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Both expressions denote the type of
functions that take a natural number as input and return a natural
number as output.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140507Z" creationid="tlqk35" creationdate="20220321T140507Z">
        <seg>두 표현식 모두 자연수를 입력으로 받아 자연수를 출력으로 반환하는 함수 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But sometimes you will want to leave this information
protected by a fully qualified name, for example, when they conflict
with identifiers in another namespace you want to use.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150453Z" creationid="tlqk35" creationdate="20220321T150453Z">
        <seg>그러나 때로는 당신이 사용할 다른 이름공간과 식별자가 충돌할 때 여러분이 이 정보가 완전히 자격을 갖춘 이름으로 보호되길 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But this information is
redundant: one can infer the argument &lt;g2&gt;α&lt;/g2&gt; in
&lt;g3&gt;Lst.cons Nat 5 (Lst.nil Nat)&lt;/g3&gt; from the fact that the second argument, &lt;g4&gt;5&lt;/g4&gt;, has
type &lt;g5&gt;Nat&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152522Z" creationid="tlqk35" creationdate="20220321T152522Z">
        <seg>그러나 이 정보는 중복적입니다. &lt;g3&gt;Lst.cons Nat 5 (Lst.nil Nat)&lt;/g3&gt;에서 두번째 인수 &lt;g4&gt;5&lt;/g4&gt;가 &lt;g5&gt;Nat&lt;/g5&gt; 유형을 가진다는 사실로부터 인수 &lt;g2&gt;α&lt;/g2&gt;를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what type should &lt;g3&gt;cons&lt;/g3&gt; have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151314Z" creationid="tlqk35" creationdate="20220321T151314Z">
        <seg>그러나  &lt;g3&gt;cons&lt;/g3&gt;는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By the end
of this chapter, you will understand much of what this means.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135143Z" creationid="tlqk35" creationdate="20220321T135143Z">
        <seg>2장의 끝에서 여러분은 이것의 의미하는 바의 대부분을 이해하게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Comment blocks can
be nested, making it possible to "comment out" chunks of code, just as
in many programming languages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135553Z" creationid="tlqk35" creationdate="20220321T135553Z">
        <seg>주석 블록은 중첩될 수 있으며 대부분의 프로그래밍 언어처럼 코드 조각을 "주석 처리"할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computer algebra systems and
specialized mathematical software packages provide means of carrying out mathematical computations, establishing
mathematical bounds, or finding mathematical objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131347Z" creationid="tlqk35" creationdate="20220321T131347Z">
        <seg>컴퓨터 대수 시스템(CAS, Computer Algebra Systems)과 특정 수학 소프트웨어 패키지는 수학 계산을 수행하고 수학적 한계를 세우며, 수학적 대상을 찾는 수단을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Computers and Theorem Proving</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131055Z" creationid="tlqk35" creationdate="20220321T131055Z">
        <seg>컴퓨터와 정리 증명</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Consider the following three function definitions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145126Z" creationid="tlqk35" creationdate="20220321T145126Z">
        <seg>다음 세 함수 정의를 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Constructing such proofs typically requires much more input and interaction from users, but it
allows you to obtain deeper and more complex proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131511Z" creationid="tlqk35" creationdate="20220321T131511Z">
        <seg>전형적으로 이런 증명을 작성하는 것은 사용자에게 훨씬 많은 입력과 상호작용을 요구합니다. 그러나 이것은 우리가 더 깊고 복잡한 증명을 얻을 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, if you have &lt;g7&gt;p : Nat × Nat&lt;/g7&gt;, then you can write
&lt;g8&gt;p.1 : Nat&lt;/g8&gt; and &lt;g9&gt;p.2 : Nat&lt;/g9&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141208Z" creationid="tlqk35" creationdate="20220321T141208Z">
        <seg>반대로 여러분이 &lt;g7&gt;p : Nat × Nat&lt;/g7&gt;을 갖고 있다면 &lt;g8&gt;p.1 : Nat&lt;/g8&gt;과 &lt;g9&gt;p.2 : Nat&lt;/g9&gt;처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Conversely, the proof of a mathematical theorem may require a
lengthy computation, in which case verifying the truth of the theorem requires verifying that the computation does what
it is supposed to do.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131219Z" creationid="tlqk35" creationdate="20220321T131219Z">
        <seg>반대로 수학적 정리의 증명은 긴 계산이 필요하는데 이 경우 정리의 참을 증명하는 건 계산한 것을 증명하는 걸 필요로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Creating a function from another expression is a process known as
&lt;g1&gt;lambda abstraction&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142243Z" creationid="tlqk35" creationdate="20220321T142243Z">
        <seg>다른 표현식으로부터 함수를 만드는 것은 &lt;g1&gt;람다 추상화(lambda abstraction)&lt;/g1&gt;과정으로 알려져 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Declaring new objects in this manner is a good way to experiment
with the system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135914Z" creationid="tlqk35" creationdate="20220321T135914Z">
        <seg>이처럼 새로운 대상을 선언하는 것은 시스템을 실험해보는 좋은 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Definitions</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143811Z" creationid="tlqk35" creationdate="20220321T143811Z">
        <seg>정의(Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent Type Theory</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135104Z" creationid="tlqk35" creationdate="20220321T135104Z">
        <seg>의존 유형론</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent products
are also called &lt;g7&gt;sigma&lt;/g7&gt; types, and you can also write them as
&lt;g8&gt;Σ a : α, β a&lt;/g8&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152302Z" creationid="tlqk35" creationdate="20220321T152302Z">
        <seg>의존적 곱은 &lt;g7&gt;sigma&lt;/g7&gt;유형이라고 불립니다. 그리고 여러분은 그것을 &lt;g8&gt;Σ a : α, β a&lt;/g8&gt;처럼 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Dependent type theory is a powerful and expressive language, allowing
you to express complex mathematical assertions, write complex hardware
and software specifications, and reason about both of these in a
natural and uniform way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135117Z" creationid="tlqk35" creationdate="20220321T135117Z">
        <seg>의존 유형론은 여러분이 복잡한 수학적 진술을 표현할 수 있게 하고, 복잡한 하드웨어와 소프트웨어 명제를 작성할 수 있게 하며 이 둘에 대해 자연스럽고 일관성있게 추론할 수 있게 하는 강력하고 표현력 있는 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Finally, you will learn about features that are specific to Lean, including the language you use to communicate
with the system, and the mechanisms Lean offers for managing complex theories and data.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134710Z" creationid="tlqk35" creationdate="20220321T134710Z">
        <seg>마지막으로 린에 여러분이 시스템과 소통하기 위해 사용하는 언어와 복잡한 이론과 자료를 관리하기 위해 린이 제공하는 메커니즘을 포함하는 구체적인 특징에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, the application of
a function &lt;g1&gt;f&lt;/g1&gt; to a value &lt;g2&gt;x&lt;/g2&gt; is denoted &lt;g3&gt;f x&lt;/g3&gt; (e.g., &lt;g4&gt;Nat.succ 2&lt;/g4&gt;).</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140728Z" creationid="tlqk35" creationdate="20220321T140728Z">
        <seg>우선 함수 &lt;g1&gt;f&lt;/g1&gt;에 값 &lt;g2&gt;x&lt;/g2&gt;의 활용은 &lt;g3&gt;f x&lt;/g3&gt; 를 지칭합니다. (예를 들어 &lt;g4&gt;Nat.succ 2&lt;/g4&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For
example, the variable &lt;g4&gt;b&lt;/g4&gt; in the expression &lt;g5&gt;fun (b : β) (x : α) =&gt; b&lt;/g5&gt;
has nothing to do with the constant &lt;g6&gt;b&lt;/g6&gt; declared earlier.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143414Z" creationid="tlqk35" creationdate="20220321T143414Z">
        <seg>예를 들어 표현식 &lt;g5&gt;fun (b : β) (x : α) =&gt; b&lt;/g5&gt; 속 변수 &lt;g4&gt;b&lt;/g4&gt;는 앞서 선언된 상수 &lt;g6&gt;b&lt;/g6&gt;와는 아무런 연관이 없습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For another example, consider the
type &lt;g5&gt;Vector α n&lt;/g5&gt;, the type of vectors of elements of &lt;g6&gt;α&lt;/g6&gt; of
length &lt;g7&gt;n&lt;/g7&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150928Z" creationid="tlqk35" creationdate="20220321T150928Z">
        <seg>또 다른 예시로 유형 &lt;g5&gt;Vector α n&lt;/g5&gt;을 고려해보세요. 이 벡터의 유형은 길이 &lt;g7&gt;n&lt;/g7&gt;인 &lt;g6&gt;α&lt;/g6&gt;를 원소로 하는 리스트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, &lt;g2&gt;List α&lt;/g2&gt; should make sense for any type
&lt;g3&gt;α&lt;/g3&gt;, no matter which type universe &lt;g4&gt;α&lt;/g4&gt; lives in.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141914Z" creationid="tlqk35" creationdate="20220321T141914Z">
        <seg>예를 들어 &lt;g3&gt;α&lt;/g3&gt;가 어떤 유형 세계에 있던간에 &lt;g2&gt;List α&lt;/g2&gt;는 임의의 유형 &lt;g4&gt;α&lt;/g4&gt;에 대해 의미가 있어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, Lean groups definitions and theorems involving lists into
a namespace &lt;g1&gt;List&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150513Z" creationid="tlqk35" creationdate="20220321T150513Z">
        <seg>예를 들어 Lean은 이름공간 &lt;g1&gt;List&lt;/g1&gt; 속에 리스트를 포함한 정의와 정리를 묶습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, if &lt;g1&gt;a&lt;/g1&gt; and &lt;g2&gt;b&lt;/g2&gt; are types, &lt;g3&gt;a -&gt; b&lt;/g3&gt;
denotes the type of functions from &lt;g4&gt;a&lt;/g4&gt; to &lt;g5&gt;b&lt;/g5&gt;, and &lt;g6&gt;a × b&lt;/g6&gt;
denotes the type of pairs consisting of an element of &lt;g7&gt;a&lt;/g7&gt; paired
with an element of &lt;g8&gt;b&lt;/g8&gt;, also known as the &lt;g9&gt;Cartesian product&lt;/g9&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140041Z" creationid="tlqk35" creationdate="20220321T140041Z">
        <seg>예를 들어 &lt;g1&gt;a&lt;/g1&gt;와 &lt;g2&gt;b&lt;/g2&gt;가 유형이라면 &lt;g3&gt;a -&gt; b&lt;/g3&gt;는 &lt;g4&gt;a&lt;/g4&gt; 에서 &lt;g5&gt;b&lt;/g5&gt;로 가는 함수 유형을 나타냅니다. 그리고 &lt;g6&gt;a × b&lt;/g6&gt; 는 &lt;g7&gt;a&lt;/g7&gt;의 원소와 &lt;g8&gt;b&lt;/g8&gt;의 원소로 이뤄진 쌍을 원소로 갖는 유형을 나타냅니다. 이것을 &lt;g9&gt;카테시안 곱&lt;/g9&gt;이라 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in a given context, &lt;g2&gt;x + 0&lt;/g2&gt; may
denote a natural number and &lt;g3&gt;f&lt;/g3&gt; may denote a function on the natural
numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135242Z" creationid="tlqk35" creationdate="20220321T135242Z">
        <seg>예를들어 어떤 맥락에서 &lt;g2&gt;x + 0&lt;/g2&gt;은 자연수를 가리키고  &lt;g3&gt;f&lt;/g3&gt;은 자연수에 대한 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, it allows
you to "partially apply" the function &lt;g11&gt;Nat.add&lt;/g11&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140858Z" creationid="tlqk35" creationdate="20220321T140858Z">
        <seg>예를 들어 이는 여러분에게 함수 &lt;g11&gt;Nat.add&lt;/g11&gt;의 "부분 적용"을 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, term rewriting, and Lean's automated methods for simplifying terms and
expressions automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132252Z" creationid="tlqk35" creationdate="20220321T132252Z">
        <seg>예를 들어, 항을 다시 쓰기(rewriting)와 Lean의 자동화된 항과 식의 단순화(simplifying) 기법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144651Z" creationid="tlqk35" creationdate="20220321T144651Z">
        <seg>예를 들어</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For now, notice that
this is an important feature of dependent type theory: every term has
a computational behavior, and supports a notion of &lt;g1&gt;normalization&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143711Z" creationid="tlqk35" creationdate="20220321T143711Z">
        <seg>현재로써는 이게 의존 유형론의 중요한 특징인 것만 알아 두세요. 모든 항은 전산적 거동을 하고 &lt;g1&gt;정규화(normalization)&lt;/g1&gt;의 개념을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For that purpose, Lean provides the notion of
a &lt;g1&gt;section&lt;/g1&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150040Z" creationid="tlqk35" creationdate="20220321T150040Z">
        <seg>이를 위해 Lean은  &lt;g1&gt;section&lt;/g1&gt;의 개념을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For that to be the case, each of them also has to have a
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141327Z" creationid="tlqk35" creationdate="20220321T141327Z">
        <seg>이렇게 하는 경우에 대해 그들 각각은 유형을 가져야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For those who like precise definitions, a Lean natural number
is an arbitrary-precision unsigned integer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135255Z" creationid="tlqk35" creationdate="20220321T135255Z">
        <seg>엄밀한 정의를 좋아하는 이들에게 린의 자연수는 부호없는 임의 정밀도의 정수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Formally, expressions that are the same up to a renaming of bound
variables are called &lt;g1&gt;alpha equivalent&lt;/g1&gt;, and are considered "the
same." Lean recognizes this equivalence.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143446Z" creationid="tlqk35" creationdate="20220321T143446Z">
        <seg>공식적으로 구속 변수의 이름이 바뀌기까지 같은 표현식은 &lt;g1&gt;알파 등가(alpha equivalent)&lt;/g1&gt;라 하고 "같은" 것으로 생각합니다. 린도 이를 등가로 인식합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function Abstraction and Evaluation</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142123Z" creationid="tlqk35" creationdate="20220321T142123Z">
        <seg>함수 추상화와 함수값의 평가</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given &lt;g3&gt;α : Type&lt;/g3&gt; and &lt;g4&gt;β : α → Type&lt;/g4&gt;, think of &lt;g5&gt;β&lt;/g5&gt;
as a family of types over &lt;g6&gt;α&lt;/g6&gt;, that is, a type &lt;g7&gt;β a&lt;/g7&gt; for each
&lt;g8&gt;a : α&lt;/g8&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151703Z" creationid="tlqk35" creationdate="20220321T151703Z">
        <seg>&lt;g3&gt;α : Type&lt;/g3&gt;과&lt;g4&gt;β : α → Type&lt;/g4&gt;이라면, &lt;g5&gt;β&lt;/g5&gt;를 &lt;g6&gt;α&lt;/g6&gt;에 대한 유형 족(family)으로 생각할 수 있습니다. 즉, 각각의 &lt;g8&gt;a : α&lt;/g8&gt;에 대해 &lt;g7&gt;β a&lt;/g7&gt;유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Given that every expression in Lean has a type, it is natural to ask:
what type does &lt;g1&gt;Type&lt;/g1&gt; itself have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141547Z" creationid="tlqk35" creationdate="20220321T141547Z">
        <seg>린의 모든 표현식이 유형을 가진다면 &lt;g1&gt;Type&lt;/g1&gt; 그 자체는 어떤 유형을 가져야 하는지 궁금한게 당연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here &lt;g1&gt;u_1&lt;/g1&gt; is a variable ranging over type levels.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141951Z" creationid="tlqk35" creationdate="20220321T141951Z">
        <seg>여기서 &lt;g1&gt;u_1&lt;/g1&gt;는 어떤 유형 세계에 대한 변수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some examples of how you can declare objects in Lean and
check their types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135259Z" creationid="tlqk35" creationdate="20220321T135259Z">
        <seg>린에서 여러분이 객체를 어떻게 선언하고 그들의 유형을 확인할 수 있는지 몇 가지 예제가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some more examples</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142527Z" creationid="tlqk35" creationdate="20220321T142527Z">
        <seg>여기 추가 예제가 더 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here is another example: given any type &lt;g1&gt;α&lt;/g1&gt;, the type &lt;g2&gt;List α&lt;/g2&gt;
denotes the type of lists of elements of type &lt;g3&gt;α&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141520Z" creationid="tlqk35" creationdate="20220321T141520Z">
        <seg>또 다른 예제가 있습니다. &lt;g1&gt;α&lt;/g1&gt;라 하는 임의의 타입에 대해 &lt;g2&gt;List α&lt;/g2&gt;의 유형은 &lt;g3&gt;α&lt;/g3&gt; 유형을 원소로 하는 리스트 유형을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here, &lt;g1&gt;twice_double x&lt;/g1&gt; is definitionally equal to the term &lt;g2&gt;(x + x) * (x + x)&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144822Z" creationid="tlqk35" creationdate="20220321T144822Z">
        <seg>여기서&lt;g1&gt;twice_double x&lt;/g1&gt;도 항  &lt;g2&gt;(x + x) * (x + x)&lt;/g2&gt;과 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If &lt;g1&gt;foo&lt;/g1&gt; is such a function, the
notation &lt;g2&gt;@foo&lt;/g2&gt; denotes the same function with all the arguments
made explicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153735Z" creationid="tlqk35" creationdate="20220321T153735Z">
        <seg>만약 &lt;g1&gt;foo&lt;/g1&gt;가 그런 함수라면 &lt;g2&gt;@foo&lt;/g2&gt; 표기는 모든 인수가 명시적으로 된 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you are reading the book online, you will see a button that reads "try it!" Pressing the button opens up a tab with a
Lean editor, and copies the example with enough surrounding context to make the code compile correctly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134929Z" creationid="tlqk35" creationdate="20220321T134929Z">
        <seg>여러분이 온라인으로 책을 읽는다면 "실행해보기"라 적힌 버튼을 볼 것입니다. 버튼을 누르면 린 편집기 탭이 열리면서 코드가 올바르게 컴파일되도록 주변 맥락을 포함해 예제를 복사합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you do name a section, however, you
have to close it using the same name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150146Z" creationid="tlqk35" creationdate="20220321T150146Z">
        <seg>그러나 여러분이 섹션에 이름을 붙이고자 한다면 같은 이름을 사용해 이를 닫아야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Implicit Arguments</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152413Z" creationid="tlqk35" creationdate="20220321T152413Z">
        <seg>암시적 인자(Implicit Arguments)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In
principle, two terms that reduce to the same value are called
&lt;g2&gt;definitionally equal&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143728Z" creationid="tlqk35" creationdate="20220321T143723Z">
        <seg>원리적으로 같은 값으로 축약되는 두 항은 &lt;g2&gt;정의상으로 동등(definitionally equal)&lt;/g2&gt;하다고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Lean, one uses an underscore, &lt;g1&gt;_&lt;/g1&gt;, to specify
that the system should fill in the information automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152757Z" creationid="tlqk35" creationdate="20220321T152757Z">
        <seg>Lean에서 누군가는 시스템이 자동적으로 정보를 채워넣도록 명시하기 위해 밑줄문자(&lt;g1&gt;_&lt;/g1&gt;)를 사용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In contrast, &lt;g1&gt;interactive
theorem proving&lt;/g1&gt; focuses on the "verification" aspect of theorem proving, requiring that every claim is supported by a
proof in a suitable axiomatic foundation.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131435Z" creationid="tlqk35" creationdate="20220321T131435Z">
        <seg>반대로 &lt;g1&gt;상호작용 증명기&lt;/g1&gt;는 모든 진술은 적절한 공리적 기초에 의한 증명으로 지지될 것을 요구하면서 정리 증명의 "식별" 측면에 초점을 둡니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact,
the expression denotes the same function as &lt;g7&gt;fun (u : β) (z : α) =&gt; u&lt;/g7&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143430Z" creationid="tlqk35" creationdate="20220321T143430Z">
        <seg>사실 표현식은  &lt;g7&gt;fun (u : β) (z : α) =&gt; u&lt;/g7&gt;처럼 같은 함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, more should be true: applying the expression &lt;g3&gt;(fun x : Nat
=&gt; x)&lt;/g3&gt; to &lt;g4&gt;1&lt;/g4&gt; should "return" the value &lt;g5&gt;1&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143634Z" creationid="tlqk35" creationdate="20220321T143634Z">
        <seg>사실, 더 중요한건 표현식&lt;g3&gt;(fun x : Nat =&gt; x)&lt;/g3&gt;을 &lt;g5&gt;1&lt;/g5&gt;에 적용하는 것은 값 &lt;g4&gt;1&lt;/g4&gt;을 "반환"하는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, most such systems provide fully elaborated "proof objects" that can be communicated to other systems and
checked independently.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131457Z" creationid="tlqk35" creationdate="20220321T131457Z">
        <seg>사실, 그런 시스템의 대부분은 증명 대상과의 완전한 협력을 제공합니다. 이 대상은 다른 시스템과 상호작용될 수 있고 독립적으로 검증될 수 있습니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In fact, the function
&lt;g3&gt;id&lt;/g3&gt; is defined in the standard library in exactly this way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153328Z" creationid="tlqk35" creationdate="20220321T153328Z">
        <seg>사실 함수 &lt;g3&gt;id&lt;/g3&gt;는 표준 라이브러리에서도 이와 정확히 동일한 방식으로 정의되어 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In many respects, however, a &lt;g1&gt;namespace ... end&lt;/g1&gt; block behaves the
same as a &lt;g2&gt;section ... end&lt;/g2&gt; block.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150718Z" creationid="tlqk35" creationdate="20220321T150718Z">
        <seg>하지만 여러 관점에서 &lt;g1&gt;namespace ... end&lt;/g1&gt;블록은 &lt;g2&gt;section ... end&lt;/g2&gt;블록과 동일하게 동작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other
words, &lt;g7&gt;assuming&lt;/g7&gt; &lt;g8&gt;α : Type&lt;/g8&gt; is the first argument to the function,
the type of the next two elements are &lt;g9&gt;α&lt;/g9&gt; and &lt;g10&gt;List α&lt;/g10&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151425Z" creationid="tlqk35" creationdate="20220321T151425Z">
        <seg>다시 말하면 함수의 첫 번째 인수로  &lt;g8&gt;α : Type&lt;/g8&gt;으로  &lt;g7&gt;가정&lt;/g7&gt;하면 다음 두 원소의 유형은  &lt;g9&gt;α&lt;/g9&gt;와 &lt;g10&gt;List α&lt;/g10&gt;가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, for every &lt;g12&gt;α&lt;/g12&gt;,
&lt;g13&gt;cons α&lt;/g13&gt; is the function that takes an element &lt;g14&gt;a : α&lt;/g14&gt; and a list
&lt;g15&gt;as : List α&lt;/g15&gt;, and returns a new list, so you have &lt;g16&gt;cons α a as : List α&lt;/g16&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151242Z" creationid="tlqk35" creationdate="20220321T151242Z">
        <seg>다시 말하면 모든 &lt;g12&gt;α&lt;/g12&gt;에 대해  &lt;g13&gt;cons α&lt;/g13&gt;는 원소 &lt;g14&gt;a : α&lt;/g14&gt;와 리스트 &lt;g15&gt;as : List α&lt;/g15&gt;를 받는 함수입니다.  그리고 새로운 리스트를 반환합니다. 그래서 여러분은  &lt;g16&gt;cons α a as : List α&lt;/g16&gt;를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, the type of the value
returned by &lt;g14&gt;f&lt;/g14&gt; depends on its input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151837Z" creationid="tlqk35" creationdate="20220321T151837Z">
        <seg>다시 말하자면 &lt;g14&gt;f&lt;/g14&gt;에 의해 반환되는 값의 유형은 그것의 입력에 의존합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In particular, if you use the
&lt;g3&gt;variable&lt;/g3&gt; command within a namespace, its scope is limited to the
namespace.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150731Z" creationid="tlqk35" creationdate="20220321T150731Z">
        <seg>특히, 이름공간 안에서 &lt;g3&gt;variable&lt;/g3&gt; 명령을 사용한다면 그것의 범위는 이름공간으로 제한될 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In practice, there is not a
sharp distinction between verifying a piece of mathematics and verifying the correctness of a system: formal
verification requires describing hardware and software systems in mathematical terms, at which point establishing claims
as to their correctness becomes a form of theorem proving.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131208Z" creationid="tlqk35" creationdate="20220321T131208Z">
        <seg>실제로 수학의 일부를 식별하는 것과 시스템의 명확성을 식별하는 것 사이에 명확한 구분이 없습니다. 형식 증명은 하드웨어와 소프트웨어 시스템을 수학적 항으로 묘사하기를 요구합니다. 그리고 그때 그들의 올바름에 대한 주장을 세우는 것은 정리 증명의 형태가 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In that case, the type &lt;g9&gt;(a : α) → β a&lt;/g9&gt; denotes the type
of functions &lt;g10&gt;f&lt;/g10&gt; with the property that, for each &lt;g11&gt;a : α&lt;/g11&gt;, &lt;g12&gt;f a&lt;/g12&gt;
is an element of &lt;g13&gt;β a&lt;/g13&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151821Z" creationid="tlqk35" creationdate="20220321T151821Z">
        <seg>이 경우 유형 &lt;g9&gt;(a : α) → β a&lt;/g9&gt;는 모든  &lt;g11&gt;a : α&lt;/g11&gt;에 대해,  &lt;g12&gt;f a&lt;/g12&gt;가 &lt;g13&gt;β a&lt;/g13&gt;의 원소라는 성질로 &lt;g10&gt;f&lt;/g10&gt; 함수의 유형을 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
Lean standard library, you often see Greek letters to denote types,
and the Unicode symbol &lt;g11&gt;→&lt;/g11&gt; as a more compact version of &lt;g12&gt;-&gt;&lt;/g12&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140139Z" creationid="tlqk35" creationdate="20220321T140139Z">
        <seg>린의 표준 라이브러리에서 여러분은 유형을 나타내는데 그리스 문자를 자주 보게 됩니다. 그리고 유니코드 기호 &lt;g11&gt;→&lt;/g11&gt; 은 &lt;g12&gt;-&gt;&lt;/g12&gt;보다 더 간결한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the
second expression, &lt;g6&gt;a&lt;/g6&gt; is a variable, and the expression
&lt;g7&gt;fun a =&gt; t2&lt;/g7&gt; has to make sense independently of the value of &lt;g8&gt;a&lt;/g8&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145013Z" creationid="tlqk35" creationdate="20220321T145013Z">
        <seg>두 번째 표현식에서 &lt;g6&gt;a&lt;/g6&gt;는 변수이고 표현식 &lt;g7&gt;fun a =&gt; t2&lt;/g7&gt;는  &lt;g8&gt;a&lt;/g8&gt;의 값과 별개로 의미를 가져야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the example above, &lt;g2&gt;def m : Nat := 1&lt;/g2&gt;
defines a new constant &lt;g3&gt;m&lt;/g3&gt; of type &lt;g4&gt;Nat&lt;/g4&gt; whose value is &lt;g5&gt;1&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135810Z" creationid="tlqk35" creationdate="20220321T135810Z">
        <seg>위 예제에서 &lt;g2&gt;def m : Nat := 1&lt;/g2&gt;는 &lt;g5&gt;1&lt;/g5&gt;을 값으로 갖는 새로운 상수 &lt;g3&gt;m&lt;/g3&gt;을 &lt;g4&gt;Nat&lt;/g4&gt;유형으로 정의합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the first expression, you should think of every instance
of &lt;g3&gt;a&lt;/g3&gt; in &lt;g4&gt;t2&lt;/g4&gt; as a syntactic abbreviation for &lt;g5&gt;t1&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144938Z" creationid="tlqk35" creationdate="20220321T144938Z">
        <seg>첫 번째 표현식에서, 여러분은 &lt;g4&gt;t2&lt;/g4&gt;속 &lt;g3&gt;a&lt;/g3&gt;의 모든 개체를 &lt;g5&gt;t1&lt;/g5&gt;에 대한 문법적 약어로 생각해야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the second pair of examples below, this mechanism is
used to specify the desired types of the expressions &lt;g6&gt;id&lt;/g6&gt; and
&lt;g7&gt;List.nil&lt;/g7&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153603Z" creationid="tlqk35" creationdate="20220321T153603Z">
        <seg>아래 예제의 쌍의 두 번째에서, 이 메커니즘은 식 &lt;g6&gt;id&lt;/g6&gt;와 &lt;g7&gt;List.nil&lt;/g7&gt;의 바람직한 유형을 명시하는데 사용됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this case you can think of &lt;g1&gt;def&lt;/g1&gt; as a kind of named &lt;g2&gt;lambda&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144029Z" creationid="tlqk35" creationdate="20220321T144029Z">
        <seg>이 경우 여러분은 &lt;g1&gt;def&lt;/g1&gt;를 &lt;g2&gt;lambda&lt;/g2&gt;와 같은 종류로 생각할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In type theory, this is generally more convenient than
writing &lt;g10&gt;Nat.add&lt;/g10&gt; as a function that takes a pair of natural numbers as
input and returns a natural number as output.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140842Z" creationid="tlqk35" creationdate="20220321T140842Z">
        <seg>유형론에서 보통 &lt;g10&gt;Nat.add&lt;/g10&gt;과 같이 쓰는 것이 자연수 쌍을 입력으로 받고 자연수를 출력으로 하는 함수로 쓰는 것보다 더 편리합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Indeed, in dependent type theory (and in Lean), &lt;g11&gt;α → β&lt;/g11&gt;
is just notation for &lt;g12&gt;(a : α) → β&lt;/g12&gt; when &lt;g13&gt;β&lt;/g13&gt; does not depend on &lt;g14&gt;a&lt;/g14&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152055Z" creationid="tlqk35" creationdate="20220321T152055Z">
        <seg>물론, 종속 유형론에서(그리고 Lean에서) &lt;g11&gt;α → β&lt;/g11&gt;는 &lt;g13&gt;β&lt;/g13&gt;가 &lt;g14&gt;a&lt;/g14&gt;에 의존하지 않을 때 &lt;g12&gt;(a : α) → β&lt;/g12&gt;에 대한 표기일 뿐입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131051Z" creationid="tlqk35" creationdate="20220321T131051Z">
        <seg>소개(Introduction)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has a compiler that
generates a binary executable and an interactive interpreter.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143751Z" creationid="tlqk35" creationdate="20220321T143751Z">
        <seg>이것은 이진 실행 프로그램을 만드는 컴파일러와 상호작용적인 인터프리터를 갖고 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is an ongoing, long-term
effort, and much of the potential for automation will be realized only gradually over time.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131736Z" creationid="tlqk35" creationdate="20220321T131736Z">
        <seg>이것은 장기적으로 현재진행 중이고 자동화에 대한 대부분의 잠재성은 시간이 지나면서 점차 실현될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is clear that &lt;g1&gt;cons α&lt;/g1&gt; should have type &lt;g2&gt;α → List α → List α&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151301Z" creationid="tlqk35" creationdate="20220321T151301Z">
        <seg>&lt;g1&gt;cons α&lt;/g1&gt;가  &lt;g2&gt;α → List α → List α&lt;/g2&gt; 유형을 가져야 함은 분명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It is still tedious, however, to type all these underscores.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153139Z" creationid="tlqk35" creationdate="20220321T153139Z">
        <seg>그래도 여전히 이 밑줄문자를 치는 것은 번거롭습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just as dependent function types &lt;g1&gt;(a : α) → β a&lt;/g1&gt; generalize the
notion of a function type &lt;g2&gt;α → β&lt;/g2&gt; by allowing &lt;g3&gt;β&lt;/g3&gt; to depend on
&lt;g4&gt;α&lt;/g4&gt;, dependent Cartesian product types &lt;g5&gt;(a : α) × β a&lt;/g5&gt; generalize
the Cartesian product &lt;g6&gt;α × β&lt;/g6&gt; in the same way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152228Z" creationid="tlqk35" creationdate="20220321T152228Z">
        <seg>의존적 함수 유형 &lt;g1&gt;(a : α) → β a&lt;/g1&gt;는 함수의 유형 &lt;g2&gt;α → β&lt;/g2&gt;의 개념을 &lt;g3&gt;β&lt;/g3&gt;가 &lt;g4&gt;α&lt;/g4&gt;에 종속적이라고 함으로써 일반화한 것처럼 의존적 카테시안 곱 유형은 &lt;g5&gt;(a : α) × β a&lt;/g5&gt;는 카테시안 곱 &lt;g6&gt;α × β&lt;/g6&gt;를 같은 방식으로 일반화합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also allows you to introduce "local" definitions using the
&lt;g1&gt;let&lt;/g1&gt; keyword.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144719Z" creationid="tlqk35" creationdate="20220321T144719Z">
        <seg>Lean은 여러분이 &lt;g1&gt;let&lt;/g1&gt; 키워드를 사용해 "지역" 정의를 가져올 수 있게 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean also has mechanisms to serve as its own &lt;g1&gt;metaprogramming
language&lt;/g1&gt;, which means that you can implement automation and extend the functionality of Lean using Lean itself.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131622Z" creationid="tlqk35" creationdate="20220321T131622Z">
        <seg>또한 Lean은 그 자체로 &lt;g1&gt;메타프로그래밍 언어&lt;/g1&gt;로 기능하는 작동 원리가 있어 자동화의 수행 및 Lean 자체로 그 기능을 확장할 수 있음을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean can
usually infer the type &lt;g4&gt;α&lt;/g4&gt;, but it is often a good idea to write it
explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144144Z" creationid="tlqk35" creationdate="20220321T144144Z">
        <seg>Lean은 &lt;g4&gt;α&lt;/g4&gt;의 유형을 추론할 수 있습니다. 그러나 이를 명백히 적는 것이 좋습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean can not only define mathematical objects and express
mathematical assertions in dependent type theory, but it also can be used as a language for writing proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132153Z" creationid="tlqk35" creationdate="20220321T132120Z">
        <seg>린은 수학적 대상들을 정의하고 수학적 주장을 의존 유형론으로 진술할 수 있고 증명을 작성하는 언어로써 사용될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean has very complex mechanisms for instantiating implicit arguments,
and we will see that they can be used to infer function types,
predicates, and even proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153412Z" creationid="tlqk35" creationdate="20220321T153412Z">
        <seg>Lean은 암시적인 인수를 인스턴스화(instantiating)하는데 아주 복잡한 매커니즘을 가지고 있습니다. 그리고 우리는 함수의 유형과 술어 그리고 심지어 증명을 추론하는데 사용될 수 있음을 볼 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean interprets the final three examples as the same expression; in
the last expression, Lean infers the type of &lt;g1&gt;x&lt;/g1&gt; and &lt;g2&gt;y&lt;/g2&gt; from the
expression &lt;g3&gt;if not y then x + 1 else x + 2&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142601Z" creationid="tlqk35" creationdate="20220321T142601Z">
        <seg>린은 마지막 세 예제를 같은 표현식으로 해석합니다. 마지막 표현식에서 린은 &lt;g1&gt;x&lt;/g1&gt;와 &lt;g2&gt;y&lt;/g2&gt;의 유형을 표현식 &lt;g3&gt;if not y then x + 1 else x + 2&lt;/g3&gt;으로부터 추론합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is a complete programming language.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143745Z" creationid="tlqk35" creationdate="20220321T143745Z">
        <seg>린은 완전한 프로그래밍 언어입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is based on a version of dependent type
theory known as the &lt;g1&gt;Calculus of Constructions&lt;/g1&gt;, with a countable
hierarchy of non-cumulative universes and inductive types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135135Z" creationid="tlqk35" creationdate="20220321T135135Z">
        <seg>린은  &lt;g1&gt;직관주의 계산법&lt;/g1&gt;이라고 하는 가산적인 비축적적 세계(Universe)와 유도형이 있는 의존 유형론 버전을 기반합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is released under the
&lt;g2&gt;Apache 2.0 license&lt;/g2&gt;, a permissive open source license that permits others to use and extend the code and
mathematical libraries freely.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131805Z" creationid="tlqk35" creationdate="20220321T131805Z">
        <seg>Lean은  &lt;g2&gt;Apache 2.0 라이센스&lt;/g2&gt;하에서 배포되었습니다. 이는 타인에게 자유롭게 사용하는 것과 수학 라이브러리 및 코드의 확장을 허락합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean is smart enough to figure out which variables are used
explicitly or implicitly in a definition.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145931Z" creationid="tlqk35" creationdate="20220321T145931Z">
        <seg>Lean은 정의에서 명시적으로나 암시적으로 사용된 변수를 구분하기에 충분히 똑똑합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides a &lt;g1&gt;fun&lt;/g1&gt; (or &lt;g2&gt;λ&lt;/g2&gt;) keyword to create a function
from an expression as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142148Z" creationid="tlqk35" creationdate="20220321T142148Z">
        <seg>린은 &lt;g1&gt;fun&lt;/g1&gt; (또는 &lt;g2&gt;λ&lt;/g2&gt;) 키워드를 제공하여 다음과 같은 표현식으로부터 함수를 만들 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides you with the &lt;g1&gt;variable&lt;/g1&gt; command to make such
declarations look more compact:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145147Z" creationid="tlqk35" creationdate="20220321T145143Z">
        <seg>린은 여러분에게 이런 선언을 더 간결하게 보이게 만들도록 &lt;g1&gt;variable&lt;/g1&gt; 명령을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean provides you with the ability to group definitions into nested,
hierarchical &lt;g1&gt;namespaces&lt;/g1&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150219Z" creationid="tlqk35" creationdate="20220321T150219Z">
        <seg>Lean은 여러분에게 정의를 중첩되고 계층적인 &lt;g1&gt;namespaces&lt;/g1&gt;에 묶을 수 있는 능력을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's underlying foundation has an infinite
hierarchy of types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141603Z" creationid="tlqk35" creationdate="20220321T141603Z">
        <seg>린의 기저에는 무한한 유형의 계층이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lean's underlying logic has a computational interpretation, and Lean can be viewed equally well as a programming
language.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131550Z" creationid="tlqk35" creationdate="20220321T131550Z">
        <seg>Lean의 기본 논리는 컴퓨팅 해석기(interpretor)을 가지는데 있다. 그래서 Lean은 프로그래밍 언어와 마찬가지로 동등하게 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's create one
that adds two natural numbers:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144254Z" creationid="tlqk35" creationdate="20220321T144254Z">
        <seg>두 자연수를 더하는 함수를 만들어 봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's take a look at some basic syntax.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140329Z" creationid="tlqk35" creationdate="20220321T140329Z">
        <seg>몇 가지 기본 문법에 대해 살펴봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like sections, namespaces can be nested:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150535Z" creationid="tlqk35" creationdate="20220321T150535Z">
        <seg>section처럼 이름공간도 중첩될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like sections, nested namespaces have to be closed in the order they
are opened.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150603Z" creationid="tlqk35" creationdate="20220321T150603Z">
        <seg>섹션과 마찬가지로 중첩된 이름공간은 그들이 열린 순서대로 닫혀야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Local Definitions</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144706Z" creationid="tlqk35" creationdate="20220321T144706Z">
        <seg>지역 정의(Local Definitions)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Many people have contributed to the effort, providing
corrections, suggestions, examples, and text.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134821Z" creationid="tlqk35" creationdate="20220321T134821Z">
        <seg>많은 사람들이 오타 정정, 제안, 예제, 본분을 제공하는 등의 노력으로 기여했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More specifically, Lean is based on a version of a system
known as the Calculus of Constructions with inductive types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132056Z" creationid="tlqk35" creationdate="20220321T132056Z">
        <seg>더 구체적으로 Lean은 유도형(inductive types)의 직관주의적 계산법(calculus of Construction)으로 알려진 시스템에 기반한 버전입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>More to the point, it can be viewed as a system for writing programs with a precise semantics, as well as
reasoning about the functions that the programs compute.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131607Z" creationid="tlqk35" creationdate="20220321T131607Z">
        <seg>더욱이 이것은 정밀한 의미를 갖는 편집프로그램이나 프로그램이 계산하는 함수에 대한 추론 프로그램으로도 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moreover, the
output indicates that the first argument is implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153759Z" creationid="tlqk35" creationdate="20220321T153759Z">
        <seg>게다가 출력은 첫 번째 인수가 암시적임을 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Much of the background information you will
need in order to do this is not specific to Lean at all.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132021Z" creationid="tlqk35" creationdate="20220321T132021Z">
        <seg>이를 배우기 위해 필요한 대부분의 배경지식은 Lean으로만 국한되어 있지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150201Z" creationid="tlqk35" creationdate="20220321T150201Z">
        <seg>이름공간(Namespaces)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces and sections serve different purposes:
namespaces organize data and sections declare variables for insertion
in definitions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150609Z" creationid="tlqk35" creationdate="20220321T150609Z">
        <seg>이름공간과 섹션은 다른 목적을 갖고 일합니다. 이름공간은 데이터를 정리하고 섹션은 정의의 삽입에 대해 변수를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Namespaces that have been closed can later be reopened, even in another file:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150550Z" creationid="tlqk35" creationdate="20220321T150550Z">
        <seg>닫힌 이름공간은 심지어 다른 파일일지라도 나중에 다시 열릴 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nor do you have
to name a section, which is to say, you can use an anonymous
&lt;g1&gt;section&lt;/g1&gt; / &lt;g2&gt;end&lt;/g2&gt; pair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150138Z" creationid="tlqk35" creationdate="20220321T150138Z">
        <seg>섹션에 이름을 줄 필요도 없습니다. 그말은 즉슨, 여러분은 익명의 &lt;g1&gt;section&lt;/g1&gt; / &lt;g2&gt;end&lt;/g2&gt; 쌍을 사용할 수 있다는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notationally,
this hides the specification of the type, making it look as though
&lt;g2&gt;ident&lt;/g2&gt; simply takes an argument of any type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153317Z" creationid="tlqk35" creationdate="20220321T153317Z">
        <seg>표기상으로 &lt;g2&gt;ident&lt;/g2&gt;가 단순히 임의의 유형의 인수를 받을 수 있는 것처럼 만들어 유형의 명세를 감춥니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note
that &lt;g10&gt;×&lt;/g10&gt; is a Unicode symbol.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140054Z" creationid="tlqk35" creationdate="20220321T140054Z">
        <seg>&lt;g10&gt;×&lt;/g10&gt;은 유니코드 기호임을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice here we called the &lt;g1&gt;double&lt;/g1&gt; function to create the first
parameter to &lt;g2&gt;add&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144328Z" creationid="tlqk35" creationdate="20220321T144328Z">
        <seg>여기서 우리가 &lt;g2&gt;add&lt;/g2&gt;의 첫 번째 매개변수를 만들기 위해 &lt;g1&gt;double&lt;/g1&gt; 함수를 호출한 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that &lt;g1&gt;(a : α) → β&lt;/g1&gt; makes sense for any expression &lt;g2&gt;β :
Type&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151858Z" creationid="tlqk35" creationdate="20220321T151858Z">
        <seg>&lt;g1&gt;(a : α) → β&lt;/g1&gt;는  모든 식  &lt;g2&gt;β : Type&lt;/g2&gt;에 대해 성립하는 것을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that applying a term &lt;g1&gt;t : α → β&lt;/g1&gt; to a term &lt;g2&gt;s : α&lt;/g2&gt; yields
an expression &lt;g3&gt;t s : β&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143513Z" creationid="tlqk35" creationdate="20220321T143513Z">
        <seg>항 &lt;g1&gt;t : α → β&lt;/g1&gt;을 항 &lt;g2&gt;s : α&lt;/g2&gt;에 적용하여 표현식 &lt;g3&gt;t s : β&lt;/g3&gt;을 얻는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that now the first &lt;g1&gt;#check&lt;/g1&gt; command gives the type of the
identifier, &lt;g2&gt;id&lt;/g2&gt;, without inserting any placeholders.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153754Z" creationid="tlqk35" creationdate="20220321T153754Z">
        <seg>현재 첫 번째 &lt;g1&gt;#check&lt;/g1&gt; 명령은 식별자 &lt;g2&gt;id&lt;/g2&gt;의 유형을 어떤 플레이스 홀더도 삽입하지 않고 주는 것을 보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that the meaning of the expression &lt;g1&gt;let a := t1; t2&lt;/g1&gt; is very
similar to the meaning of &lt;g2&gt;(fun a =&gt; t2) t1&lt;/g2&gt;, but the two are not
the same.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144909Z" creationid="tlqk35" creationdate="20220321T144909Z">
        <seg>표현식 &lt;g1&gt;let a := t1; t2&lt;/g1&gt;의 의미는 &lt;g2&gt;(fun a =&gt; t2) t1&lt;/g2&gt;의 의미와 아주 비슷함을 주목하세요. 그러나 이 둘은 같지는 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now to get a bit more abstract, you can also specify arguments that
are like type parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144422Z" creationid="tlqk35" creationdate="20220321T144422Z">
        <seg>이제 약간 더 추상적으로 갑시다. 여러분은 유형 매개변수같은 인수를 지정할 수도 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numerals are overloaded in Lean, but when the type of a numeral cannot
be inferred, Lean assumes, by default, that it is a natural number.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153644Z" creationid="tlqk35" creationdate="20220321T153644Z">
        <seg>수치들은 Lean에 매우 많이 있습니다. 그러나 수치 유형이 추론되지 못할 때, 린은 기본적으로 그걸 자연수라고 가정합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Often, when you import a module, you will want to open one or
more of the namespaces it contains, to have access to the short
identifiers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150448Z" creationid="tlqk35" creationdate="20220321T150448Z">
        <seg>짧은 식별자로 접근하기 위해서 종종 여러분이 모듈을 가져오기(import) 할 때, 모듈이 담은 다수의 이름공간을 열기 원할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once again, you should try some examples on your own.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140307Z" creationid="tlqk35" creationdate="20220321T140307Z">
        <seg>다시 한번 여러분 스스로 몇 가지 예제를 시도해보기 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can always specify the type &lt;g1&gt;T&lt;/g1&gt; of an expression &lt;g2&gt;e&lt;/g2&gt; by
writing &lt;g3&gt;(e : T)&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153518Z" creationid="tlqk35" creationdate="20220321T153518Z">
        <seg>누군가는 표현식 &lt;g2&gt;e&lt;/g2&gt;의 유형 &lt;g1&gt;T&lt;/g1&gt;를 &lt;g3&gt;(e : T)&lt;/g3&gt;와 같이 씀으로써 항상 명시할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One can similarly infer the argument in &lt;g6&gt;Lst.nil Nat&lt;/g6&gt;, not
from anything else in that expression, but from the fact that it is
sent as an argument to the function &lt;g7&gt;Lst.cons&lt;/g7&gt;, which expects an element
of type &lt;g8&gt;Lst α&lt;/g8&gt; in that position.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153125Z" creationid="tlqk35" creationdate="20220321T152730Z">
        <seg>어떤 식으로부터도 아니고 &lt;g8&gt;Lst α&lt;/g8&gt;형의 원소를 기대하는 &lt;g7&gt; Lst.cons&lt;/g7&gt; 함수에 인수로 전달되었다는 사실로부터 누군가는 비슷하게 &lt;g6&gt;Lst.nil Nat&lt;/g6&gt;에서 인수를 추론할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way in which Lean's dependent type theory extends simple type
theory is that types themselves --- entities like &lt;g1&gt;Nat&lt;/g1&gt; and &lt;g2&gt;Bool&lt;/g2&gt;
--- are first-class citizens, which is to say that they themselves are
objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141313Z" creationid="tlqk35" creationdate="20220321T141313Z">
        <seg>린의 종속 유형론이 단순 유형론을 확장시키는 한 방법은 ---&lt;g1&gt;Nat&lt;/g1&gt;과 &lt;g2&gt;Bool&lt;/g2&gt;같은 개체는 그들 그 자체로 대상인 일등 시민 ---으로 두는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Other systems provide search procedures and decision procedures for specific languages and domains,
such as linear or nonlinear expressions over the integers or the real numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131328Z" creationid="tlqk35" creationdate="20220321T131328Z">
        <seg>다른 시스템들은 특정 언어와 영역에 대한 선형 혹은 비선형 식(가령 정수나 실수에 대해 정의된)들에 탐색 절차과 결정 절차를 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Please see &lt;g1&gt;lean prover&lt;/g1&gt; and &lt;g2&gt;lean community&lt;/g2&gt; for an up to date list
of our amazing contributors.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134918Z" creationid="tlqk35" creationdate="20220321T134918Z">
        <seg>합&lt;g1&gt;린 증명보조기&lt;/g1&gt;와 &lt;g2&gt;린 커뮤니티&lt;/g2&gt;에서 놀라운 최신 기여자 명단을 확인할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Printing them out shows that all three groups of definitions have
exactly the same effect.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145220Z" creationid="tlqk35" creationdate="20220321T145220Z">
        <seg>이것을 출력하는 것은 세 정의 그룹이 정확히 동일한 효과를 가짐을 보여줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recall that the &lt;g1&gt;def&lt;/g1&gt; keyword provides one important way of declaring new named
objects.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143839Z" creationid="tlqk35" creationdate="20220321T143839Z">
        <seg>&lt;g1&gt;def&lt;/g1&gt;가 새 이름을 가진 대상을 선언하는 중요한 방식임을 기억하세요.

</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Resolution theorem provers, tableau theorem provers, fast
satisfiability solvers, and so on provide means of establishing the validity of formulas in propositional and
first-order logic.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131315Z" creationid="tlqk35" creationdate="20220321T131315Z">
        <seg>Resolution 증명 보조기, tableau 증명 보조기, fast satisfiability 솔버 등등은 명제 논리식와 1계 논리식의 유효성을 식별하는 세우는 수단을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning to the example of lists, you can use the command &lt;g1&gt;#check&lt;/g1&gt; to
inspect the type of the following &lt;g2&gt;List&lt;/g2&gt; functions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152114Z" creationid="tlqk35" creationdate="20220321T152114Z">
        <seg>리스트의 예로 돌아가서 여러분은 다음 &lt;g2&gt;List&lt;/g2&gt; 함수의 유형을 검사하기 위해 &lt;g1&gt;#check&lt;/g1&gt; 명령을 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Returning to the previous example and
renaming bound variables for clarity, notice the types of the
following expressions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143523Z" creationid="tlqk35" creationdate="20220321T143523Z">
        <seg>이전 예제로 돌아가 명확성을 위해 구속변수의 이름을 바꿉시다. 다음 표현식의 유형을 주목하세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Second, when writing type expressions, arrows associate to the &lt;g5&gt;right&lt;/g5&gt;; for
example, the type of &lt;g6&gt;Nat.add&lt;/g6&gt; is &lt;g7&gt;Nat → Nat → Nat&lt;/g7&gt; which is equivalent
to &lt;g8&gt;Nat → (Nat → Nat)&lt;/g8&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140808Z" creationid="tlqk35" creationdate="20220321T140808Z">
        <seg>둘째로 유형 표현식을 쓸 때 화살표는&lt;g5&gt;오른쪽&lt;/g5&gt; 먼저 결합합니다. 가령&lt;g6&gt;Nat.add&lt;/g6&gt;의 유형은 &lt;g7&gt;Nat → Nat → Nat&lt;/g7&gt;이고 이는 &lt;g8&gt;Nat → (Nat → Nat)&lt;/g8&gt;과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sections are also useful for delimiting the scope of
commands such as &lt;g1&gt;set_option&lt;/g1&gt; and &lt;g2&gt;open&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150626Z" creationid="tlqk35" creationdate="20220321T150626Z">
        <seg>section은 &lt;g1&gt;set_option&lt;/g1&gt;과 &lt;g2&gt;open&lt;/g2&gt;같이 명령의 범위를 제한하는데 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sections can also be nested,
which allows you to declare new variables incrementally.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150155Z" creationid="tlqk35" creationdate="20220321T150155Z">
        <seg>section은 중첩될 수도 있습니다. 이는 여러분에게 새로운 변수를 점진적으로 선언할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, if you use an &lt;g4&gt;open&lt;/g4&gt; command within a
namespace, its effects disappear when the namespace is closed.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150742Z" creationid="tlqk35" creationdate="20220321T150742Z">
        <seg>마찬가지로 여러분이 이름공간 내에서 &lt;g4&gt;open&lt;/g4&gt; 명령을 사용한다면 그것의 효과는 이름공간이 닫힐 때 사라질 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, methods of &lt;g2&gt;elaboration&lt;/g2&gt; and &lt;g3&gt;type inference&lt;/g3&gt;, which can be used to support
flexible forms of algebraic reasoning.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134656Z" creationid="tlqk35" creationdate="20220321T134656Z">
        <seg>비슷하게 대수 추론의 유연한 형태를 지원하는데 사용될 수 있는 &lt;g2&gt;협력법&lt;/g2&gt;과  &lt;g3&gt;유형 추론&lt;/g3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Similarly, two dashes &lt;g3&gt;--&lt;/g3&gt; indicate that the rest of
the line contains a comment that is also ignored.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135543Z" creationid="tlqk35" creationdate="20220321T135543Z">
        <seg>마찬가지로 두 개의 대시 &lt;g3&gt;--&lt;/g3&gt;는 이 줄의 나머지는 주석을 포함함을 나타내고 이 또한 무시됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple Type Theory</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135147Z" creationid="tlqk35" creationdate="20220321T135147Z">
        <seg>단순 유형론(Simple Type Theory)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So
the expressions in the first two &lt;g1&gt;#check&lt;/g1&gt; commands below are
elaborated in the same way, whereas the third &lt;g2&gt;#check&lt;/g2&gt; command
interprets &lt;g3&gt;2&lt;/g3&gt; as an integer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153707Z" creationid="tlqk35" creationdate="20220321T153707Z">
        <seg>그래서 아래 첫 두 &lt;g1&gt;#check&lt;/g1&gt;명령에서 표현식은 같은 방식으로 해석됩니다. 반면 세 번째 &lt;g2&gt;#check&lt;/g2&gt; 명령은 &lt;g3&gt;2&lt;/g3&gt;를 정수로 해석합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So &lt;g2&gt;def&lt;/g2&gt; can also be used to simply name a value like this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144224Z" creationid="tlqk35" creationdate="20220321T144224Z">
        <seg>그래서 &lt;g2&gt;def&lt;/g2&gt;는 이 같은 값을 단순히 이름으로 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So it makes sense to take the type to be the first argument to
&lt;g8&gt;cons&lt;/g8&gt;, so that for any type, &lt;g9&gt;α&lt;/g9&gt;, &lt;g10&gt;cons α&lt;/g10&gt; is the insertion
function for lists of type &lt;g11&gt;α&lt;/g11&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151156Z" creationid="tlqk35" creationdate="20220321T151156Z">
        <seg>그래서 &lt;g8&gt;cons&lt;/g8&gt;의 첫번째 인수의 유형으로 임의의 유형 &lt;g9&gt;α&lt;/g9&gt;를 받아들이게 하는게 타당합니다. &lt;g10&gt;cons α&lt;/g10&gt;는 &lt;g11&gt;α&lt;/g11&gt;유형을 원소로 하는 리스트에 대한 삽입 함수입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So, for example, you
can write &lt;g8&gt;fun x =&gt; g (f x)&lt;/g8&gt; instead of &lt;g9&gt;fun x : Nat =&gt; g (f x)&lt;/g9&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143113Z" creationid="tlqk35" creationdate="20220321T143113Z">
        <seg>그래서 여러분은 &lt;g8&gt;fun x : Nat =&gt; g (f x)&lt;/g8&gt;대신에 &lt;g9&gt;fun x =&gt; g (f x)&lt;/g9&gt;와 같이 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some mathematically common examples of operations of functions can be
described in terms of lambda abstraction:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142622Z" creationid="tlqk35" creationdate="20220321T142622Z">
        <seg>수학적으로 흔한 함수 연산 예제는 람다 추상화에 대한 것으로 설명될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some operations, however, need to be &lt;g1&gt;polymorphic&lt;/g1&gt; over type
universes.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141814Z" creationid="tlqk35" creationdate="20220321T141814Z">
        <seg>그러나 몇몇 연산은 유형 세계에 대해 &lt;g1&gt;다형적(polymorphic)&lt;/g1&gt;일 필요가 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes, however, it is useful to limit
the scope of a variable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150032Z" creationid="tlqk35" creationdate="20220321T150032Z">
        <seg>그러나 때때로 변수의 범위를 제한하는 것이 유용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes, however, we may find ourselves in a situation where we have
declared an argument to a function to be implicit, but now want to
provide the argument explicitly.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153716Z" creationid="tlqk35" creationdate="20220321T153716Z">
        <seg>하지만 때때로 우리는 우리 스스로 함수에 대한 인수가 암시적이도록 선언하는 걸 발견합니다. 그러나 지금 인수를 명시적으로 제공하길 원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Special modes in Visual Studio Code (VS Code for short) and
Emacs offer powerful support for writing and debugging proofs, and is much better suited for serious use.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131922Z" creationid="tlqk35" creationdate="20220321T131922Z">
        <seg>비주얼 스튜디오 코드(짧게는 VS code)에서 특정 모드와 Emacs는 강력한 편집 기능과 증명 디버깅 기능을 지원합니다. 그리고 진지한 사용을 생각한다면 이게 훨씬 적합합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Such a
function is &lt;g3&gt;polymorphic&lt;/g3&gt;: you expect the &lt;g4&gt;cons&lt;/g4&gt; function for
&lt;g5&gt;Nat&lt;/g5&gt;, &lt;g6&gt;Bool&lt;/g6&gt;, or an arbitrary type &lt;g7&gt;α&lt;/g7&gt; to behave the same way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151118Z" creationid="tlqk35" creationdate="20220321T151118Z">
        <seg>이러한 함수는 &lt;g3&gt;polymorphic&lt;/g3&gt;입니다. 여러분은 &lt;g4&gt;cons&lt;/g4&gt;는  &lt;g5&gt;Nat&lt;/g5&gt;, &lt;g6&gt;Bool&lt;/g6&gt; 혹은 임의의 유형  &lt;g7&gt;α&lt;/g7&gt;에 대해 동일한 방식으로 동작해야 한다고 기대합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Such systems
can have bugs, and it can be difficult to ensure that the results they deliver are correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131418Z" creationid="tlqk35" creationdate="20220321T131418Z">
        <seg>이런 시스템들은 버그가 생길 수 있고, 그들이 올바르다고 도출한 결과를 확실히 보장하기가 어려울 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose we have an implementation of lists as:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152423Z" creationid="tlqk35" creationdate="20220321T152423Z">
        <seg>우리가 리스트의 구현을 다음과 같이 했다고 가정합시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose you have the variable &lt;g2&gt;x : α&lt;/g2&gt; and you can
construct an expression &lt;g3&gt;t : β&lt;/g3&gt;, then the expression &lt;g4&gt;fun (x : α)
=&gt; t&lt;/g4&gt;, or, equivalently, &lt;g5&gt;λ (x : α) =&gt; t&lt;/g5&gt;, is an object of type &lt;g6&gt;α
→ β&lt;/g6&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142401Z" creationid="tlqk35" creationdate="20220321T142401Z">
        <seg>여러분이 변수 &lt;g2&gt;x : α&lt;/g2&gt;를 갖고 있고 표현식 &lt;g3&gt;t : β&lt;/g3&gt;을 만들 수 있다 가정합시다. 그러면 표현식&lt;g4&gt;fun (x : α) =&gt; t&lt;/g4&gt; 또는 등가적으로 &lt;g5&gt;λ (x : α) =&gt; t&lt;/g5&gt;은 &lt;g6&gt;α → β&lt;/g6&gt; 유형인 대상입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Suppose you wish to write a function &lt;g1&gt;cons&lt;/g1&gt; which inserts a new
element at the head of a list.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151011Z" creationid="tlqk35" creationdate="20220321T151011Z">
        <seg>여러분이 리스트의 머리에 새 원소를 삽입하는 함수 &lt;g1&gt;cons&lt;/g1&gt;를 만들기 원한다 해봅시다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;;&lt;/g1&gt; can be omitted when a line break is used.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144853Z" creationid="tlqk35" creationdate="20220321T144853Z">
        <seg>세미콜론&lt;g1&gt;;&lt;/g1&gt;은 줄을 분리할 때 사용되므로 생략될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;Lean Theorem Prover&lt;/g1&gt; aims to bridge the gap between interactive and automated theorem proving, by situating
automated tools and methods in a framework that supports user interaction and the construction of fully specified
axiomatic proofs.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131527Z" creationid="tlqk35" creationdate="20220321T131527Z">
        <seg> &lt;g1&gt;Lean 증명 보조기&lt;/g1&gt;는 사용자의 상호작용과 완전히 구체화된 공리적 증명의 생성을 돕는 자동화된 도구와 방법들을 프레임워크에 둠으로써 상호작용과 자동화된 정리 증명 사이의 빈틈을 메우는 것을 목표로 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;Lean&lt;/g1&gt; project was launched by Leonardo de Moura at Microsoft Research Redmond in 2013.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131729Z" creationid="tlqk35" creationdate="20220321T131729Z">
        <seg>&lt;g1&gt;Lean&lt;/g1&gt; 프로젝트는 마이크로소프트 연구소 Redmond의 Leonardo de Moura가 2013년 시작했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;def&lt;/g1&gt; keyword declares new constant symbols into the
working environment.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135611Z" creationid="tlqk35" creationdate="20220321T135611Z">
        <seg>&lt;g1&gt;def&lt;/g1&gt;는 작업 환경에 새로운 상수기호를 선언합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;open&lt;/g1&gt; command brings the shorter names into the current
context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150440Z" creationid="tlqk35" creationdate="20220321T150440Z">
        <seg>&lt;g1&gt;open&lt;/g1&gt; 명령은 현재 맥락에서 짧은 이름을 가져옵니다.
</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g1&gt;variable&lt;/g1&gt; command instructs Lean to insert the declared
variables as bound variables in definitions that refer to them by
name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145922Z" creationid="tlqk35" creationdate="20220321T145922Z">
        <seg> &lt;g1&gt;variable&lt;/g1&gt;명령은 Lean에게 선언된 변수를 그들을 이름으로 참조하는 정의의 구속 변수로 삽입하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g3&gt;@&lt;/g3&gt; symbol
and the difference between the round and curly braces will be
explained momentarily.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152129Z" creationid="tlqk35" creationdate="20220321T152129Z">
        <seg>&lt;g3&gt;@&lt;/g3&gt; 기호와 소괄호와 중괄호 사이의 차이는 곧 설명할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g6&gt;#check&lt;/g6&gt; command asks Lean to report their
types; in Lean, auxiliary commands that query the system for
information typically begin with the hash (#) symbol.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135833Z" creationid="tlqk35" creationdate="20220321T135833Z">
        <seg>&lt;g6&gt;#check&lt;/g6&gt; 명령은 린에게 그것의 유형을 보고하도록 요청합니다. 린에서 시스템에게 정보를 불러오는 보조 명령은 주로 해시(#) 기호로 시작합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g7&gt;#eval&lt;/g7&gt; command asks Lean to evaluate the given expression.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135856Z" creationid="tlqk35" creationdate="20220321T135856Z">
        <seg>&lt;g7&gt;#eval&lt;/g7&gt; 명령은 린에게 제시된 표현의 값을 평가하도록 요청합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The &lt;g9&gt;let&lt;/g9&gt; construct is a stronger means of abbreviation, and there
are expressions of the form &lt;g10&gt;let a := t1; t2&lt;/g10&gt; that cannot be
expressed as &lt;g11&gt;(fun a =&gt; t2) t1&lt;/g11&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145042Z" creationid="tlqk35" creationdate="20220321T145042Z">
        <seg> &lt;g9&gt;let&lt;/g9&gt; 생성은 약어의 의미로 더 강합니다. 그리고 &lt;g10&gt;let a := t1; t2&lt;/g10&gt; 형태의 표현식은 &lt;g11&gt;(fun a =&gt; t2) t1&lt;/g11&gt;같이 표현될 수 없는 식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The command &lt;g1&gt;open List&lt;/g1&gt; allows you to use the shorter names:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150528Z" creationid="tlqk35" creationdate="20220321T150528Z">
        <seg>&lt;g1&gt;open List&lt;/g1&gt; 명령은 여러분이 더 짧은 이름을 사용할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The example above shows
that &lt;g12&gt;Nat.add 3&lt;/g12&gt; has type &lt;g13&gt;Nat → Nat&lt;/g13&gt;, that is, &lt;g14&gt;Nat.add 3&lt;/g14&gt; returns a
function that "waits" for a second argument, &lt;g15&gt;n&lt;/g15&gt;, which is then
equivalent to writing &lt;g16&gt;Nat.add 3 n&lt;/g16&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140932Z" creationid="tlqk35" creationdate="20220321T140932Z">
        <seg>위의 예제에서 &lt;g12&gt;Nat.add 3&lt;/g12&gt;는 &lt;g13&gt;Nat → Nat&lt;/g13&gt;유형을 가짐을  보였습니다. 즉 &lt;g14&gt;Nat.add 3&lt;/g14&gt;은 두번째 인자 &lt;c14&gt;n&lt;/c14&gt;을 "기다리는" 함수를 반환하는 것입니다. 이것은 &lt;g16&gt;Nat.add 3 n&lt;/g16&gt;로 쓰는 것과 동등합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression
&lt;g1&gt;fun x : Nat =&gt; x&lt;/g1&gt; denotes the identity function on &lt;g2&gt;Nat&lt;/g2&gt;, the
expression &lt;g3&gt;fun x : Nat =&gt; true&lt;/g3&gt; denotes the constant function that
always returns &lt;g4&gt;true&lt;/g4&gt;, and &lt;g5&gt;fun x : Nat =&gt; g (f x)&lt;/g5&gt; denotes the
composition of &lt;g6&gt;f&lt;/g6&gt; and &lt;g7&gt;g&lt;/g7&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142738Z" creationid="tlqk35" creationdate="20220321T142738Z">
        <seg>표현식 &lt;g1&gt;fun x : Nat =&gt; x&lt;/g1&gt;은 &lt;g2&gt;Nat&lt;/g2&gt;에 대한 항등함수를 의미합니다. 표현식 &lt;g3&gt;fun x : Nat =&gt; true&lt;/g3&gt;은 항상  &lt;g4&gt;true&lt;/g4&gt;을 반환하는 상수함수를 가리합니다. 그리고 &lt;g5&gt;fun x : Nat =&gt; g (f x)&lt;/g5&gt;는 &lt;g6&gt;f&lt;/g6&gt;와 &lt;g7&gt;g&lt;/g7&gt;의 합성함수를 가리킵니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression &lt;g2&gt;let a := t1; t2&lt;/g2&gt; is
definitionally equal to the result of replacing every occurrence of
&lt;g3&gt;a&lt;/g3&gt; in &lt;g4&gt;t2&lt;/g4&gt; by &lt;g5&gt;t1&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144755Z" creationid="tlqk35" creationdate="20220321T144755Z">
        <seg>표현식 &lt;g2&gt;let a := t1; t2&lt;/g2&gt; 는 &lt;g4&gt;t2&lt;/g4&gt;  속 &lt;g3&gt;a&lt;/g3&gt;의 모든 나타남(occurrence)을 &lt;g5&gt;t1&lt;/g5&gt;으로 대체한 결과에 대해 정의상으로 같습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first function returns a type
&lt;g6&gt;γ&lt;/g6&gt; so that is also the return type of the &lt;g7&gt;compose&lt;/g7&gt; function.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144609Z" creationid="tlqk35" creationdate="20220321T144609Z">
        <seg>첫 번째 함수는 유형 &lt;g6&gt;γ&lt;/g6&gt; 를 반환하여 이게 &lt;g7&gt;compose&lt;/g7&gt; 함수의 반환형이 되게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first is to run it from the web: a Javascript version of Lean, a standard
library of definitions and theorems, and an editor are actually downloaded to your browser and run there.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131828Z" creationid="tlqk35" creationdate="20220321T131828Z">
        <seg>첫째는 웹으로부터 이것을 실행하는 것입니다.(Lean의 자바스크립트 버전, 정의와 정리들의 표준 라이브러리, 편집자는 실제로 여러분의 브라우저에 다운로드를 시키고 거기서 실행하는 것임)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following calls a given function twice passing the output of the
first invocation to the second:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144414Z" creationid="tlqk35" creationdate="20220321T144414Z">
        <seg>다음은 주어진 함수를 첫번째 호출의 출력을 두번째에 전달하는 것으로 두 번 호출합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The following yields the same result:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144033Z" creationid="tlqk35" creationdate="20220321T144033Z">
        <seg>다음은 같은 결과를 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function &lt;g7&gt;Prod&lt;/g7&gt; is
similarly polymorphic:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142043Z" creationid="tlqk35" creationdate="20220321T142043Z">
        <seg>마찬가지로 &lt;g7&gt;Prod&lt;/g7&gt; 함수는 다형적입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions &lt;g1&gt;f&lt;/g1&gt; and &lt;g2&gt;g&lt;/g2&gt; above denote the same function.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152345Z" creationid="tlqk35" creationdate="20220321T152345Z">
        <seg>위 함수  &lt;g1&gt;f&lt;/g1&gt;와 &lt;g2&gt;g&lt;/g2&gt;는 같은 함수를 지칭합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The general form of a definition is &lt;g1&gt;def foo : α := bar&lt;/g1&gt; where
&lt;g2&gt;α&lt;/g2&gt; is the type returned from the expression &lt;g3&gt;bar&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144127Z" creationid="tlqk35" creationdate="20220321T144127Z">
        <seg>정의의 일반적인 형태는  &lt;g1&gt;def foo : α := bar&lt;/g1&gt;입니다. 여기서  &lt;g2&gt;α&lt;/g2&gt; 는 식 &lt;g3&gt;bar&lt;/g3&gt;로부터 반환되는 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The general form of a lambda expression is &lt;g1&gt;fun x : α =&gt; t&lt;/g1&gt;, where
the variable &lt;g2&gt;x&lt;/g2&gt; is a "bound variable": it is really a placeholder,
whose "scope" does not extend beyond the expression &lt;g3&gt;t&lt;/g3&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143328Z" creationid="tlqk35" creationdate="20220321T143328Z">
        <seg>람다 표현식의 일반적인 형태는 &lt;g1&gt;fun x : α =&gt; t&lt;/g1&gt;입니다. 여기서 변수 &lt;g2&gt;x&lt;/g2&gt;는 "구속변수"입니다. 이는 그것의 "범위"가 표현식  &lt;g3&gt;t&lt;/g3&gt; 안으로 제한되는 '자리차지자'일 뿐 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The goal is to support both mathematical reasoning and reasoning about complex systems, and to verify
claims in both domains.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131543Z" creationid="tlqk35" creationdate="20220321T131543Z">
        <seg>목표는 수학적 추론과 복잡한 시스템에 대한 추론을 모두 지원하고 양쪽 영역의 주장을 식별하게 만드는 겁이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The gold standard for supporting a mathematical claim is to provide a proof, and twentieth-century developments in logic
show most if not all conventional proof methods can be reduced to a small set of axioms and rules in any of a number of
foundational systems.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131234Z" creationid="tlqk35" creationdate="20220321T131234Z">
        <seg>수학 진술을 지지하기 위한 황금률은 증명을 제공하는 것이며 20세기 논리학의 발전은 기존은 몇 가지의 공리의 모임과 기초계의 몇 가지 규칙으로 축소될 수 있음을 거의 보여주었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The judicious use of Unicode improves
legibility, and all modern editors have great support for it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140114Z" creationid="tlqk35" creationdate="20220321T140114Z">
        <seg>분별있는 유니코드의 사용은 가독성을 개선합니다. 그리고 현대의 모든 편집기는 그것의 사용을 지원합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last expression, for example, denotes the function that takes
three types, &lt;g1&gt;α&lt;/g1&gt;, &lt;g2&gt;β&lt;/g2&gt;, and &lt;g3&gt;γ&lt;/g3&gt;, and two functions, &lt;g4&gt;g : β → γ&lt;/g4&gt;
and &lt;g5&gt;f : α → β&lt;/g5&gt;, and returns the composition of &lt;g6&gt;g&lt;/g6&gt; and &lt;g7&gt;f&lt;/g7&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143241Z" creationid="tlqk35" creationdate="20220321T143241Z">
        <seg>마지막 표현식은 세 유형 &lt;g1&gt;α&lt;/g1&gt;, &lt;g2&gt;β&lt;/g2&gt;, &lt;g3&gt;γ&lt;/g3&gt;과 두 함수 &lt;g4&gt;g : β → γ&lt;/g4&gt;과 &lt;g5&gt;f : α → β&lt;/g5&gt;을 받고 &lt;g6&gt;g&lt;/g6&gt;과 &lt;g7&gt;f&lt;/g7&gt;의 합성을 반환하는 함수를 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The list is indefinite, so
that there is a &lt;g6&gt;Type n&lt;/g6&gt; for every natural number &lt;g7&gt;n&lt;/g7&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141719Z" creationid="tlqk35" creationdate="20220321T141719Z">
        <seg>모든 자연수 &lt;g6&gt;n&lt;/g6&gt;에 대해 &lt;g7&gt;Type n&lt;/g7&gt;가 있어서 이런 리스트를 무한히 나열할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The name &lt;g1&gt;double&lt;/g1&gt; is defined as a
function that takes an input parameter &lt;g2&gt;x&lt;/g2&gt; of type &lt;g3&gt;Nat&lt;/g3&gt;, where the
result of the call is &lt;g4&gt;x + x&lt;/g4&gt;, so it is returning type &lt;g5&gt;Nat&lt;/g5&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143946Z" creationid="tlqk35" creationdate="20220321T143946Z">
        <seg>이름 &lt;g1&gt;double&lt;/g1&gt;은 &lt;g3&gt;Nat&lt;/g3&gt; 유형의 입력 매개변수 &lt;g2&gt;x&lt;/g2&gt;를 받고  호출의 결과로 &lt;g4&gt;x + x&lt;/g4&gt;인 함수로 정의되었습니다. 그래서 &lt;g5&gt;Nat&lt;/g5&gt; 유형을 반환합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The native version is much faster than
the web version, and is more flexible in other ways, too.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131909Z" creationid="tlqk35" creationdate="20220321T131909Z">
        <seg>원본 버전은 웹 버전보다 더 빠르고 다른 방식보다 유연합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The output of the
&lt;g2&gt;#check&lt;/g2&gt; command means that whenever &lt;g3&gt;α&lt;/g3&gt; has type &lt;g4&gt;Type n&lt;/g4&gt;,
&lt;g5&gt;List α&lt;/g5&gt; also has type &lt;g6&gt;Type n&lt;/g6&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142028Z" creationid="tlqk35" creationdate="20220321T142028Z">
        <seg>&lt;g2&gt;#check&lt;/g2&gt; 명령의 출력은 &lt;g3&gt;α&lt;/g3&gt;가 &lt;g4&gt;Type n&lt;/g4&gt;유형을 갖는 한 &lt;g5&gt;List α&lt;/g5&gt;도 &lt;g6&gt;Type n&lt;/g6&gt; 유형을 가짐을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameter list can be separated like this:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144304Z" creationid="tlqk35" creationdate="20220321T144304Z">
        <seg>매개변수 리스트는 이와 같이 나눠 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The presence of implicit arguments means that at times
there may be insufficient information to fix the meaning of an
expression precisely.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153430Z" creationid="tlqk35" creationdate="20220321T153430Z">
        <seg>암시적 인수의 존재는 현재로는 식의 정확한 의미를 고치기에 정보가 불충분함을 의미할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The process of instantiating these
"holes," or "placeholders," in a term is often known as
&lt;g1&gt;elaboration&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153423Z" creationid="tlqk35" creationdate="20220321T153423Z">
        <seg>이런 "구멍" 또는 "플레이스 홀더"의 인스턴스화 과정은 &lt;g1&gt;협력(elaboration)&lt;/g1&gt;으로 불리기도 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The right hand side &lt;g1&gt;bar&lt;/g1&gt; can be any expression, not just a lambda.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144213Z" creationid="tlqk35" creationdate="20220321T144213Z">
        <seg>우변 &lt;g1&gt;bar&lt;/g1&gt;는 lambda뿐만 아니라 어떤 식이든 될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second way to use Lean is to install and run it natively on your computer.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131857Z" creationid="tlqk35" creationdate="20220321T131857Z">
        <seg>Lean을 사용하는 두 번째 방법은 여러분의 컴퓨터에 설치하여 로컬로 실행하는 것 입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The short explanation is that types can depend on parameters.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150811Z" creationid="tlqk35" creationdate="20220321T150811Z">
        <seg>간단한 설명은 유형이 매개변수에 의존할 수 있다는 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The source
code, and instructions for building Lean, are available at
&lt;g1&gt;https://github.com/leanprover/lean4/&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131946Z" creationid="tlqk35" creationdate="20220321T131946Z">
        <seg>Lean을 만든 소스코드와  명령어들은 &lt;g1&gt;https://github.com/leanprover/lean4/&lt;/g1&gt;에서 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type algebra &lt;g2&gt;β → γ&lt;/g2&gt; and &lt;g3&gt;α → β&lt;/g3&gt; means it is a requirement
that the type of the output of the second function must match the
type of the input to the first function - which makes sense, otherwise
the two functions would not be composable.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144512Z" creationid="tlqk35" creationdate="20220321T144512Z">
        <seg> &lt;g2&gt;β → γ&lt;/g2&gt; 와 &lt;g3&gt;α → β&lt;/g3&gt;의 유형 대수는 두 번째 함수의 출력 유형이 첫 번째 함수의 입력 유형과 반드시 일치해야 한다는 요구를 같습니다. 이렇지 않다면 두 함수는 합성될 수 없을 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The unicode symbol &lt;g8&gt;×&lt;/g8&gt; for the Cartesian product
is entered as &lt;g9&gt;\times&lt;/g9&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140531Z" creationid="tlqk35" creationdate="20220321T140531Z">
        <seg>카테시안 곱을 나타내는 유니코드 기호 &lt;g8&gt;×&lt;/g8&gt;는 &lt;g9&gt;\times&lt;/g9&gt;을 입력하여 씁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then, you can construct lists of &lt;g1&gt;Nat&lt;/g1&gt; as follows.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152432Z" creationid="tlqk35" creationdate="20220321T152432Z">
        <seg>그럼 여러분은  &lt;c0&gt;Nat&lt;/c0&gt;의 리스트를 다음과 같이 생성할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are a few more things to notice here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140641Z" creationid="tlqk35" creationdate="20220321T140641Z">
        <seg>여기서 몇 개 더 짚고가야 할 것이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are currently two ways to use Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131811Z" creationid="tlqk35" creationdate="20220321T131811Z">
        <seg>현재 Lean을 사용하는 두 가지 방식이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There is only one
anonymous namespace at the root level.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150427Z" creationid="tlqk35" creationdate="20220321T150427Z">
        <seg>root 계층에서만 익명 이름 공간이 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These
aspects of Lean are explored in a companion tutorial to this one, &lt;g2&gt;Programming in Lean 4&lt;/g2&gt;, though computational
aspects of the system will make an appearance here.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131657Z" creationid="tlqk35" creationdate="20220321T131657Z">
        <seg>Lean의 이러한 측면은 이 교재의 동반 교재인 &lt;g2&gt;Programming in Lean&lt;/g2&gt;에서 더 찾아볼 수 있다. 그렇지만 여기에서도 린의 계산적인 측면을 찾아봅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These
types vary depending on the first argument, &lt;g11&gt;α&lt;/g11&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151505Z" creationid="tlqk35" creationdate="20220321T151500Z">
        <seg>이 유형은 첫번째 인수 &lt;g11&gt;α&lt;/g11&gt;에 따라 달라집니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>These can include ordinary mathematical theorems, as well as claims that pieces of hardware
or software, network protocols, and mechanical and hybrid systems meet their specifications.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131146Z" creationid="tlqk35" creationdate="20220321T131146Z">
        <seg>이 주장들은 평범한 수학적 정리뿐만 아니라 하드웨어와 소프트웨어, 네트워크 프로토콜, 역학적 복합적 시스템이 그들의 명세를 만족하는지에 대한 주장도 포함될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They are considered "the same" by Lean's type
checker, and Lean does its best to recognize and support these
identifications.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143738Z" creationid="tlqk35" creationdate="20220321T143738Z">
        <seg>이런 것은 린의 유형 검사기가 "같은"것으로 봅니다. 그리고 린은 유형을 인식하고 대조하는데 최선을 다합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think about what these expressions mean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142638Z" creationid="tlqk35" creationdate="20220321T142638Z">
        <seg>이 표현식의 의미에 대해 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of &lt;g1&gt;Type 0&lt;/g1&gt; as a universe of "small" or "ordinary" types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141626Z" creationid="tlqk35" creationdate="20220321T141626Z">
        <seg>&lt;g1&gt;Type 0&lt;/g1&gt;는 "작은" 또는 "평범한" 유형들의 세계라고 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think of this as the function from &lt;g7&gt;α&lt;/g7&gt; to &lt;g8&gt;β&lt;/g8&gt; which maps
any value &lt;g9&gt;x&lt;/g9&gt; to the value &lt;g10&gt;t&lt;/g10&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142516Z" creationid="tlqk35" creationdate="20220321T142516Z">
        <seg>이를  임의의 값 &lt;g9&gt;x&lt;/g9&gt;에서 값 &lt;g10&gt;t&lt;/g10&gt;로 대응시키는 &lt;g7&gt;α&lt;/g7&gt;에서 &lt;g8&gt;β&lt;/g8&gt;까지의 함수로 생각해보세요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This book is designed to teach you to develop and verify proofs in Lean.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132009Z" creationid="tlqk35" creationdate="20220321T132009Z">
        <seg>이 책은 Lean에서 증명을 검증하고 세울 수 있도록 당신을 가르치게끔 설계되었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This clarifies your intention, and Lean will flag an
error if the right-hand side of the definition does not have a matching
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144154Z" creationid="tlqk35" creationdate="20220321T144154Z">
        <seg>이것은 당신의 의도를 명확히 만들고 Lean은 정의의 우변에 일치하는 유형이 아닌 경우 에러를 표시할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This definition of &lt;g1&gt;ident&lt;/g1&gt; here has the same effect as the one
above.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153405Z" creationid="tlqk35" creationdate="20220321T153405Z">
        <seg>&lt;g1&gt;ident&lt;/g1&gt;의 이 정의는 여기서 위의 것과 같이 같은 효과를 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This explains the
type annotation of the function &lt;g5&gt;List&lt;/g5&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141932Z" creationid="tlqk35" creationdate="20220321T141932Z">
        <seg>이는 &lt;g5&gt;List&lt;/g5&gt;함수의 유형 표기를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This gives you a way of creating pairs of natural
numbers.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141135Z" creationid="tlqk35" creationdate="20220321T141135Z">
        <seg>이는 여러분에게 자연수의 쌍을 만들 수 있는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This gives you a way of extracting
its two components.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141215Z" creationid="tlqk35" creationdate="20220321T141215Z">
        <seg>이는 여러분에게 순서쌍의 두 성분을 추출하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This instructs Lean's elaborator to use the value
&lt;g4&gt;T&lt;/g4&gt; as the type of &lt;g5&gt;e&lt;/g5&gt; when trying to resolve implicit
arguments.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153538Z" creationid="tlqk35" creationdate="20220321T153538Z">
        <seg>이것은 린의 협력기가 암시적 인수를 해결하려고 시도할 때 &lt;g5&gt;e&lt;/g5&gt;의 유형으로 &lt;g4&gt;T&lt;/g4&gt;값을 사용하라고 지시합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is
known as an "implicit argument."</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152804Z" creationid="tlqk35" creationdate="20220321T152804Z">
        <seg>이것은 "암시적 인자"라고 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a central feature of dependent type theory: terms carry a lot
of information, and often some of that information can be inferred
from the context.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152741Z" creationid="tlqk35" creationdate="20220321T152741Z">
        <seg>이는 의존 유형론의 핵심 특징입니다. 항은 많은 정보를 전달하고 종종 그 정보의 몇은  맥락으로부터 추론될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is an instance of a &lt;g1&gt;dependent function type&lt;/g1&gt;, or &lt;g2&gt;dependent
arrow type&lt;/g2&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151554Z" creationid="tlqk35" creationdate="20220321T151554Z">
        <seg>이것은 &lt;g1&gt;의존적 함수 유형&lt;/g1&gt; 또는 &lt;g2&gt;의존적 방향 유형&lt;/g2&gt;의 개체입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is done by putting the arguments in
curly braces, as follows:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153159Z" creationid="tlqk35" creationdate="20220321T153159Z">
        <seg>이것은 다음과 같이 인수를 중괄호 안에 두는 것으로 할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This makes the first argument to &lt;g1&gt;ident&lt;/g1&gt; implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153306Z" creationid="tlqk35" creationdate="20220321T153306Z">
        <seg>이 첫 인수는 &lt;g1&gt;ident&lt;/g1&gt;를 암시적으로 만듭니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means &lt;g1&gt;compose&lt;/g1&gt; is a function that takes any two functions as input
arguments, so long as those functions each take only one input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144440Z" creationid="tlqk35" creationdate="20220321T144440Z">
        <seg>이는 &lt;g1&gt;compose&lt;/g1&gt;가 하나의 입력만 받는 함수인 경우에만 임의의 두 함수를 입력 인수로 받는 함수임을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means &lt;g3&gt;compose&lt;/g3&gt; can compose just about any 2 functions
so long as they each take one parameter, and so long as the type of
output of the second matches the input of the first.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144642Z" creationid="tlqk35" creationdate="20220321T144642Z">
        <seg>이는 &lt;g3&gt;compose&lt;/g3&gt;가 그들이 입력받는 두 함수 각각이 한 매개변수만 받고 두번째 함수의 출력 유형이 첫번째 함수의 입력 유형과 같은 한 합성할 수 있다는 것을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This might look more familiar to you if you know how functions work in
other programming languages.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143905Z" creationid="tlqk35" creationdate="20220321T143905Z">
        <seg>다른 프로그래밍언어에서 함수가 어떻게 동작하는지 안다면 이게 여러분에게 더 친숙하게 보일지 모르겠습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This provides
a quick and convenient way to begin experimenting with the system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131839Z" creationid="tlqk35" creationdate="20220321T131839Z">
        <seg>이는 실험적으로 시스템을 시작하는데 편리하고 빠른 방법을 제공합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This sets a very high standard: every rule of inference and every step of a
calculation has to be justified by appealing to prior definitions and theorems, all the way down to basic axioms and
rules.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131444Z" creationid="tlqk35" creationdate="20220321T131444Z">
        <seg>이것은 아주 높은 기준을 설정합니다. 모든 추론 규칙과 계산의 모든 계산 과정은 선행된(기초 공리와 규칙으로 거슬러 내려가는) 정의와 정리에 호소하여 정당화되어야 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial describes the current version of Lean, known as Lean 4.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131956Z" creationid="tlqk35" creationdate="20220321T131956Z">
        <seg>이 튜토리얼은 린의 현재 버전(린 4)를 설명합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial is an open access project maintained on Github.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134813Z" creationid="tlqk35" creationdate="20220321T134813Z">
        <seg>이 튜토리얼은 깃허브로 관리되어 누구나 접근할 수 있는 프로젝트입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This type depends on &lt;g8&gt;two&lt;/g8&gt; parameters: the type of the
elements in the vector (&lt;g9&gt;α : Type&lt;/g9&gt;) and the length of the vector
&lt;g10&gt;n : Nat&lt;/g10&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150957Z" creationid="tlqk35" creationdate="20220321T150957Z">
        <seg>이 유형은 &lt;g8&gt;두&lt;/g8&gt; 매개변수에 의존합니다. 하나는 벡터의 원소의 유형 (&lt;g9&gt;α : Type&lt;/g9&gt;)이고 또 다른 하나는 벡터의 길이&lt;g10&gt;n : Nat&lt;/g10&gt;입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Throughout the text you will find examples of Lean code like the one below:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134728Z" creationid="tlqk35" creationdate="20220321T134728Z">
        <seg>이 교재에서 여러분은 아래와 같은 린 코드 예제를 보게 될 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus namespaces
give you a way to manage names in your working environment.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150500Z" creationid="tlqk35" creationdate="20220321T150500Z">
        <seg>따라서 이름공간은 당신의 작업 환경 속에 이름을 관리하는 방법을 줍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Thus you can
view &lt;g9&gt;Nat.add&lt;/g9&gt; as a function that takes a natural number and returns
another function that takes a natural number and returns a natural
number.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140823Z" creationid="tlqk35" creationdate="20220321T140823Z">
        <seg>따라서 여러분은 &lt;g9&gt;Nat.add&lt;/g9&gt;은 자연수를 받아 자연수를 받고 자연수를 반환하는 또 다른 함수를 반환하는 함수로 볼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To define polymorphic constants, Lean allows you to
declare universe variables explicitly using the &lt;g1&gt;universe&lt;/g1&gt; command:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142059Z" creationid="tlqk35" creationdate="20220321T142059Z">
        <seg>다형적인 상수를 정의하기 위해 린은 여러분이 세계 변수를 &lt;g1&gt;universe&lt;/g1&gt; 명령을 명시적으로 사용하여 선언할 수 있게 했습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To start with, you will learn the logical system that Lean is
based on, a version of &lt;g1&gt;dependent type theory&lt;/g1&gt; that is powerful enough to prove almost any conventional mathematical
theorem, and expressive enough to do it in a natural way.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132047Z" creationid="tlqk35" creationdate="20220321T132047Z">
        <seg>먼저 여러분은 Lean이 기초하고 있는 논리 체계 즉 거의 모든 기존의 수학적 정리를 증명할 수 있을 만큼 강력하고 그것을 자연스럽게 할 수 있을 만큼 충분히 표현력이 뛰어난 &lt;g1&gt;의존유형론&lt;/g1&gt; 버전을 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference is an important part of Lean:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144052Z" creationid="tlqk35" creationdate="20220321T144052Z">
        <seg>유형 추론은 Lean의 중요한 기능입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types as objects</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141233Z" creationid="tlqk35" creationdate="20220321T141233Z">
        <seg>대상으로써 유형</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike &lt;g3&gt;section&lt;/g3&gt;, namespaces require a name.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150420Z" creationid="tlqk35" creationdate="20220321T150420Z">
        <seg>&lt;g3&gt;section&lt;/g3&gt;과는 달리, 이름공간은 이름이 필요합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables and Sections</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145123Z" creationid="tlqk35" creationdate="20220321T145123Z">
        <seg>변수와 섹션(Variables and Sections)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Variables can also be specified as implicit when they are declared with
the &lt;g1&gt;variable&lt;/g1&gt; command:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153351Z" creationid="tlqk35" creationdate="20220321T153351Z">
        <seg>&lt;g1&gt;variable&lt;/g1&gt; 명령으로 선언될 때 변수도 암시적으로 구체화될 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We are grateful to Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan
Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner,
Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey,
Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett for their contributions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134840Z" creationid="tlqk35" creationdate="20220321T134840Z">
        <seg>우리는 Ulrik Buchholz, Kevin Buzzard, Mario Carneiro, Nathan Carter, Eduardo Cavazos, Amine Chaieb, Joe Corneli, William DeMeo, Marcus Klaas de Vries, Ben Dyer, Gabriel Ebner, Anthony Hart, Simon Hudon, Sean Leather, Assia Mahboubi, Gihan Marasingha, Patrick Massot, Christopher John Mazey, Sebastian Ullrich, Floris van Doorn, Daniel Velleman, Théo Zimmerman, Paul Chisholm, and Chris Lovett에게 그들의 공헌에 대해 감사드립니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also use this device in function
definitions:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153258Z" creationid="tlqk35" creationdate="20220321T153258Z">
        <seg>우리는 함수 정의에서도 이 기능을 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We have
chosen a nontraditional name here only to avoid a clash of names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153335Z" creationid="tlqk35" creationdate="20220321T153335Z">
        <seg>우리는 여기서 이름의 충돌을 방지하기 위해 비관습적인 이름을 선택할 뿐이었습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We recommend running the examples and experimenting with the code on your own as you work through the chapters
that follow.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134950Z" creationid="tlqk35" creationdate="20220321T134950Z">
        <seg>우리는 여러분이 장을 따라 공부하면서 스스로 예제를 실행해보고 코드를 실험해보는 것을 추천합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What makes dependent type theory dependent?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150804Z" creationid="tlqk35" creationdate="20220321T150804Z">
        <seg>무엇이 의존 유형론을 의존적이게 만드는가?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What makes simple type theory powerful is that you can build new types
out of others.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135919Z" creationid="tlqk35" creationdate="20220321T135919Z">
        <seg>단순 유형론을 강력하게 만드는 것은 기본형 외의 여러분만의 새로운 유형을 만들 수 있다는 점입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What type should &lt;g2&gt;cons&lt;/g2&gt; have?</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151029Z" creationid="tlqk35" creationdate="20220321T151029Z">
        <seg>&lt;g2&gt;cons&lt;/g2&gt;는 어떤 유형을 가져야 할까요?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When &lt;g7&gt;β&lt;/g7&gt; doesn't
depend on &lt;g8&gt;a&lt;/g8&gt;, &lt;g9&gt;(a : α) → β&lt;/g9&gt; is no different from the type
&lt;g10&gt;α → β&lt;/g10&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152016Z" creationid="tlqk35" creationdate="20220321T152016Z">
        <seg> &lt;g7&gt;β&lt;/g7&gt;가  &lt;g8&gt;a&lt;/g8&gt;에 의존하지 않을 때, &lt;g9&gt;(a : α) → β&lt;/g9&gt;는 유형 &lt;g10&gt;α → β&lt;/g10&gt;유형과 다르지 않습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a
function takes an argument that can generally be inferred from
context, Lean allows you to specify that this argument should, by
default, be left implicit.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T153145Z" creationid="tlqk35" creationdate="20220321T153145Z">
        <seg>함수가 일반적으로 맥락으로부터 추론할 수 있는 인수를 받을 때, Lean은 여러분이 이런 인수가 암시적이어야 함을 명시하도록 기본적으로 허용합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When declared in this way, a variable stays in scope until the end of
the file you are working on.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150021Z" creationid="tlqk35" creationdate="20220321T150021Z">
        <seg>이 방식으로 선언되었을 때, 변수는 여러분이 작업하는 파일 끝까지를 범위로 가질 겁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the section is closed, the variables go out of scope, and cannot
be referenced any more.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150059Z" creationid="tlqk35" creationdate="20220321T150059Z">
        <seg>섹션이 닫히게 될 때, 변수들은 범위를 벗어나게 됩니다. 그리고 구분된 메모리 외에 아무것도 없게 됩니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When the value of &lt;g3&gt;β&lt;/g3&gt; depends on &lt;g4&gt;a&lt;/g4&gt; (as does, for
example, the expression &lt;g5&gt;β a&lt;/g5&gt; in the previous paragraph),
&lt;g6&gt;(a : α) → β&lt;/g6&gt; denotes a dependent function type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T151941Z" creationid="tlqk35" creationdate="20220321T151941Z">
        <seg>&lt;g3&gt;β&lt;/g3&gt;의 값이 &lt;g4&gt;a&lt;/g4&gt;에 의존할 때(예를 들어 앞 단락에서 식 &lt;g5&gt;β a&lt;/g5&gt;처럼), &lt;g6&gt;(a : α) → β&lt;/g6&gt;는 의존적 함수 유형을 나타냅니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you declare that you are working in the namespace &lt;g1&gt;Foo&lt;/g1&gt;, every
identifier you declare has a full name with prefix "&lt;g2&gt;Foo.&lt;/g2&gt;".</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150245Z" creationid="tlqk35" creationdate="20220321T150245Z">
        <seg>이름공간 &lt;g1&gt;Foo&lt;/g1&gt;에서 작업한다고 여러분이 선언할 때 여러분이 선언한 모든 식별자들은 "&lt;g2&gt;Foo.&lt;/g2&gt;"를 접미사로 갖습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With this reduction, there are two ways that a computer can help establish a claim: it can help
find a proof in the first place, and it can help verify that a purported proof is correct.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T131244Z" creationid="tlqk35" creationdate="20220321T131244Z">
        <seg>이러한 축소로부터 컴퓨터가 진술을 만드는데 도움을 주는 두 가지 방법이 있습니다. 처음부터 증명을 찾는 걸 돕는 것과 다른 하나는 제시한 증명이 옳은지 식별하도록 돕게 하는 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Within
the namespace, you can refer to identifiers by their shorter names,
but once you end the namespace, you have to use the longer names.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150359Z" creationid="tlqk35" creationdate="20220321T150359Z">
        <seg>이름공간 안에서 여러분은 식별자들을 그들의 약식 이름으로 부를 수 있습니다. 그러나 한번 이름공간에 끝에 오면 여러분은 더 긴 이름을 사용해야만 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You
can then invoke this function using:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143957Z" creationid="tlqk35" creationdate="20220321T143957Z">
        <seg>여러분은 이 함수를 다음과 같이 불러낼 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You
have already seen a nice example of this: the type &lt;g1&gt;List α&lt;/g1&gt; depends
on the argument &lt;g2&gt;α&lt;/g2&gt;, and this dependence is what distinguishes
&lt;g3&gt;List Nat&lt;/g3&gt; and &lt;g4&gt;List Bool&lt;/g4&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150838Z" creationid="tlqk35" creationdate="20220321T150838Z">
        <seg>여러분은 이것에 대한 멋진 예제를 보았습니다. 유형  &lt;g1&gt;List α&lt;/g1&gt; 는 인수 &lt;g2&gt;α&lt;/g2&gt;에 의존합니다. 여기서  &lt;g3&gt;List Nat&lt;/g3&gt;과 &lt;g4&gt;List Bool&lt;/g4&gt;을 구분하는 것은 이 의존입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
enter these particular ones with &lt;g13&gt;\a&lt;/g13&gt;, &lt;g14&gt;\b&lt;/g14&gt;, and &lt;g15&gt;\g&lt;/g15&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140633Z" creationid="tlqk35" creationdate="20220321T140633Z">
        <seg>여러분은 이들 중 특정한 것은 &lt;g13&gt;\a&lt;/g13&gt;, &lt;g14&gt;\b&lt;/g14&gt;과 &lt;g15&gt;\g&lt;/g15&gt;으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can
use the command &lt;g1&gt;#eval&lt;/g1&gt; to execute expressions, and it is the
preferred way of testing your functions.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143808Z" creationid="tlqk35" creationdate="20220321T143808Z">
        <seg>여러분은 &lt;g1&gt;#eval&lt;/g1&gt; 명령을 사용해 식을 실행할 수 있습니다. 그리고 이것은 당신의 함수를 시험하는 선호되는 방식입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also declare new constants for types:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141350Z" creationid="tlqk35" creationdate="20220321T141350Z">
        <seg>여러분은 유형들에 대해 새 상수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also define a function that takes another function as input.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144405Z" creationid="tlqk35" creationdate="20220321T144405Z">
        <seg>여러분은 또 다른 함수를 입력으로 받는 함수를 정의할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also pass types as parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143154Z" creationid="tlqk35" creationdate="20220321T143154Z">
        <seg>여러분은 매개변수로 유형도 전달할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use the
ASCII alternative &lt;g5&gt;-&gt;&lt;/g5&gt;, so the expressions &lt;g6&gt;Nat -&gt; Nat&lt;/g6&gt; and &lt;g7&gt;Nat →
Nat&lt;/g7&gt; mean the same thing.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140458Z" creationid="tlqk35" creationdate="20220321T140458Z">
        <seg>여러분은 ASCII 대체 표현으로 &lt;g5&gt;-&gt;&lt;/g5&gt;을 사용할 수 있습니다. 그래서 표현식 &lt;g6&gt;Nat -&gt; Nat&lt;/g6&gt;과 &lt;g7&gt;Nat → Nat&lt;/g7&gt;은 같은 식을 의미합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can avoid the universe command by providing the universe parameters when defining F.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142112Z" creationid="tlqk35" creationdate="20220321T142112Z">
        <seg>여러분은 F를 정의할 때 universe 매개변수를 제공하는 것으로 universe 명령을 쓰지 않을 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can combine multiple assignments by chaining &lt;g1&gt;let&lt;/g1&gt; statements:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144834Z" creationid="tlqk35" creationdate="20220321T144834Z">
        <seg>여러분은 다수의 할당을 &lt;g1&gt;let&lt;/g1&gt; 구문으로 연결함으로써 결합할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can declare variables of any type, not just &lt;g1&gt;Type&lt;/g1&gt; itself:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T145206Z" creationid="tlqk35" creationdate="20220321T145206Z">
        <seg>여러분은 &lt;g1&gt;Type&lt;/g1&gt; 그 자체뿐만 아니라 임의의 유형의 변수를 선언할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can enter the unicode
arrow &lt;g1&gt;→&lt;/g1&gt; by typing &lt;g2&gt;\to&lt;/g2&gt; or &lt;g3&gt;\r&lt;/g3&gt; or &lt;g4&gt;\-&gt;&lt;/g4&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140358Z" creationid="tlqk35" creationdate="20220321T140358Z">
        <seg>여러분은 유니코드 화살표 &lt;g1&gt;→&lt;/g1&gt;를 &lt;g2&gt;\to&lt;/g2&gt;을 치거나 or &lt;g3&gt;\r&lt;/g3&gt;또는 &lt;g4&gt;\-&gt;&lt;/g4&gt;으로 입력할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can evaluate a lambda function by passing the required parameters:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142224Z" creationid="tlqk35" creationdate="20220321T142224Z">
        <seg>여러분은 필요한 매개변수를 람다 함수에 넘겨줌으로써 값을 평가할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can omit the type declarations when Lean has enough information to
infer it.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144044Z" creationid="tlqk35" creationdate="20220321T144044Z">
        <seg>Lean이 유형을 추론하기에 충분한 정보를 갖고있을 때 여러분은 유형 선언을 생략할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can pass functions as parameters and by giving them names &lt;g1&gt;f&lt;/g1&gt;
and &lt;g2&gt;g&lt;/g2&gt; you can then use those functions in the implementation:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143134Z" creationid="tlqk35" creationdate="20220321T143134Z">
        <seg>여러분은 매개변수로 함수의 이름  &lt;g1&gt;f&lt;/g1&gt;과 &lt;g2&gt;g&lt;/g2&gt; 을 주는 것으로 함수를 전달할 수 있습니다.  그러면 구현에서 이들 함수를 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can probably guess what this one will do.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144354Z" creationid="tlqk35" creationdate="20220321T144354Z">
        <seg>여러분은 이 정의가 아마 뭘 할 지 추측할 수 있을 거예요.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can see that each one of the expressions above is an object of
type &lt;g1&gt;Type&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141344Z" creationid="tlqk35" creationdate="20220321T141344Z">
        <seg>여러분도 보다시피 위 각각의 표현식은 &lt;g1&gt;Type&lt;/g1&gt; 유형입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can therefore proceed as
though &lt;g2&gt;α&lt;/g2&gt;, &lt;g3&gt;β&lt;/g3&gt;, &lt;g4&gt;γ&lt;/g4&gt;, &lt;g5&gt;g&lt;/g5&gt;, &lt;g6&gt;f&lt;/g6&gt;, &lt;g7&gt;h&lt;/g7&gt;, and &lt;g8&gt;x&lt;/g8&gt; are fixed
objects when you write your definitions, and let Lean abstract the
definitions for you automatically.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150013Z" creationid="tlqk35" creationdate="20220321T150013Z">
        <seg>그러므로 여러분은 여러분의 정의를 작성할 때  &lt;g2&gt;α&lt;/g2&gt;, &lt;g3&gt;β&lt;/g3&gt;, &lt;g4&gt;γ&lt;/g4&gt;, &lt;g5&gt;g&lt;/g5&gt;, &lt;g6&gt;f&lt;/g6&gt;, &lt;g7&gt;h&lt;/g7&gt;, &lt;g8&gt;x&lt;/g8&gt;가 고정된 대상임에도 사용할 수 있습니다. 그리고 lean이 여러분을 위해 자동으로 정의를 축약할 수 있게 합니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can type
things into the editor and modify the examples, and Lean will check the results and provide feedback continuously as you
type.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T134940Z" creationid="tlqk35" creationdate="20220321T134940Z">
        <seg>여러분은 편집기에 무언가를 치거나 예제를 수정할 수 있습니다. 그리고 린은 여러분이 치는 동안 지속적으로 결과를 확인하고 피드백을 제공할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use &lt;g9&gt;⟨a, b⟩&lt;/g9&gt; or &lt;g10&gt;Sigma.mk a b&lt;/g10&gt; to create a
dependent pair.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T152318Z" creationid="tlqk35" creationdate="20220321T152318Z">
        <seg>여러분은 &lt;g9&gt;⟨a, b⟩&lt;/g9&gt; 또는 &lt;g10&gt;Sigma.mk a b&lt;/g10&gt;를 종속적 쌍을 만드는데 쓸 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can use other more interesting expressions inside a &lt;g1&gt;def&lt;/g1&gt;:</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T144344Z" creationid="tlqk35" creationdate="20220321T144344Z">
        <seg>여러분은 다른 더 흥미로운 식을 &lt;g1&gt;def&lt;/g1&gt; 안에 사용할 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can, in general, leave off the
type annotation and let Lean infer it for you.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T142754Z" creationid="tlqk35" creationdate="20220321T142754Z">
        <seg>일반적으로 여러분도 유형 표기를 빼고 린에게 유형을 추론하게 둘 수 있습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do not have to indent the lines within a section.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T150121Z" creationid="tlqk35" creationdate="20220321T150121Z">
        <seg>섹션 안에서 줄에 들여쓰기를 하거나 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have actually come up against one of the most subtle aspects of
Lean's typing system.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141553Z" creationid="tlqk35" creationdate="20220321T141553Z">
        <seg>여러분은 린의 유형화 시스템의 가장 미묘한 면 중 하나를 마주쳤습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have seen that if you have &lt;g1&gt;m : Nat&lt;/g1&gt; and &lt;g2&gt;n : Nat&lt;/g2&gt;, then
&lt;g3&gt;(m, n)&lt;/g3&gt; denotes the ordered pair of &lt;g4&gt;m&lt;/g4&gt; and &lt;g5&gt;n&lt;/g5&gt; which is of
type &lt;g6&gt;Nat × Nat&lt;/g6&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T141120Z" creationid="tlqk35" creationdate="20220321T141120Z">
        <seg>여러분은 &lt;g1&gt;m : Nat&lt;/g1&gt;과  &lt;g2&gt;n : Nat&lt;/g2&gt;이면, &lt;g3&gt;(m, n)&lt;/g3&gt;은 &lt;g6&gt;Nat × Nat&lt;/g6&gt;유형인 &lt;g4&gt;m&lt;/g4&gt;과 &lt;g5&gt;n&lt;/g5&gt;의 순서쌍을 가리킨다는 것을 보았습니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You should try
declaring some constants and type checking some expressions on your
own.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T135902Z" creationid="tlqk35" creationdate="20220321T135902Z">
        <seg>여러분은 스스로 몇몇 상수를 선언하고 몇 가지 식의 유형을 확인해보길 바랍니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will generally use lower-case Greek
letters like &lt;g10&gt;α&lt;/g10&gt;, &lt;g11&gt;β&lt;/g11&gt;, and &lt;g12&gt;γ&lt;/g12&gt; to range over types.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T140558Z" creationid="tlqk35" creationdate="20220321T140558Z">
        <seg>여러분은 유형을 포괄하기 위해  &lt;g10&gt;α&lt;/g10&gt;, &lt;g11&gt;β&lt;/g11&gt;, &lt;g12&gt;γ&lt;/g12&gt;같은 그리스 소문자 자주 사용할 것입니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will learn various methods to support this in &lt;g1&gt;dependent type
theory&lt;/g1&gt;.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T132230Z" creationid="tlqk35" creationdate="20220321T132230Z">
        <seg>여러분은 &lt;g1&gt;의존 유형론&lt;/g1&gt;에서 이를 지원하는 다양한 방법에 대해 배웁니다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will see later how these terms are evaluated.</seg>
      </tuv>
      <tuv lang="ko" changeid="tlqk35" changedate="20220321T143658Z" creationid="tlqk35" creationdate="20220321T143658Z">
        <seg>여러분은 나중에 이 항들이 어떻게 평가되는지 볼 겁니다.</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
